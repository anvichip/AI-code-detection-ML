{"code": "class Solution {\n    public int maxSum(int[] nums) {\n    int ans = -1;\n    Map<Integer,List<Integer>> ump = new HashMap<>();\n    for(int i = 0; i < nums.length; ++i){\n        int t = nums[i], maxDigit = 0;\n        while(t != 0){ //evaluate max digit in the number\n            maxDigit = Math.max(t%10, maxDigit);\n            t = t/10;\n        }\n        if(!ump.containsKey(maxDigit)) ump.put(maxDigit, new ArrayList<>());\n        ump.get(maxDigit).add(nums[i]); // add the number to the map \n    }\n    for(Map.Entry<Integer, List<Integer>> entry: ump.entrySet()){\n        entry.getValue().sort(Comparator.reverseOrder()); //to find max two number in each max digit \n        if(entry.getValue().size() >= 2) ans = Math.max(ans, entry.getValue().get(0) + entry.getValue().get(1)); //sum max two number and take max\n    }\n    return ans;\n    }\n}"}
{"code": "class Solution:\n    def maxSum(self, nums: List[int]) -> int:\n        max_by_digit = defaultdict(int)\n        max_sum = -1\n\n        for num in nums:\n            digit = max(str(num))\n\n            if digit in max_by_digit:\n                max_sum = max(max_sum, max_by_digit[digit] + num)\n\n            max_by_digit[digit] = max(max_by_digit[digit], num)\n\n        return max_sum"}
{"code": "class Solution {\n    public:\n        int maxSum(vector<int>& nums) {\n        int res = -1, max_num[10] = {};\n        for (auto num : nums) {\n            int max_d = 0;\n            for (int v = num; v; v /= 10)\n                max_d = max(max_d, v % 10);\n            if (max_num[max_d])\n                res = max(res, max_num[max_d] + num);\n            max_num[max_d] = max(max_num[max_d], num);\n        }\n        return res;\n    }\n};"}
{"code": "class Solution {\n    public String finalString(String s) {\n        StringBuilder nm=new StringBuilder();\n        for(char c:s.toCharArray())\n        {\n            if(c=='i')\n            {\n                nm.reverse();\n            }\n            else\n            {\n                nm.append(c);\n            }\n        }\n        return nm.toString();\n    }\n}"}
{"code": "class Solution:\n    def finalString(self, s: str) -> str:\n        while \"i\" in s:\n            index=s.index(\"i\")\n\n            #first half and second half\n            first=s[:index][::-1]\n            second=s[index+1:]\n\n            s=\"\".join([first,second])\n        return s"}
{"code": "class Solution {\npublic:\n    string finalString(const string &s) {\n        string a, b;\n        for (char ch : s)\n            if (ch == 'i')\n                swap(a, b);\n            else\n                a += ch;\n        return string(rbegin(b), rend(b)) + a;\n    }\n};"}
{"code": "class Solution {\n    int minAbsoluteDifference(List<Integer> nums, int x) {\n        int ans = Integer.MAX_VALUE;\n        TreeSet<Integer> s = new TreeSet<>();\n        for(int i = x; i < nums.size(); ++i){\n            s.add(nums.get(i-x));\n            Integer high = s.ceiling(nums.get(i)), low = s.floor(nums.get(i));\n            if(high != null) ans = Math.min(ans, Math.abs(nums.get(i) - high));\n            if(low != null) ans = Math.min(ans, Math.abs(nums.get(i) - low));\n        }\n        return ans;\n    }\n}"}
{"code": "class Solution:\n  def minAbsoluteDifference(self, nums: List[int], x: int) -> int:\n    if x == 0:\n      return 0\n\n    arr, best_dist = SortedList([]), float('inf')\n    for i in range(x, len(nums)):\n      arr.add(nums[i - x])\n      v = nums[i]\n\n      pos = arr.bisect_left(v)\n      if pos < len(arr):\n        best_dist = min(best_dist, abs(arr[pos] - v))\n      if pos > 0:\n        best_dist = min(best_dist, abs(arr[pos - 1] - v))\n    \n    return best_dist"}
{"code": "class Solution {\npublic:\n    int minAbsoluteDifference(vector<int>& nums, int x) {\n        int ans = INT_MAX;\n        set<int> s;\n        for(int i = x; i < nums.size(); ++i){\n            s.insert(nums[i-x]);\n            auto it = s.upper_bound(nums[i]);\n            if(it != s.end()) ans = min(ans, abs(nums[i] - *it));\n            if(it != s.begin()) ans = min(ans, abs(nums[i] - *prev(it)));\n        }\n        return ans;\n    }\n};"}
{"code": "class Solution {\n    public ListNode doubleIt(ListNode head) {\n        if (head.val > 4)\n            head = new ListNode(0, head);\n        for(ListNode node = head; node != null; node = node.next) {\n            node.val = (node.val * 2) % 10;\n            if (node.next != null && node.next.val > 4)\n                node.val++;\n        }\n        return head;\n    }\n}"}
{"code": "class Solution:\n    def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if head.val > 4:\n            head = ListNode(0, head)\n        node = head\n        while node:\n            node.val = (node.val * 2) % 10\n            if node.next and node.next.val > 4:\n                node.val += 1\n            node = node.next\n        return head"}
{"code": "class Solution {\npublic:\n    ListNode* doubleIt(ListNode* head) {\n        if (head->val > 4)\n            head = new ListNode(0, head);\n        for(ListNode* node = head; node; node = node->next) {\n            node->val = (node->val * 2) % 10;\n            if (node->next && node->next->val > 4)\n                node->val++;\n        }\n        return head;\n    }\n};"}
{"code": "class Solution {\n    static final int MOD = 1000000007;\n\n    public int maximumScore(List<Integer> nums, int k) {\n        int n = nums.size();\n\n        int upper = Collections.max(nums) + 1;\n\n        boolean[] prime = new boolean[upper];\n        int[] primeScore = new int[upper];\n        Arrays.fill(prime, true);\n        prime[0] = prime[1] = false;\n        for (int i = 2; i < upper; i++) {\n            if (prime[i]) {\n                for (int j = i; j < upper; j += i) {\n                    primeScore[j]++;\n                    prime[j] = false;\n                }\n            }\n        }\n\n        int[] nextGreaterElement = new int[n];\n        Arrays.fill(nextGreaterElement, n);\n        Stack<Integer> s = new Stack<>();\n        for (int i = n - 1; i >= 0; i--) {\n            while (!s.empty() && primeScore[nums.get(i)] >= primeScore[nums.get(s.peek())]) {\n                s.pop();\n            }\n            nextGreaterElement[i] = s.empty() ? n : s.peek();\n            s.push(i);\n        }\n\n        int[] prevGreaterOrEqualElement = new int[n];\n        Arrays.fill(prevGreaterOrEqualElement, -1);\n        s = new Stack<>();\n        for (int i = 0; i < n; i++) {\n            while (!s.empty() && primeScore[nums.get(i)] > primeScore[nums.get(s.peek())]) {\n                s.pop();\n            }\n            prevGreaterOrEqualElement[i] = s.empty() ? -1 : s.peek();\n            s.push(i);\n        }\n\n        int res = 1;\n        int[][] tuples = new int[n][2];\n        for (int i = 0; i < n; i++) {\n            tuples[i][0] = nums.get(i);\n            tuples[i][1] = i;\n        }\n        Arrays.sort(tuples, new Comparator<int[]>() {\n            public int compare(int[] a, int[] b) {\n                return b[0] - a[0];\n            }\n        });\n        for (int i = 0; i < n; i++) {\n            int num = tuples[i][0];\n            int idx = tuples[i][1];\n            int operations = Math.min((idx - prevGreaterOrEqualElement[idx]) * (nextGreaterElement[idx] - idx), k);\n            res = (int)((1L * res * pow(num, operations)) % MOD);\n            k -= operations;\n            if (k == 0) {\n                return res;\n            }\n        }\n\n        return res;\n    }\n\n    public int pow(int x, int n) {\n        int res = 1;\n        while (n > 0) {\n            if (n % 2 == 1) {\n                res = (int)((1L * res * x) % MOD);\n            }\n            x = (int)((1L * x * x) % MOD);\n            n /= 2;\n        }\n        return res;\n    }\n}"}
{"code": "class Solution: \n    MOD = 1000000007\n\n    def maximumScore(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n\n        upper = max(nums) + 1\n\n        prime = [True]*upper\n        prime[0] = prime[1] = False\n        primeScore = [0]*upper\n        for i in range(2, upper):\n            if prime[i]:\n                for j in range(i, upper, i):\n                    primeScore[j] += 1\n                    prime[j] = False\n\n        nextGreaterElement = [n]*n\n        s = []\n        for i in range(n - 1, -1, -1):\n            while s and primeScore[nums[i]] >= primeScore[nums[s[-1]]]:\n                s.pop()\n            nextGreaterElement[i] = s[-1] if s else n\n            s.append(i)\n\n        prevGreaterOrEqualElement = [-1]*n\n        s = []\n        for i in range(n):\n            while s and primeScore[nums[i]] > primeScore[nums[s[-1]]]:\n                s.pop()\n            prevGreaterOrEqualElement[i] = s[-1] if s else -1\n            s.append(i)\n\n        res = 1\n        tuples = [[nums[i], i] for i in range(n)]\n        tuples.sort(reverse=True)\n        for num, idx in tuples:\n            operations = min((idx - prevGreaterOrEqualElement[idx]) * (nextGreaterElement[idx] - idx), k)\n            res = (res * self.pow(num, operations)) % self.MOD\n            k -= operations\n            if k == 0:\n                return res\n\n        return res\n\n    def pow(self, x: int, n: int) -> int:\n        res = 1\n        while n > 0:\n            if n % 2 == 1:\n                res = (res * x) % self.MOD\n            x = (x * x) % self.MOD\n            n //= 2\n        return res"}
{"code": "class Solution {\npublic:\n    const int MOD = 1000000007;\n\n    int maximumScore(vector<int>& nums, int k) {\n        int n = nums.size();\n\n        int upper = *max_element(nums.begin(), nums.end()) + 1;\n\n        vector<bool> prime(upper, true);\n        prime[0] = prime[1] = false;\n        vector<int> primeScore(upper, 0);\n        for (int i = 2; i < upper; i++) {\n            if (prime[i]) {\n                for (int j = i; j < upper; j += i) {\n                    primeScore[j]++;\n                    prime[j] = false;\n                }\n            }\n        }\n\n        vector<int> nextGreaterElement(n, n);\n        stack<int> s;\n        for (int i = n - 1; i >= 0; i--) {\n            while (!s.empty() && primeScore[nums[i]] >= primeScore[nums[s.top()]]) {\n                s.pop();\n            }\n            nextGreaterElement[i] = s.empty() ? n : s.top();\n            s.push(i);\n        }\n\n        vector<int> prevGreaterOrEqualElement(n, -1);\n        s = stack<int>();\n        for (int i = 0; i < n; i++) {\n            while (!s.empty() && primeScore[nums[i]] > primeScore[nums[s.top()]]) {\n                s.pop();\n            }\n            prevGreaterOrEqualElement[i] = s.empty() ? -1 : s.top();\n            s.push(i);\n        }\n\n        int res = 1;\n        vector<pair<int, int>> tuples(n);\n        for (int i = 0; i < n; i++) {\n            tuples[i].first = nums[i];\n            tuples[i].second = i;\n        }\n        sort(tuples.rbegin(), tuples.rend());\n        for (const auto& [num, i] : tuples) {\n            int operations = min((i - prevGreaterOrEqualElement[i]) * (nextGreaterElement[i] - i), k);\n            res = (int)((1L * res * pow(num, operations)) % MOD);\n            k -= operations;\n            if (k == 0) {\n                return res;\n            }\n        }\n\n        return res;\n    }\n\n    int pow(int x, int n) {\n        int res = 1;\n        while (n > 0) {\n            if (n % 2 == 1) {\n                res = (int)((1L * res * x) % MOD);\n            }\n            x = (int)((1L * x * x) % MOD);\n            n /= 2;\n        }\n        return res;\n    }\n};"}
{"code": "class Solution {\n    public long findMaximumElegance(int[][] A, int k) {\n        Arrays.sort(A, (a, b) -> b[0] - a[0]);\n        long res = 0, cur = 0;\n        List<Integer> dup = new ArrayList<>();\n        Set<Integer> seen = new HashSet<>();\n        for (int i = 0; i < A.length; ++i) {\n            if (i < k) {\n                if (seen.contains(A[i][1])) {\n                    dup.add(A[i][0]);\n                }\n                cur += A[i][0];\n            } else if (!seen.contains(A[i][1])) {\n                if (dup.isEmpty()) break;\n                cur += A[i][0] - dup.remove(dup.size() - 1);\n            }\n            seen.add(A[i][1]);\n            res = Math.max(res, cur + 1L * seen.size() * seen.size());\n        }\n        return res;\n    }\n}"}
{"code": "class Solution:\n    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:\n        items = sorted(items, key=lambda v: -v[0])\n        res = cur = 0\n        A = []\n        seen = set()\n        for i, (p, c) in enumerate(items):\n            if i < k:\n                if c in seen:\n                    A.append(p)\n                cur += p\n            elif c not in seen:\n                if not A: break\n                cur += p - A.pop()\n            seen.add(c)\n            res = max(res, cur + len(seen) * len(seen))\n        return res"}
{"code": "class Solution {\npublic:\n    long long findMaximumElegance(vector<vector<int>>& A, int k) {\n        sort(A.begin(), A.end(), [](const vector<int>& a, const vector<int>& b) {\n            return a[0] > b[0];\n        });\n        long long res = 0, cur = 0;\n        vector<int> dup;\n        unordered_set<int> seen;\n        for (int i = 0; i < A.size(); ++i) {\n            if (i < k) {\n                if (seen.count(A[i][1])) {\n                    dup.push_back(A[i][0]);\n                }\n                cur += A[i][0];\n            } else if (seen.find(A[i][1]) == seen.end()) {\n                if (dup.empty()) break;\n                cur += A[i][0] - dup.back();\n                dup.pop_back();\n            }\n            seen.insert(A[i][1]);\n            res = fmax(res, cur + 1L * seen.size() * seen.size());\n        }\n        return res;\n    }\n};"}
{"code": "class Solution {\n    public int maxSum(int[] nums) {\n    int ans = -1;\n    Map<Integer,List<Integer>> ump = new HashMap<>();\n    for(int i = 0; i < nums.length; ++i){\n        int t = nums[i], maxDigit = 0;\n        while(t != 0){ //evaluate max digit in the number\n            maxDigit = Math.max(t%10, maxDigit);\n            t = t/10;\n        }\n        if(!ump.containsKey(maxDigit)) ump.put(maxDigit, new ArrayList<>());\n        ump.get(maxDigit).add(nums[i]); // add the number to the map \n    }\n    for(Map.Entry<Integer, List<Integer>> entry: ump.entrySet()){\n        entry.getValue().sort(Comparator.reverseOrder()); //to find max two number in each max digit \n        if(entry.getValue().size() >= 2) ans = Math.max(ans, entry.getValue().get(0) + entry.getValue().get(1)); //sum max two number and take max\n    }\n    return ans;\n    }\n}"}
{"code": "class Solution:\n    def maxSum(self, nums: List[int]) -> int:\n        max_by_digit = defaultdict(int)\n        max_sum = -1\n\n        for num in nums:\n            digit = max(str(num))\n\n            if digit in max_by_digit:\n                max_sum = max(max_sum, max_by_digit[digit] + num)\n\n            max_by_digit[digit] = max(max_by_digit[digit], num)\n\n        return max_sum"}
{"code": "class Solution {\n    public:\n        int maxSum(vector<int>& nums) {\n        int res = -1, max_num[10] = {};\n        for (auto num : nums) {\n            int max_d = 0;\n            for (int v = num; v; v /= 10)\n                max_d = max(max_d, v % 10);\n            if (max_num[max_d])\n                res = max(res, max_num[max_d] + num);\n            max_num[max_d] = max(max_num[max_d], num);\n        }\n        return res;\n    }\n};"}
{"code": "class Solution {\n    public String finalString(String s) {\n        StringBuilder nm=new StringBuilder();\n        for(char c:s.toCharArray())\n        {\n            if(c=='i')\n            {\n                nm.reverse();\n            }\n            else\n            {\n                nm.append(c);\n            }\n        }\n        return nm.toString();\n    }\n}"}
{"code": "class Solution:\n    def finalString(self, s: str) -> str:\n        while \"i\" in s:\n            index=s.index(\"i\")\n\n            #first half and second half\n            first=s[:index][::-1]\n            second=s[index+1:]\n\n            s=\"\".join([first,second])\n        return s"}
{"code": "class Solution {\npublic:\n    string finalString(const string &s) {\n        string a, b;\n        for (char ch : s)\n            if (ch == 'i')\n                swap(a, b);\n            else\n                a += ch;\n        return string(rbegin(b), rend(b)) + a;\n    }\n};"}
{"code": "class Solution {\n    int minAbsoluteDifference(List<Integer> nums, int x) {\n        int ans = Integer.MAX_VALUE;\n        TreeSet<Integer> s = new TreeSet<>();\n        for(int i = x; i < nums.size(); ++i){\n            s.add(nums.get(i-x));\n            Integer high = s.ceiling(nums.get(i)), low = s.floor(nums.get(i));\n            if(high != null) ans = Math.min(ans, Math.abs(nums.get(i) - high));\n            if(low != null) ans = Math.min(ans, Math.abs(nums.get(i) - low));\n        }\n        return ans;\n    }\n}"}
{"code": "class Solution:\n  def minAbsoluteDifference(self, nums: List[int], x: int) -> int:\n    if x == 0:\n      return 0\n\n    arr, best_dist = SortedList([]), float('inf')\n    for i in range(x, len(nums)):\n      arr.add(nums[i - x])\n      v = nums[i]\n\n      pos = arr.bisect_left(v)\n      if pos < len(arr):\n        best_dist = min(best_dist, abs(arr[pos] - v))\n      if pos > 0:\n        best_dist = min(best_dist, abs(arr[pos - 1] - v))\n    \n    return best_dist"}
{"code": "class Solution {\npublic:\n    int minAbsoluteDifference(vector<int>& nums, int x) {\n        int ans = INT_MAX;\n        set<int> s;\n        for(int i = x; i < nums.size(); ++i){\n            s.insert(nums[i-x]);\n            auto it = s.upper_bound(nums[i]);\n            if(it != s.end()) ans = min(ans, abs(nums[i] - *it));\n            if(it != s.begin()) ans = min(ans, abs(nums[i] - *prev(it)));\n        }\n        return ans;\n    }\n};"}
{"code": "class Solution {\n    public ListNode doubleIt(ListNode head) {\n        if (head.val > 4)\n            head = new ListNode(0, head);\n        for(ListNode node = head; node != null; node = node.next) {\n            node.val = (node.val * 2) % 10;\n            if (node.next != null && node.next.val > 4)\n                node.val++;\n        }\n        return head;\n    }\n}"}
{"code": "class Solution:\n    def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if head.val > 4:\n            head = ListNode(0, head)\n        node = head\n        while node:\n            node.val = (node.val * 2) % 10\n            if node.next and node.next.val > 4:\n                node.val += 1\n            node = node.next\n        return head"}
{"code": "class Solution {\npublic:\n    ListNode* doubleIt(ListNode* head) {\n        if (head->val > 4)\n            head = new ListNode(0, head);\n        for(ListNode* node = head; node; node = node->next) {\n            node->val = (node->val * 2) % 10;\n            if (node->next && node->next->val > 4)\n                node->val++;\n        }\n        return head;\n    }\n};"}
{"code": "class Solution {\n    static final int MOD = 1000000007;\n\n    public int maximumScore(List<Integer> nums, int k) {\n        int n = nums.size();\n\n        int upper = Collections.max(nums) + 1;\n\n        boolean[] prime = new boolean[upper];\n        int[] primeScore = new int[upper];\n        Arrays.fill(prime, true);\n        prime[0] = prime[1] = false;\n        for (int i = 2; i < upper; i++) {\n            if (prime[i]) {\n                for (int j = i; j < upper; j += i) {\n                    primeScore[j]++;\n                    prime[j] = false;\n                }\n            }\n        }\n\n        int[] nextGreaterElement = new int[n];\n        Arrays.fill(nextGreaterElement, n);\n        Stack<Integer> s = new Stack<>();\n        for (int i = n - 1; i >= 0; i--) {\n            while (!s.empty() && primeScore[nums.get(i)] >= primeScore[nums.get(s.peek())]) {\n                s.pop();\n            }\n            nextGreaterElement[i] = s.empty() ? n : s.peek();\n            s.push(i);\n        }\n\n        int[] prevGreaterOrEqualElement = new int[n];\n        Arrays.fill(prevGreaterOrEqualElement, -1);\n        s = new Stack<>();\n        for (int i = 0; i < n; i++) {\n            while (!s.empty() && primeScore[nums.get(i)] > primeScore[nums.get(s.peek())]) {\n                s.pop();\n            }\n            prevGreaterOrEqualElement[i] = s.empty() ? -1 : s.peek();\n            s.push(i);\n        }\n\n        int res = 1;\n        int[][] tuples = new int[n][2];\n        for (int i = 0; i < n; i++) {\n            tuples[i][0] = nums.get(i);\n            tuples[i][1] = i;\n        }\n        Arrays.sort(tuples, new Comparator<int[]>() {\n            public int compare(int[] a, int[] b) {\n                return b[0] - a[0];\n            }\n        });\n        for (int i = 0; i < n; i++) {\n            int num = tuples[i][0];\n            int idx = tuples[i][1];\n            int operations = Math.min((idx - prevGreaterOrEqualElement[idx]) * (nextGreaterElement[idx] - idx), k);\n            res = (int)((1L * res * pow(num, operations)) % MOD);\n            k -= operations;\n            if (k == 0) {\n                return res;\n            }\n        }\n\n        return res;\n    }\n\n    public int pow(int x, int n) {\n        int res = 1;\n        while (n > 0) {\n            if (n % 2 == 1) {\n                res = (int)((1L * res * x) % MOD);\n            }\n            x = (int)((1L * x * x) % MOD);\n            n /= 2;\n        }\n        return res;\n    }\n}"}
{"code": "class Solution: \n    MOD = 1000000007\n\n    def maximumScore(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n\n        upper = max(nums) + 1\n\n        prime = [True]*upper\n        prime[0] = prime[1] = False\n        primeScore = [0]*upper\n        for i in range(2, upper):\n            if prime[i]:\n                for j in range(i, upper, i):\n                    primeScore[j] += 1\n                    prime[j] = False\n\n        nextGreaterElement = [n]*n\n        s = []\n        for i in range(n - 1, -1, -1):\n            while s and primeScore[nums[i]] >= primeScore[nums[s[-1]]]:\n                s.pop()\n            nextGreaterElement[i] = s[-1] if s else n\n            s.append(i)\n\n        prevGreaterOrEqualElement = [-1]*n\n        s = []\n        for i in range(n):\n            while s and primeScore[nums[i]] > primeScore[nums[s[-1]]]:\n                s.pop()\n            prevGreaterOrEqualElement[i] = s[-1] if s else -1\n            s.append(i)\n\n        res = 1\n        tuples = [[nums[i], i] for i in range(n)]\n        tuples.sort(reverse=True)\n        for num, idx in tuples:\n            operations = min((idx - prevGreaterOrEqualElement[idx]) * (nextGreaterElement[idx] - idx), k)\n            res = (res * self.pow(num, operations)) % self.MOD\n            k -= operations\n            if k == 0:\n                return res\n\n        return res\n\n    def pow(self, x: int, n: int) -> int:\n        res = 1\n        while n > 0:\n            if n % 2 == 1:\n                res = (res * x) % self.MOD\n            x = (x * x) % self.MOD\n            n //= 2\n        return res"}
{"code": "class Solution {\npublic:\n    const int MOD = 1000000007;\n\n    int maximumScore(vector<int>& nums, int k) {\n        int n = nums.size();\n\n        int upper = *max_element(nums.begin(), nums.end()) + 1;\n\n        vector<bool> prime(upper, true);\n        prime[0] = prime[1] = false;\n        vector<int> primeScore(upper, 0);\n        for (int i = 2; i < upper; i++) {\n            if (prime[i]) {\n                for (int j = i; j < upper; j += i) {\n                    primeScore[j]++;\n                    prime[j] = false;\n                }\n            }\n        }\n\n        vector<int> nextGreaterElement(n, n);\n        stack<int> s;\n        for (int i = n - 1; i >= 0; i--) {\n            while (!s.empty() && primeScore[nums[i]] >= primeScore[nums[s.top()]]) {\n                s.pop();\n            }\n            nextGreaterElement[i] = s.empty() ? n : s.top();\n            s.push(i);\n        }\n\n        vector<int> prevGreaterOrEqualElement(n, -1);\n        s = stack<int>();\n        for (int i = 0; i < n; i++) {\n            while (!s.empty() && primeScore[nums[i]] > primeScore[nums[s.top()]]) {\n                s.pop();\n            }\n            prevGreaterOrEqualElement[i] = s.empty() ? -1 : s.top();\n            s.push(i);\n        }\n\n        int res = 1;\n        vector<pair<int, int>> tuples(n);\n        for (int i = 0; i < n; i++) {\n            tuples[i].first = nums[i];\n            tuples[i].second = i;\n        }\n        sort(tuples.rbegin(), tuples.rend());\n        for (const auto& [num, i] : tuples) {\n            int operations = min((i - prevGreaterOrEqualElement[i]) * (nextGreaterElement[i] - i), k);\n            res = (int)((1L * res * pow(num, operations)) % MOD);\n            k -= operations;\n            if (k == 0) {\n                return res;\n            }\n        }\n\n        return res;\n    }\n\n    int pow(int x, int n) {\n        int res = 1;\n        while (n > 0) {\n            if (n % 2 == 1) {\n                res = (int)((1L * res * x) % MOD);\n            }\n            x = (int)((1L * x * x) % MOD);\n            n /= 2;\n        }\n        return res;\n    }\n};"}
{"code": "class Solution {\n    public long findMaximumElegance(int[][] A, int k) {\n        Arrays.sort(A, (a, b) -> b[0] - a[0]);\n        long res = 0, cur = 0;\n        List<Integer> dup = new ArrayList<>();\n        Set<Integer> seen = new HashSet<>();\n        for (int i = 0; i < A.length; ++i) {\n            if (i < k) {\n                if (seen.contains(A[i][1])) {\n                    dup.add(A[i][0]);\n                }\n                cur += A[i][0];\n            } else if (!seen.contains(A[i][1])) {\n                if (dup.isEmpty()) break;\n                cur += A[i][0] - dup.remove(dup.size() - 1);\n            }\n            seen.add(A[i][1]);\n            res = Math.max(res, cur + 1L * seen.size() * seen.size());\n        }\n        return res;\n    }\n}"}
{"code": "class Solution:\n    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:\n        items = sorted(items, key=lambda v: -v[0])\n        res = cur = 0\n        A = []\n        seen = set()\n        for i, (p, c) in enumerate(items):\n            if i < k:\n                if c in seen:\n                    A.append(p)\n                cur += p\n            elif c not in seen:\n                if not A: break\n                cur += p - A.pop()\n            seen.add(c)\n            res = max(res, cur + len(seen) * len(seen))\n        return res"}
{"code": "class Solution {\npublic:\n    long long findMaximumElegance(vector<vector<int>>& A, int k) {\n        sort(A.begin(), A.end(), [](const vector<int>& a, const vector<int>& b) {\n            return a[0] > b[0];\n        });\n        long long res = 0, cur = 0;\n        vector<int> dup;\n        unordered_set<int> seen;\n        for (int i = 0; i < A.size(); ++i) {\n            if (i < k) {\n                if (seen.count(A[i][1])) {\n                    dup.push_back(A[i][0]);\n                }\n                cur += A[i][0];\n            } else if (seen.find(A[i][1]) == seen.end()) {\n                if (dup.empty()) break;\n                cur += A[i][0] - dup.back();\n                dup.pop_back();\n            }\n            seen.insert(A[i][1]);\n            res = fmax(res, cur + 1L * seen.size() * seen.size());\n        }\n        return res;\n    }\n};"}
{"code": "class Solution {\n    public int maxSum(int[] nums) {\n    int ans = -1;\n    Map<Integer,List<Integer>> ump = new HashMap<>();\n    for(int i = 0; i < nums.length; ++i){\n        int t = nums[i], maxDigit = 0;\n        while(t != 0){ //evaluate max digit in the number\n            maxDigit = Math.max(t%10, maxDigit);\n            t = t/10;\n        }\n        if(!ump.containsKey(maxDigit)) ump.put(maxDigit, new ArrayList<>());\n        ump.get(maxDigit).add(nums[i]); // add the number to the map \n    }\n    for(Map.Entry<Integer, List<Integer>> entry: ump.entrySet()){\n        entry.getValue().sort(Comparator.reverseOrder()); //to find max two number in each max digit \n        if(entry.getValue().size() >= 2) ans = Math.max(ans, entry.getValue().get(0) + entry.getValue().get(1)); //sum max two number and take max\n    }\n    return ans;\n    }\n}"}
{"code": "class Solution:\n    def maxSum(self, nums: List[int]) -> int:\n        max_by_digit = defaultdict(int)\n        max_sum = -1\n\n        for num in nums:\n            digit = max(str(num))\n\n            if digit in max_by_digit:\n                max_sum = max(max_sum, max_by_digit[digit] + num)\n\n            max_by_digit[digit] = max(max_by_digit[digit], num)\n\n        return max_sum"}
{"code": "class Solution {\n    public:\n        int maxSum(vector<int>& nums) {\n        int res = -1, max_num[10] = {};\n        for (auto num : nums) {\n            int max_d = 0;\n            for (int v = num; v; v /= 10)\n                max_d = max(max_d, v % 10);\n            if (max_num[max_d])\n                res = max(res, max_num[max_d] + num);\n            max_num[max_d] = max(max_num[max_d], num);\n        }\n        return res;\n    }\n};"}
{"code": "class Solution {\n    public String finalString(String s) {\n        StringBuilder nm=new StringBuilder();\n        for(char c:s.toCharArray())\n        {\n            if(c=='i')\n            {\n                nm.reverse();\n            }\n            else\n            {\n                nm.append(c);\n            }\n        }\n        return nm.toString();\n    }\n}"}
{"code": "class Solution:\n    def finalString(self, s: str) -> str:\n        while \"i\" in s:\n            index=s.index(\"i\")\n\n            #first half and second half\n            first=s[:index][::-1]\n            second=s[index+1:]\n\n            s=\"\".join([first,second])\n        return s"}
{"code": "class Solution {\npublic:\n    string finalString(const string &s) {\n        string a, b;\n        for (char ch : s)\n            if (ch == 'i')\n                swap(a, b);\n            else\n                a += ch;\n        return string(rbegin(b), rend(b)) + a;\n    }\n};"}
{"code": "class Solution {\n    int minAbsoluteDifference(List<Integer> nums, int x) {\n        int ans = Integer.MAX_VALUE;\n        TreeSet<Integer> s = new TreeSet<>();\n        for(int i = x; i < nums.size(); ++i){\n            s.add(nums.get(i-x));\n            Integer high = s.ceiling(nums.get(i)), low = s.floor(nums.get(i));\n            if(high != null) ans = Math.min(ans, Math.abs(nums.get(i) - high));\n            if(low != null) ans = Math.min(ans, Math.abs(nums.get(i) - low));\n        }\n        return ans;\n    }\n}"}
{"code": "class Solution:\n  def minAbsoluteDifference(self, nums: List[int], x: int) -> int:\n    if x == 0:\n      return 0\n\n    arr, best_dist = SortedList([]), float('inf')\n    for i in range(x, len(nums)):\n      arr.add(nums[i - x])\n      v = nums[i]\n\n      pos = arr.bisect_left(v)\n      if pos < len(arr):\n        best_dist = min(best_dist, abs(arr[pos] - v))\n      if pos > 0:\n        best_dist = min(best_dist, abs(arr[pos - 1] - v))\n    \n    return best_dist"}
{"code": "class Solution {\npublic:\n    int minAbsoluteDifference(vector<int>& nums, int x) {\n        int ans = INT_MAX;\n        set<int> s;\n        for(int i = x; i < nums.size(); ++i){\n            s.insert(nums[i-x]);\n            auto it = s.upper_bound(nums[i]);\n            if(it != s.end()) ans = min(ans, abs(nums[i] - *it));\n            if(it != s.begin()) ans = min(ans, abs(nums[i] - *prev(it)));\n        }\n        return ans;\n    }\n};"}
{"code": "class Solution {\n    public ListNode doubleIt(ListNode head) {\n        if (head.val > 4)\n            head = new ListNode(0, head);\n        for(ListNode node = head; node != null; node = node.next) {\n            node.val = (node.val * 2) % 10;\n            if (node.next != null && node.next.val > 4)\n                node.val++;\n        }\n        return head;\n    }\n}"}
{"code": "class Solution:\n    def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if head.val > 4:\n            head = ListNode(0, head)\n        node = head\n        while node:\n            node.val = (node.val * 2) % 10\n            if node.next and node.next.val > 4:\n                node.val += 1\n            node = node.next\n        return head"}
{"code": "class Solution {\npublic:\n    ListNode* doubleIt(ListNode* head) {\n        if (head->val > 4)\n            head = new ListNode(0, head);\n        for(ListNode* node = head; node; node = node->next) {\n            node->val = (node->val * 2) % 10;\n            if (node->next && node->next->val > 4)\n                node->val++;\n        }\n        return head;\n    }\n};"}
{"code": "class Solution {\n    static final int MOD = 1000000007;\n\n    public int maximumScore(List<Integer> nums, int k) {\n        int n = nums.size();\n\n        int upper = Collections.max(nums) + 1;\n\n        boolean[] prime = new boolean[upper];\n        int[] primeScore = new int[upper];\n        Arrays.fill(prime, true);\n        prime[0] = prime[1] = false;\n        for (int i = 2; i < upper; i++) {\n            if (prime[i]) {\n                for (int j = i; j < upper; j += i) {\n                    primeScore[j]++;\n                    prime[j] = false;\n                }\n            }\n        }\n\n        int[] nextGreaterElement = new int[n];\n        Arrays.fill(nextGreaterElement, n);\n        Stack<Integer> s = new Stack<>();\n        for (int i = n - 1; i >= 0; i--) {\n            while (!s.empty() && primeScore[nums.get(i)] >= primeScore[nums.get(s.peek())]) {\n                s.pop();\n            }\n            nextGreaterElement[i] = s.empty() ? n : s.peek();\n            s.push(i);\n        }\n\n        int[] prevGreaterOrEqualElement = new int[n];\n        Arrays.fill(prevGreaterOrEqualElement, -1);\n        s = new Stack<>();\n        for (int i = 0; i < n; i++) {\n            while (!s.empty() && primeScore[nums.get(i)] > primeScore[nums.get(s.peek())]) {\n                s.pop();\n            }\n            prevGreaterOrEqualElement[i] = s.empty() ? -1 : s.peek();\n            s.push(i);\n        }\n\n        int res = 1;\n        int[][] tuples = new int[n][2];\n        for (int i = 0; i < n; i++) {\n            tuples[i][0] = nums.get(i);\n            tuples[i][1] = i;\n        }\n        Arrays.sort(tuples, new Comparator<int[]>() {\n            public int compare(int[] a, int[] b) {\n                return b[0] - a[0];\n            }\n        });\n        for (int i = 0; i < n; i++) {\n            int num = tuples[i][0];\n            int idx = tuples[i][1];\n            int operations = Math.min((idx - prevGreaterOrEqualElement[idx]) * (nextGreaterElement[idx] - idx), k);\n            res = (int)((1L * res * pow(num, operations)) % MOD);\n            k -= operations;\n            if (k == 0) {\n                return res;\n            }\n        }\n\n        return res;\n    }\n\n    public int pow(int x, int n) {\n        int res = 1;\n        while (n > 0) {\n            if (n % 2 == 1) {\n                res = (int)((1L * res * x) % MOD);\n            }\n            x = (int)((1L * x * x) % MOD);\n            n /= 2;\n        }\n        return res;\n    }\n}"}
{"code": "class Solution: \n    MOD = 1000000007\n\n    def maximumScore(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n\n        upper = max(nums) + 1\n\n        prime = [True]*upper\n        prime[0] = prime[1] = False\n        primeScore = [0]*upper\n        for i in range(2, upper):\n            if prime[i]:\n                for j in range(i, upper, i):\n                    primeScore[j] += 1\n                    prime[j] = False\n\n        nextGreaterElement = [n]*n\n        s = []\n        for i in range(n - 1, -1, -1):\n            while s and primeScore[nums[i]] >= primeScore[nums[s[-1]]]:\n                s.pop()\n            nextGreaterElement[i] = s[-1] if s else n\n            s.append(i)\n\n        prevGreaterOrEqualElement = [-1]*n\n        s = []\n        for i in range(n):\n            while s and primeScore[nums[i]] > primeScore[nums[s[-1]]]:\n                s.pop()\n            prevGreaterOrEqualElement[i] = s[-1] if s else -1\n            s.append(i)\n\n        res = 1\n        tuples = [[nums[i], i] for i in range(n)]\n        tuples.sort(reverse=True)\n        for num, idx in tuples:\n            operations = min((idx - prevGreaterOrEqualElement[idx]) * (nextGreaterElement[idx] - idx), k)\n            res = (res * self.pow(num, operations)) % self.MOD\n            k -= operations\n            if k == 0:\n                return res\n\n        return res\n\n    def pow(self, x: int, n: int) -> int:\n        res = 1\n        while n > 0:\n            if n % 2 == 1:\n                res = (res * x) % self.MOD\n            x = (x * x) % self.MOD\n            n //= 2\n        return res"}
{"code": "class Solution {\npublic:\n    const int MOD = 1000000007;\n\n    int maximumScore(vector<int>& nums, int k) {\n        int n = nums.size();\n\n        int upper = *max_element(nums.begin(), nums.end()) + 1;\n\n        vector<bool> prime(upper, true);\n        prime[0] = prime[1] = false;\n        vector<int> primeScore(upper, 0);\n        for (int i = 2; i < upper; i++) {\n            if (prime[i]) {\n                for (int j = i; j < upper; j += i) {\n                    primeScore[j]++;\n                    prime[j] = false;\n                }\n            }\n        }\n\n        vector<int> nextGreaterElement(n, n);\n        stack<int> s;\n        for (int i = n - 1; i >= 0; i--) {\n            while (!s.empty() && primeScore[nums[i]] >= primeScore[nums[s.top()]]) {\n                s.pop();\n            }\n            nextGreaterElement[i] = s.empty() ? n : s.top();\n            s.push(i);\n        }\n\n        vector<int> prevGreaterOrEqualElement(n, -1);\n        s = stack<int>();\n        for (int i = 0; i < n; i++) {\n            while (!s.empty() && primeScore[nums[i]] > primeScore[nums[s.top()]]) {\n                s.pop();\n            }\n            prevGreaterOrEqualElement[i] = s.empty() ? -1 : s.top();\n            s.push(i);\n        }\n\n        int res = 1;\n        vector<pair<int, int>> tuples(n);\n        for (int i = 0; i < n; i++) {\n            tuples[i].first = nums[i];\n            tuples[i].second = i;\n        }\n        sort(tuples.rbegin(), tuples.rend());\n        for (const auto& [num, i] : tuples) {\n            int operations = min((i - prevGreaterOrEqualElement[i]) * (nextGreaterElement[i] - i), k);\n            res = (int)((1L * res * pow(num, operations)) % MOD);\n            k -= operations;\n            if (k == 0) {\n                return res;\n            }\n        }\n\n        return res;\n    }\n\n    int pow(int x, int n) {\n        int res = 1;\n        while (n > 0) {\n            if (n % 2 == 1) {\n                res = (int)((1L * res * x) % MOD);\n            }\n            x = (int)((1L * x * x) % MOD);\n            n /= 2;\n        }\n        return res;\n    }\n};"}
{"code": "class Solution {\n    public long findMaximumElegance(int[][] A, int k) {\n        Arrays.sort(A, (a, b) -> b[0] - a[0]);\n        long res = 0, cur = 0;\n        List<Integer> dup = new ArrayList<>();\n        Set<Integer> seen = new HashSet<>();\n        for (int i = 0; i < A.length; ++i) {\n            if (i < k) {\n                if (seen.contains(A[i][1])) {\n                    dup.add(A[i][0]);\n                }\n                cur += A[i][0];\n            } else if (!seen.contains(A[i][1])) {\n                if (dup.isEmpty()) break;\n                cur += A[i][0] - dup.remove(dup.size() - 1);\n            }\n            seen.add(A[i][1]);\n            res = Math.max(res, cur + 1L * seen.size() * seen.size());\n        }\n        return res;\n    }\n}"}
{"code": "class Solution:\n    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:\n        items = sorted(items, key=lambda v: -v[0])\n        res = cur = 0\n        A = []\n        seen = set()\n        for i, (p, c) in enumerate(items):\n            if i < k:\n                if c in seen:\n                    A.append(p)\n                cur += p\n            elif c not in seen:\n                if not A: break\n                cur += p - A.pop()\n            seen.add(c)\n            res = max(res, cur + len(seen) * len(seen))\n        return res"}
{"code": "class Solution {\npublic:\n    long long findMaximumElegance(vector<vector<int>>& A, int k) {\n        sort(A.begin(), A.end(), [](const vector<int>& a, const vector<int>& b) {\n            return a[0] > b[0];\n        });\n        long long res = 0, cur = 0;\n        vector<int> dup;\n        unordered_set<int> seen;\n        for (int i = 0; i < A.size(); ++i) {\n            if (i < k) {\n                if (seen.count(A[i][1])) {\n                    dup.push_back(A[i][0]);\n                }\n                cur += A[i][0];\n            } else if (seen.find(A[i][1]) == seen.end()) {\n                if (dup.empty()) break;\n                cur += A[i][0] - dup.back();\n                dup.pop_back();\n            }\n            seen.insert(A[i][1]);\n            res = fmax(res, cur + 1L * seen.size() * seen.size());\n        }\n        return res;\n    }\n};"}
{"code": "class Solution {\n    public int maxSum(int[] nums) {\n    int ans = -1;\n    Map<Integer,List<Integer>> ump = new HashMap<>();\n    for(int i = 0; i < nums.length; ++i){\n        int t = nums[i], maxDigit = 0;\n        while(t != 0){ //evaluate max digit in the number\n            maxDigit = Math.max(t%10, maxDigit);\n            t = t/10;\n        }\n        if(!ump.containsKey(maxDigit)) ump.put(maxDigit, new ArrayList<>());\n        ump.get(maxDigit).add(nums[i]); // add the number to the map \n    }\n    for(Map.Entry<Integer, List<Integer>> entry: ump.entrySet()){\n        entry.getValue().sort(Comparator.reverseOrder()); //to find max two number in each max digit \n        if(entry.getValue().size() >= 2) ans = Math.max(ans, entry.getValue().get(0) + entry.getValue().get(1)); //sum max two number and take max\n    }\n    return ans;\n    }\n}"}
{"code": "class Solution:\n    def maxSum(self, nums: List[int]) -> int:\n        max_by_digit = defaultdict(int)\n        max_sum = -1\n\n        for num in nums:\n            digit = max(str(num))\n\n            if digit in max_by_digit:\n                max_sum = max(max_sum, max_by_digit[digit] + num)\n\n            max_by_digit[digit] = max(max_by_digit[digit], num)\n\n        return max_sum"}
{"code": "class Solution {\n    public:\n        int maxSum(vector<int>& nums) {\n        int res = -1, max_num[10] = {};\n        for (auto num : nums) {\n            int max_d = 0;\n            for (int v = num; v; v /= 10)\n                max_d = max(max_d, v % 10);\n            if (max_num[max_d])\n                res = max(res, max_num[max_d] + num);\n            max_num[max_d] = max(max_num[max_d], num);\n        }\n        return res;\n    }\n};"}
{"code": "class Solution {\n    public String finalString(String s) {\n        StringBuilder nm=new StringBuilder();\n        for(char c:s.toCharArray())\n        {\n            if(c=='i')\n            {\n                nm.reverse();\n            }\n            else\n            {\n                nm.append(c);\n            }\n        }\n        return nm.toString();\n    }\n}"}
{"code": "class Solution:\n    def finalString(self, s: str) -> str:\n        while \"i\" in s:\n            index=s.index(\"i\")\n\n            #first half and second half\n            first=s[:index][::-1]\n            second=s[index+1:]\n\n            s=\"\".join([first,second])\n        return s"}
{"code": "class Solution {\npublic:\n    string finalString(const string &s) {\n        string a, b;\n        for (char ch : s)\n            if (ch == 'i')\n                swap(a, b);\n            else\n                a += ch;\n        return string(rbegin(b), rend(b)) + a;\n    }\n};"}
{"code": "class Solution {\n    int minAbsoluteDifference(List<Integer> nums, int x) {\n        int ans = Integer.MAX_VALUE;\n        TreeSet<Integer> s = new TreeSet<>();\n        for(int i = x; i < nums.size(); ++i){\n            s.add(nums.get(i-x));\n            Integer high = s.ceiling(nums.get(i)), low = s.floor(nums.get(i));\n            if(high != null) ans = Math.min(ans, Math.abs(nums.get(i) - high));\n            if(low != null) ans = Math.min(ans, Math.abs(nums.get(i) - low));\n        }\n        return ans;\n    }\n}"}
{"code": "class Solution:\n  def minAbsoluteDifference(self, nums: List[int], x: int) -> int:\n    if x == 0:\n      return 0\n\n    arr, best_dist = SortedList([]), float('inf')\n    for i in range(x, len(nums)):\n      arr.add(nums[i - x])\n      v = nums[i]\n\n      pos = arr.bisect_left(v)\n      if pos < len(arr):\n        best_dist = min(best_dist, abs(arr[pos] - v))\n      if pos > 0:\n        best_dist = min(best_dist, abs(arr[pos - 1] - v))\n    \n    return best_dist"}
{"code": "class Solution {\npublic:\n    int minAbsoluteDifference(vector<int>& nums, int x) {\n        int ans = INT_MAX;\n        set<int> s;\n        for(int i = x; i < nums.size(); ++i){\n            s.insert(nums[i-x]);\n            auto it = s.upper_bound(nums[i]);\n            if(it != s.end()) ans = min(ans, abs(nums[i] - *it));\n            if(it != s.begin()) ans = min(ans, abs(nums[i] - *prev(it)));\n        }\n        return ans;\n    }\n};"}
{"code": "class Solution {\n    public ListNode doubleIt(ListNode head) {\n        if (head.val > 4)\n            head = new ListNode(0, head);\n        for(ListNode node = head; node != null; node = node.next) {\n            node.val = (node.val * 2) % 10;\n            if (node.next != null && node.next.val > 4)\n                node.val++;\n        }\n        return head;\n    }\n}"}
{"code": "class Solution:\n    def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if head.val > 4:\n            head = ListNode(0, head)\n        node = head\n        while node:\n            node.val = (node.val * 2) % 10\n            if node.next and node.next.val > 4:\n                node.val += 1\n            node = node.next\n        return head"}
{"code": "class Solution {\npublic:\n    ListNode* doubleIt(ListNode* head) {\n        if (head->val > 4)\n            head = new ListNode(0, head);\n        for(ListNode* node = head; node; node = node->next) {\n            node->val = (node->val * 2) % 10;\n            if (node->next && node->next->val > 4)\n                node->val++;\n        }\n        return head;\n    }\n};"}
{"code": "class Solution {\n    static final int MOD = 1000000007;\n\n    public int maximumScore(List<Integer> nums, int k) {\n        int n = nums.size();\n\n        int upper = Collections.max(nums) + 1;\n\n        boolean[] prime = new boolean[upper];\n        int[] primeScore = new int[upper];\n        Arrays.fill(prime, true);\n        prime[0] = prime[1] = false;\n        for (int i = 2; i < upper; i++) {\n            if (prime[i]) {\n                for (int j = i; j < upper; j += i) {\n                    primeScore[j]++;\n                    prime[j] = false;\n                }\n            }\n        }\n\n        int[] nextGreaterElement = new int[n];\n        Arrays.fill(nextGreaterElement, n);\n        Stack<Integer> s = new Stack<>();\n        for (int i = n - 1; i >= 0; i--) {\n            while (!s.empty() && primeScore[nums.get(i)] >= primeScore[nums.get(s.peek())]) {\n                s.pop();\n            }\n            nextGreaterElement[i] = s.empty() ? n : s.peek();\n            s.push(i);\n        }\n\n        int[] prevGreaterOrEqualElement = new int[n];\n        Arrays.fill(prevGreaterOrEqualElement, -1);\n        s = new Stack<>();\n        for (int i = 0; i < n; i++) {\n            while (!s.empty() && primeScore[nums.get(i)] > primeScore[nums.get(s.peek())]) {\n                s.pop();\n            }\n            prevGreaterOrEqualElement[i] = s.empty() ? -1 : s.peek();\n            s.push(i);\n        }\n\n        int res = 1;\n        int[][] tuples = new int[n][2];\n        for (int i = 0; i < n; i++) {\n            tuples[i][0] = nums.get(i);\n            tuples[i][1] = i;\n        }\n        Arrays.sort(tuples, new Comparator<int[]>() {\n            public int compare(int[] a, int[] b) {\n                return b[0] - a[0];\n            }\n        });\n        for (int i = 0; i < n; i++) {\n            int num = tuples[i][0];\n            int idx = tuples[i][1];\n            int operations = Math.min((idx - prevGreaterOrEqualElement[idx]) * (nextGreaterElement[idx] - idx), k);\n            res = (int)((1L * res * pow(num, operations)) % MOD);\n            k -= operations;\n            if (k == 0) {\n                return res;\n            }\n        }\n\n        return res;\n    }\n\n    public int pow(int x, int n) {\n        int res = 1;\n        while (n > 0) {\n            if (n % 2 == 1) {\n                res = (int)((1L * res * x) % MOD);\n            }\n            x = (int)((1L * x * x) % MOD);\n            n /= 2;\n        }\n        return res;\n    }\n}"}
{"code": "class Solution: \n    MOD = 1000000007\n\n    def maximumScore(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n\n        upper = max(nums) + 1\n\n        prime = [True]*upper\n        prime[0] = prime[1] = False\n        primeScore = [0]*upper\n        for i in range(2, upper):\n            if prime[i]:\n                for j in range(i, upper, i):\n                    primeScore[j] += 1\n                    prime[j] = False\n\n        nextGreaterElement = [n]*n\n        s = []\n        for i in range(n - 1, -1, -1):\n            while s and primeScore[nums[i]] >= primeScore[nums[s[-1]]]:\n                s.pop()\n            nextGreaterElement[i] = s[-1] if s else n\n            s.append(i)\n\n        prevGreaterOrEqualElement = [-1]*n\n        s = []\n        for i in range(n):\n            while s and primeScore[nums[i]] > primeScore[nums[s[-1]]]:\n                s.pop()\n            prevGreaterOrEqualElement[i] = s[-1] if s else -1\n            s.append(i)\n\n        res = 1\n        tuples = [[nums[i], i] for i in range(n)]\n        tuples.sort(reverse=True)\n        for num, idx in tuples:\n            operations = min((idx - prevGreaterOrEqualElement[idx]) * (nextGreaterElement[idx] - idx), k)\n            res = (res * self.pow(num, operations)) % self.MOD\n            k -= operations\n            if k == 0:\n                return res\n\n        return res\n\n    def pow(self, x: int, n: int) -> int:\n        res = 1\n        while n > 0:\n            if n % 2 == 1:\n                res = (res * x) % self.MOD\n            x = (x * x) % self.MOD\n            n //= 2\n        return res"}
{"code": "class Solution {\npublic:\n    const int MOD = 1000000007;\n\n    int maximumScore(vector<int>& nums, int k) {\n        int n = nums.size();\n\n        int upper = *max_element(nums.begin(), nums.end()) + 1;\n\n        vector<bool> prime(upper, true);\n        prime[0] = prime[1] = false;\n        vector<int> primeScore(upper, 0);\n        for (int i = 2; i < upper; i++) {\n            if (prime[i]) {\n                for (int j = i; j < upper; j += i) {\n                    primeScore[j]++;\n                    prime[j] = false;\n                }\n            }\n        }\n\n        vector<int> nextGreaterElement(n, n);\n        stack<int> s;\n        for (int i = n - 1; i >= 0; i--) {\n            while (!s.empty() && primeScore[nums[i]] >= primeScore[nums[s.top()]]) {\n                s.pop();\n            }\n            nextGreaterElement[i] = s.empty() ? n : s.top();\n            s.push(i);\n        }\n\n        vector<int> prevGreaterOrEqualElement(n, -1);\n        s = stack<int>();\n        for (int i = 0; i < n; i++) {\n            while (!s.empty() && primeScore[nums[i]] > primeScore[nums[s.top()]]) {\n                s.pop();\n            }\n            prevGreaterOrEqualElement[i] = s.empty() ? -1 : s.top();\n            s.push(i);\n        }\n\n        int res = 1;\n        vector<pair<int, int>> tuples(n);\n        for (int i = 0; i < n; i++) {\n            tuples[i].first = nums[i];\n            tuples[i].second = i;\n        }\n        sort(tuples.rbegin(), tuples.rend());\n        for (const auto& [num, i] : tuples) {\n            int operations = min((i - prevGreaterOrEqualElement[i]) * (nextGreaterElement[i] - i), k);\n            res = (int)((1L * res * pow(num, operations)) % MOD);\n            k -= operations;\n            if (k == 0) {\n                return res;\n            }\n        }\n\n        return res;\n    }\n\n    int pow(int x, int n) {\n        int res = 1;\n        while (n > 0) {\n            if (n % 2 == 1) {\n                res = (int)((1L * res * x) % MOD);\n            }\n            x = (int)((1L * x * x) % MOD);\n            n /= 2;\n        }\n        return res;\n    }\n};"}
{"code": "class Solution {\n    public long findMaximumElegance(int[][] A, int k) {\n        Arrays.sort(A, (a, b) -> b[0] - a[0]);\n        long res = 0, cur = 0;\n        List<Integer> dup = new ArrayList<>();\n        Set<Integer> seen = new HashSet<>();\n        for (int i = 0; i < A.length; ++i) {\n            if (i < k) {\n                if (seen.contains(A[i][1])) {\n                    dup.add(A[i][0]);\n                }\n                cur += A[i][0];\n            } else if (!seen.contains(A[i][1])) {\n                if (dup.isEmpty()) break;\n                cur += A[i][0] - dup.remove(dup.size() - 1);\n            }\n            seen.add(A[i][1]);\n            res = Math.max(res, cur + 1L * seen.size() * seen.size());\n        }\n        return res;\n    }\n}"}
{"code": "class Solution:\n    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:\n        items = sorted(items, key=lambda v: -v[0])\n        res = cur = 0\n        A = []\n        seen = set()\n        for i, (p, c) in enumerate(items):\n            if i < k:\n                if c in seen:\n                    A.append(p)\n                cur += p\n            elif c not in seen:\n                if not A: break\n                cur += p - A.pop()\n            seen.add(c)\n            res = max(res, cur + len(seen) * len(seen))\n        return res"}
{"code": "class Solution {\npublic:\n    long long findMaximumElegance(vector<vector<int>>& A, int k) {\n        sort(A.begin(), A.end(), [](const vector<int>& a, const vector<int>& b) {\n            return a[0] > b[0];\n        });\n        long long res = 0, cur = 0;\n        vector<int> dup;\n        unordered_set<int> seen;\n        for (int i = 0; i < A.size(); ++i) {\n            if (i < k) {\n                if (seen.count(A[i][1])) {\n                    dup.push_back(A[i][0]);\n                }\n                cur += A[i][0];\n            } else if (seen.find(A[i][1]) == seen.end()) {\n                if (dup.empty()) break;\n                cur += A[i][0] - dup.back();\n                dup.pop_back();\n            }\n            seen.insert(A[i][1]);\n            res = fmax(res, cur + 1L * seen.size() * seen.size());\n        }\n        return res;\n    }\n};"}
{"code": "class Solution {\n    public int maxSum(int[] nums) {\n    int ans = -1;\n    Map<Integer,List<Integer>> ump = new HashMap<>();\n    for(int i = 0; i < nums.length; ++i){\n        int t = nums[i], maxDigit = 0;\n        while(t != 0){ //evaluate max digit in the number\n            maxDigit = Math.max(t%10, maxDigit);\n            t = t/10;\n        }\n        if(!ump.containsKey(maxDigit)) ump.put(maxDigit, new ArrayList<>());\n        ump.get(maxDigit).add(nums[i]); // add the number to the map \n    }\n    for(Map.Entry<Integer, List<Integer>> entry: ump.entrySet()){\n        entry.getValue().sort(Comparator.reverseOrder()); //to find max two number in each max digit \n        if(entry.getValue().size() >= 2) ans = Math.max(ans, entry.getValue().get(0) + entry.getValue().get(1)); //sum max two number and take max\n    }\n    return ans;\n    }\n}"}
{"code": "class Solution:\n    def maxSum(self, nums: List[int]) -> int:\n        max_by_digit = defaultdict(int)\n        max_sum = -1\n\n        for num in nums:\n            digit = max(str(num))\n\n            if digit in max_by_digit:\n                max_sum = max(max_sum, max_by_digit[digit] + num)\n\n            max_by_digit[digit] = max(max_by_digit[digit], num)\n\n        return max_sum"}
{"code": "class Solution {\n    public:\n        int maxSum(vector<int>& nums) {\n        int res = -1, max_num[10] = {};\n        for (auto num : nums) {\n            int max_d = 0;\n            for (int v = num; v; v /= 10)\n                max_d = max(max_d, v % 10);\n            if (max_num[max_d])\n                res = max(res, max_num[max_d] + num);\n            max_num[max_d] = max(max_num[max_d], num);\n        }\n        return res;\n    }\n};"}
{"code": "class Solution {\n    public String finalString(String s) {\n        StringBuilder nm=new StringBuilder();\n        for(char c:s.toCharArray())\n        {\n            if(c=='i')\n            {\n                nm.reverse();\n            }\n            else\n            {\n                nm.append(c);\n            }\n        }\n        return nm.toString();\n    }\n}"}
{"code": "class Solution:\n    def finalString(self, s: str) -> str:\n        while \"i\" in s:\n            index=s.index(\"i\")\n\n            #first half and second half\n            first=s[:index][::-1]\n            second=s[index+1:]\n\n            s=\"\".join([first,second])\n        return s"}
{"code": "class Solution {\npublic:\n    string finalString(const string &s) {\n        string a, b;\n        for (char ch : s)\n            if (ch == 'i')\n                swap(a, b);\n            else\n                a += ch;\n        return string(rbegin(b), rend(b)) + a;\n    }\n};"}
{"code": "class Solution {\n    int minAbsoluteDifference(List<Integer> nums, int x) {\n        int ans = Integer.MAX_VALUE;\n        TreeSet<Integer> s = new TreeSet<>();\n        for(int i = x; i < nums.size(); ++i){\n            s.add(nums.get(i-x));\n            Integer high = s.ceiling(nums.get(i)), low = s.floor(nums.get(i));\n            if(high != null) ans = Math.min(ans, Math.abs(nums.get(i) - high));\n            if(low != null) ans = Math.min(ans, Math.abs(nums.get(i) - low));\n        }\n        return ans;\n    }\n}"}
{"code": "class Solution:\n  def minAbsoluteDifference(self, nums: List[int], x: int) -> int:\n    if x == 0:\n      return 0\n\n    arr, best_dist = SortedList([]), float('inf')\n    for i in range(x, len(nums)):\n      arr.add(nums[i - x])\n      v = nums[i]\n\n      pos = arr.bisect_left(v)\n      if pos < len(arr):\n        best_dist = min(best_dist, abs(arr[pos] - v))\n      if pos > 0:\n        best_dist = min(best_dist, abs(arr[pos - 1] - v))\n    \n    return best_dist"}
{"code": "class Solution {\npublic:\n    int minAbsoluteDifference(vector<int>& nums, int x) {\n        int ans = INT_MAX;\n        set<int> s;\n        for(int i = x; i < nums.size(); ++i){\n            s.insert(nums[i-x]);\n            auto it = s.upper_bound(nums[i]);\n            if(it != s.end()) ans = min(ans, abs(nums[i] - *it));\n            if(it != s.begin()) ans = min(ans, abs(nums[i] - *prev(it)));\n        }\n        return ans;\n    }\n};"}
{"code": "class Solution {\n    public ListNode doubleIt(ListNode head) {\n        if (head.val > 4)\n            head = new ListNode(0, head);\n        for(ListNode node = head; node != null; node = node.next) {\n            node.val = (node.val * 2) % 10;\n            if (node.next != null && node.next.val > 4)\n                node.val++;\n        }\n        return head;\n    }\n}"}
{"code": "class Solution:\n    def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if head.val > 4:\n            head = ListNode(0, head)\n        node = head\n        while node:\n            node.val = (node.val * 2) % 10\n            if node.next and node.next.val > 4:\n                node.val += 1\n            node = node.next\n        return head"}
{"code": "class Solution {\npublic:\n    ListNode* doubleIt(ListNode* head) {\n        if (head->val > 4)\n            head = new ListNode(0, head);\n        for(ListNode* node = head; node; node = node->next) {\n            node->val = (node->val * 2) % 10;\n            if (node->next && node->next->val > 4)\n                node->val++;\n        }\n        return head;\n    }\n};"}
{"code": "class Solution {\n    static final int MOD = 1000000007;\n\n    public int maximumScore(List<Integer> nums, int k) {\n        int n = nums.size();\n\n        int upper = Collections.max(nums) + 1;\n\n        boolean[] prime = new boolean[upper];\n        int[] primeScore = new int[upper];\n        Arrays.fill(prime, true);\n        prime[0] = prime[1] = false;\n        for (int i = 2; i < upper; i++) {\n            if (prime[i]) {\n                for (int j = i; j < upper; j += i) {\n                    primeScore[j]++;\n                    prime[j] = false;\n                }\n            }\n        }\n\n        int[] nextGreaterElement = new int[n];\n        Arrays.fill(nextGreaterElement, n);\n        Stack<Integer> s = new Stack<>();\n        for (int i = n - 1; i >= 0; i--) {\n            while (!s.empty() && primeScore[nums.get(i)] >= primeScore[nums.get(s.peek())]) {\n                s.pop();\n            }\n            nextGreaterElement[i] = s.empty() ? n : s.peek();\n            s.push(i);\n        }\n\n        int[] prevGreaterOrEqualElement = new int[n];\n        Arrays.fill(prevGreaterOrEqualElement, -1);\n        s = new Stack<>();\n        for (int i = 0; i < n; i++) {\n            while (!s.empty() && primeScore[nums.get(i)] > primeScore[nums.get(s.peek())]) {\n                s.pop();\n            }\n            prevGreaterOrEqualElement[i] = s.empty() ? -1 : s.peek();\n            s.push(i);\n        }\n\n        int res = 1;\n        int[][] tuples = new int[n][2];\n        for (int i = 0; i < n; i++) {\n            tuples[i][0] = nums.get(i);\n            tuples[i][1] = i;\n        }\n        Arrays.sort(tuples, new Comparator<int[]>() {\n            public int compare(int[] a, int[] b) {\n                return b[0] - a[0];\n            }\n        });\n        for (int i = 0; i < n; i++) {\n            int num = tuples[i][0];\n            int idx = tuples[i][1];\n            int operations = Math.min((idx - prevGreaterOrEqualElement[idx]) * (nextGreaterElement[idx] - idx), k);\n            res = (int)((1L * res * pow(num, operations)) % MOD);\n            k -= operations;\n            if (k == 0) {\n                return res;\n            }\n        }\n\n        return res;\n    }\n\n    public int pow(int x, int n) {\n        int res = 1;\n        while (n > 0) {\n            if (n % 2 == 1) {\n                res = (int)((1L * res * x) % MOD);\n            }\n            x = (int)((1L * x * x) % MOD);\n            n /= 2;\n        }\n        return res;\n    }\n}"}
{"code": "class Solution: \n    MOD = 1000000007\n\n    def maximumScore(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n\n        upper = max(nums) + 1\n\n        prime = [True]*upper\n        prime[0] = prime[1] = False\n        primeScore = [0]*upper\n        for i in range(2, upper):\n            if prime[i]:\n                for j in range(i, upper, i):\n                    primeScore[j] += 1\n                    prime[j] = False\n\n        nextGreaterElement = [n]*n\n        s = []\n        for i in range(n - 1, -1, -1):\n            while s and primeScore[nums[i]] >= primeScore[nums[s[-1]]]:\n                s.pop()\n            nextGreaterElement[i] = s[-1] if s else n\n            s.append(i)\n\n        prevGreaterOrEqualElement = [-1]*n\n        s = []\n        for i in range(n):\n            while s and primeScore[nums[i]] > primeScore[nums[s[-1]]]:\n                s.pop()\n            prevGreaterOrEqualElement[i] = s[-1] if s else -1\n            s.append(i)\n\n        res = 1\n        tuples = [[nums[i], i] for i in range(n)]\n        tuples.sort(reverse=True)\n        for num, idx in tuples:\n            operations = min((idx - prevGreaterOrEqualElement[idx]) * (nextGreaterElement[idx] - idx), k)\n            res = (res * self.pow(num, operations)) % self.MOD\n            k -= operations\n            if k == 0:\n                return res\n\n        return res\n\n    def pow(self, x: int, n: int) -> int:\n        res = 1\n        while n > 0:\n            if n % 2 == 1:\n                res = (res * x) % self.MOD\n            x = (x * x) % self.MOD\n            n //= 2\n        return res"}
{"code": "class Solution {\npublic:\n    const int MOD = 1000000007;\n\n    int maximumScore(vector<int>& nums, int k) {\n        int n = nums.size();\n\n        int upper = *max_element(nums.begin(), nums.end()) + 1;\n\n        vector<bool> prime(upper, true);\n        prime[0] = prime[1] = false;\n        vector<int> primeScore(upper, 0);\n        for (int i = 2; i < upper; i++) {\n            if (prime[i]) {\n                for (int j = i; j < upper; j += i) {\n                    primeScore[j]++;\n                    prime[j] = false;\n                }\n            }\n        }\n\n        vector<int> nextGreaterElement(n, n);\n        stack<int> s;\n        for (int i = n - 1; i >= 0; i--) {\n            while (!s.empty() && primeScore[nums[i]] >= primeScore[nums[s.top()]]) {\n                s.pop();\n            }\n            nextGreaterElement[i] = s.empty() ? n : s.top();\n            s.push(i);\n        }\n\n        vector<int> prevGreaterOrEqualElement(n, -1);\n        s = stack<int>();\n        for (int i = 0; i < n; i++) {\n            while (!s.empty() && primeScore[nums[i]] > primeScore[nums[s.top()]]) {\n                s.pop();\n            }\n            prevGreaterOrEqualElement[i] = s.empty() ? -1 : s.top();\n            s.push(i);\n        }\n\n        int res = 1;\n        vector<pair<int, int>> tuples(n);\n        for (int i = 0; i < n; i++) {\n            tuples[i].first = nums[i];\n            tuples[i].second = i;\n        }\n        sort(tuples.rbegin(), tuples.rend());\n        for (const auto& [num, i] : tuples) {\n            int operations = min((i - prevGreaterOrEqualElement[i]) * (nextGreaterElement[i] - i), k);\n            res = (int)((1L * res * pow(num, operations)) % MOD);\n            k -= operations;\n            if (k == 0) {\n                return res;\n            }\n        }\n\n        return res;\n    }\n\n    int pow(int x, int n) {\n        int res = 1;\n        while (n > 0) {\n            if (n % 2 == 1) {\n                res = (int)((1L * res * x) % MOD);\n            }\n            x = (int)((1L * x * x) % MOD);\n            n /= 2;\n        }\n        return res;\n    }\n};"}
{"code": "class Solution {\n    public long findMaximumElegance(int[][] A, int k) {\n        Arrays.sort(A, (a, b) -> b[0] - a[0]);\n        long res = 0, cur = 0;\n        List<Integer> dup = new ArrayList<>();\n        Set<Integer> seen = new HashSet<>();\n        for (int i = 0; i < A.length; ++i) {\n            if (i < k) {\n                if (seen.contains(A[i][1])) {\n                    dup.add(A[i][0]);\n                }\n                cur += A[i][0];\n            } else if (!seen.contains(A[i][1])) {\n                if (dup.isEmpty()) break;\n                cur += A[i][0] - dup.remove(dup.size() - 1);\n            }\n            seen.add(A[i][1]);\n            res = Math.max(res, cur + 1L * seen.size() * seen.size());\n        }\n        return res;\n    }\n}"}
{"code": "class Solution:\n    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:\n        items = sorted(items, key=lambda v: -v[0])\n        res = cur = 0\n        A = []\n        seen = set()\n        for i, (p, c) in enumerate(items):\n            if i < k:\n                if c in seen:\n                    A.append(p)\n                cur += p\n            elif c not in seen:\n                if not A: break\n                cur += p - A.pop()\n            seen.add(c)\n            res = max(res, cur + len(seen) * len(seen))\n        return res"}
{"code": "class Solution {\npublic:\n    long long findMaximumElegance(vector<vector<int>>& A, int k) {\n        sort(A.begin(), A.end(), [](const vector<int>& a, const vector<int>& b) {\n            return a[0] > b[0];\n        });\n        long long res = 0, cur = 0;\n        vector<int> dup;\n        unordered_set<int> seen;\n        for (int i = 0; i < A.size(); ++i) {\n            if (i < k) {\n                if (seen.count(A[i][1])) {\n                    dup.push_back(A[i][0]);\n                }\n                cur += A[i][0];\n            } else if (seen.find(A[i][1]) == seen.end()) {\n                if (dup.empty()) break;\n                cur += A[i][0] - dup.back();\n                dup.pop_back();\n            }\n            seen.insert(A[i][1]);\n            res = fmax(res, cur + 1L * seen.size() * seen.size());\n        }\n        return res;\n    }\n};"}
{"code": "class Solution {\n    public int maxSum(int[] nums) {\n    int ans = -1;\n    Map<Integer,List<Integer>> ump = new HashMap<>();\n    for(int i = 0; i < nums.length; ++i){\n        int t = nums[i], maxDigit = 0;\n        while(t != 0){ //evaluate max digit in the number\n            maxDigit = Math.max(t%10, maxDigit);\n            t = t/10;\n        }\n        if(!ump.containsKey(maxDigit)) ump.put(maxDigit, new ArrayList<>());\n        ump.get(maxDigit).add(nums[i]); // add the number to the map \n    }\n    for(Map.Entry<Integer, List<Integer>> entry: ump.entrySet()){\n        entry.getValue().sort(Comparator.reverseOrder()); //to find max two number in each max digit \n        if(entry.getValue().size() >= 2) ans = Math.max(ans, entry.getValue().get(0) + entry.getValue().get(1)); //sum max two number and take max\n    }\n    return ans;\n    }\n}"}
{"code": "class Solution:\n    def maxSum(self, nums: List[int]) -> int:\n        max_by_digit = defaultdict(int)\n        max_sum = -1\n\n        for num in nums:\n            digit = max(str(num))\n\n            if digit in max_by_digit:\n                max_sum = max(max_sum, max_by_digit[digit] + num)\n\n            max_by_digit[digit] = max(max_by_digit[digit], num)\n\n        return max_sum"}
{"code": "class Solution {\n    public:\n        int maxSum(vector<int>& nums) {\n        int res = -1, max_num[10] = {};\n        for (auto num : nums) {\n            int max_d = 0;\n            for (int v = num; v; v /= 10)\n                max_d = max(max_d, v % 10);\n            if (max_num[max_d])\n                res = max(res, max_num[max_d] + num);\n            max_num[max_d] = max(max_num[max_d], num);\n        }\n        return res;\n    }\n};"}
{"code": "class Solution {\n    public String finalString(String s) {\n        StringBuilder nm=new StringBuilder();\n        for(char c:s.toCharArray())\n        {\n            if(c=='i')\n            {\n                nm.reverse();\n            }\n            else\n            {\n                nm.append(c);\n            }\n        }\n        return nm.toString();\n    }\n}"}
{"code": "class Solution:\n    def finalString(self, s: str) -> str:\n        while \"i\" in s:\n            index=s.index(\"i\")\n\n            #first half and second half\n            first=s[:index][::-1]\n            second=s[index+1:]\n\n            s=\"\".join([first,second])\n        return s"}
{"code": "class Solution {\npublic:\n    string finalString(const string &s) {\n        string a, b;\n        for (char ch : s)\n            if (ch == 'i')\n                swap(a, b);\n            else\n                a += ch;\n        return string(rbegin(b), rend(b)) + a;\n    }\n};"}
{"code": "class Solution {\n    int minAbsoluteDifference(List<Integer> nums, int x) {\n        int ans = Integer.MAX_VALUE;\n        TreeSet<Integer> s = new TreeSet<>();\n        for(int i = x; i < nums.size(); ++i){\n            s.add(nums.get(i-x));\n            Integer high = s.ceiling(nums.get(i)), low = s.floor(nums.get(i));\n            if(high != null) ans = Math.min(ans, Math.abs(nums.get(i) - high));\n            if(low != null) ans = Math.min(ans, Math.abs(nums.get(i) - low));\n        }\n        return ans;\n    }\n}"}
{"code": "class Solution:\n  def minAbsoluteDifference(self, nums: List[int], x: int) -> int:\n    if x == 0:\n      return 0\n\n    arr, best_dist = SortedList([]), float('inf')\n    for i in range(x, len(nums)):\n      arr.add(nums[i - x])\n      v = nums[i]\n\n      pos = arr.bisect_left(v)\n      if pos < len(arr):\n        best_dist = min(best_dist, abs(arr[pos] - v))\n      if pos > 0:\n        best_dist = min(best_dist, abs(arr[pos - 1] - v))\n    \n    return best_dist"}
{"code": "class Solution {\npublic:\n    int minAbsoluteDifference(vector<int>& nums, int x) {\n        int ans = INT_MAX;\n        set<int> s;\n        for(int i = x; i < nums.size(); ++i){\n            s.insert(nums[i-x]);\n            auto it = s.upper_bound(nums[i]);\n            if(it != s.end()) ans = min(ans, abs(nums[i] - *it));\n            if(it != s.begin()) ans = min(ans, abs(nums[i] - *prev(it)));\n        }\n        return ans;\n    }\n};"}
{"code": "class Solution {\n    public ListNode doubleIt(ListNode head) {\n        if (head.val > 4)\n            head = new ListNode(0, head);\n        for(ListNode node = head; node != null; node = node.next) {\n            node.val = (node.val * 2) % 10;\n            if (node.next != null && node.next.val > 4)\n                node.val++;\n        }\n        return head;\n    }\n}"}
{"code": "class Solution:\n    def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if head.val > 4:\n            head = ListNode(0, head)\n        node = head\n        while node:\n            node.val = (node.val * 2) % 10\n            if node.next and node.next.val > 4:\n                node.val += 1\n            node = node.next\n        return head"}
{"code": "class Solution {\npublic:\n    ListNode* doubleIt(ListNode* head) {\n        if (head->val > 4)\n            head = new ListNode(0, head);\n        for(ListNode* node = head; node; node = node->next) {\n            node->val = (node->val * 2) % 10;\n            if (node->next && node->next->val > 4)\n                node->val++;\n        }\n        return head;\n    }\n};"}
{"code": "class Solution {\n    static final int MOD = 1000000007;\n\n    public int maximumScore(List<Integer> nums, int k) {\n        int n = nums.size();\n\n        int upper = Collections.max(nums) + 1;\n\n        boolean[] prime = new boolean[upper];\n        int[] primeScore = new int[upper];\n        Arrays.fill(prime, true);\n        prime[0] = prime[1] = false;\n        for (int i = 2; i < upper; i++) {\n            if (prime[i]) {\n                for (int j = i; j < upper; j += i) {\n                    primeScore[j]++;\n                    prime[j] = false;\n                }\n            }\n        }\n\n        int[] nextGreaterElement = new int[n];\n        Arrays.fill(nextGreaterElement, n);\n        Stack<Integer> s = new Stack<>();\n        for (int i = n - 1; i >= 0; i--) {\n            while (!s.empty() && primeScore[nums.get(i)] >= primeScore[nums.get(s.peek())]) {\n                s.pop();\n            }\n            nextGreaterElement[i] = s.empty() ? n : s.peek();\n            s.push(i);\n        }\n\n        int[] prevGreaterOrEqualElement = new int[n];\n        Arrays.fill(prevGreaterOrEqualElement, -1);\n        s = new Stack<>();\n        for (int i = 0; i < n; i++) {\n            while (!s.empty() && primeScore[nums.get(i)] > primeScore[nums.get(s.peek())]) {\n                s.pop();\n            }\n            prevGreaterOrEqualElement[i] = s.empty() ? -1 : s.peek();\n            s.push(i);\n        }\n\n        int res = 1;\n        int[][] tuples = new int[n][2];\n        for (int i = 0; i < n; i++) {\n            tuples[i][0] = nums.get(i);\n            tuples[i][1] = i;\n        }\n        Arrays.sort(tuples, new Comparator<int[]>() {\n            public int compare(int[] a, int[] b) {\n                return b[0] - a[0];\n            }\n        });\n        for (int i = 0; i < n; i++) {\n            int num = tuples[i][0];\n            int idx = tuples[i][1];\n            int operations = Math.min((idx - prevGreaterOrEqualElement[idx]) * (nextGreaterElement[idx] - idx), k);\n            res = (int)((1L * res * pow(num, operations)) % MOD);\n            k -= operations;\n            if (k == 0) {\n                return res;\n            }\n        }\n\n        return res;\n    }\n\n    public int pow(int x, int n) {\n        int res = 1;\n        while (n > 0) {\n            if (n % 2 == 1) {\n                res = (int)((1L * res * x) % MOD);\n            }\n            x = (int)((1L * x * x) % MOD);\n            n /= 2;\n        }\n        return res;\n    }\n}"}
{"code": "class Solution: \n    MOD = 1000000007\n\n    def maximumScore(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n\n        upper = max(nums) + 1\n\n        prime = [True]*upper\n        prime[0] = prime[1] = False\n        primeScore = [0]*upper\n        for i in range(2, upper):\n            if prime[i]:\n                for j in range(i, upper, i):\n                    primeScore[j] += 1\n                    prime[j] = False\n\n        nextGreaterElement = [n]*n\n        s = []\n        for i in range(n - 1, -1, -1):\n            while s and primeScore[nums[i]] >= primeScore[nums[s[-1]]]:\n                s.pop()\n            nextGreaterElement[i] = s[-1] if s else n\n            s.append(i)\n\n        prevGreaterOrEqualElement = [-1]*n\n        s = []\n        for i in range(n):\n            while s and primeScore[nums[i]] > primeScore[nums[s[-1]]]:\n                s.pop()\n            prevGreaterOrEqualElement[i] = s[-1] if s else -1\n            s.append(i)\n\n        res = 1\n        tuples = [[nums[i], i] for i in range(n)]\n        tuples.sort(reverse=True)\n        for num, idx in tuples:\n            operations = min((idx - prevGreaterOrEqualElement[idx]) * (nextGreaterElement[idx] - idx), k)\n            res = (res * self.pow(num, operations)) % self.MOD\n            k -= operations\n            if k == 0:\n                return res\n\n        return res\n\n    def pow(self, x: int, n: int) -> int:\n        res = 1\n        while n > 0:\n            if n % 2 == 1:\n                res = (res * x) % self.MOD\n            x = (x * x) % self.MOD\n            n //= 2\n        return res"}
{"code": "class Solution {\npublic:\n    const int MOD = 1000000007;\n\n    int maximumScore(vector<int>& nums, int k) {\n        int n = nums.size();\n\n        int upper = *max_element(nums.begin(), nums.end()) + 1;\n\n        vector<bool> prime(upper, true);\n        prime[0] = prime[1] = false;\n        vector<int> primeScore(upper, 0);\n        for (int i = 2; i < upper; i++) {\n            if (prime[i]) {\n                for (int j = i; j < upper; j += i) {\n                    primeScore[j]++;\n                    prime[j] = false;\n                }\n            }\n        }\n\n        vector<int> nextGreaterElement(n, n);\n        stack<int> s;\n        for (int i = n - 1; i >= 0; i--) {\n            while (!s.empty() && primeScore[nums[i]] >= primeScore[nums[s.top()]]) {\n                s.pop();\n            }\n            nextGreaterElement[i] = s.empty() ? n : s.top();\n            s.push(i);\n        }\n\n        vector<int> prevGreaterOrEqualElement(n, -1);\n        s = stack<int>();\n        for (int i = 0; i < n; i++) {\n            while (!s.empty() && primeScore[nums[i]] > primeScore[nums[s.top()]]) {\n                s.pop();\n            }\n            prevGreaterOrEqualElement[i] = s.empty() ? -1 : s.top();\n            s.push(i);\n        }\n\n        int res = 1;\n        vector<pair<int, int>> tuples(n);\n        for (int i = 0; i < n; i++) {\n            tuples[i].first = nums[i];\n            tuples[i].second = i;\n        }\n        sort(tuples.rbegin(), tuples.rend());\n        for (const auto& [num, i] : tuples) {\n            int operations = min((i - prevGreaterOrEqualElement[i]) * (nextGreaterElement[i] - i), k);\n            res = (int)((1L * res * pow(num, operations)) % MOD);\n            k -= operations;\n            if (k == 0) {\n                return res;\n            }\n        }\n\n        return res;\n    }\n\n    int pow(int x, int n) {\n        int res = 1;\n        while (n > 0) {\n            if (n % 2 == 1) {\n                res = (int)((1L * res * x) % MOD);\n            }\n            x = (int)((1L * x * x) % MOD);\n            n /= 2;\n        }\n        return res;\n    }\n};"}
{"code": "class Solution {\n    public long findMaximumElegance(int[][] A, int k) {\n        Arrays.sort(A, (a, b) -> b[0] - a[0]);\n        long res = 0, cur = 0;\n        List<Integer> dup = new ArrayList<>();\n        Set<Integer> seen = new HashSet<>();\n        for (int i = 0; i < A.length; ++i) {\n            if (i < k) {\n                if (seen.contains(A[i][1])) {\n                    dup.add(A[i][0]);\n                }\n                cur += A[i][0];\n            } else if (!seen.contains(A[i][1])) {\n                if (dup.isEmpty()) break;\n                cur += A[i][0] - dup.remove(dup.size() - 1);\n            }\n            seen.add(A[i][1]);\n            res = Math.max(res, cur + 1L * seen.size() * seen.size());\n        }\n        return res;\n    }\n}"}
{"code": "class Solution:\n    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:\n        items = sorted(items, key=lambda v: -v[0])\n        res = cur = 0\n        A = []\n        seen = set()\n        for i, (p, c) in enumerate(items):\n            if i < k:\n                if c in seen:\n                    A.append(p)\n                cur += p\n            elif c not in seen:\n                if not A: break\n                cur += p - A.pop()\n            seen.add(c)\n            res = max(res, cur + len(seen) * len(seen))\n        return res"}
{"code": "class Solution {\npublic:\n    long long findMaximumElegance(vector<vector<int>>& A, int k) {\n        sort(A.begin(), A.end(), [](const vector<int>& a, const vector<int>& b) {\n            return a[0] > b[0];\n        });\n        long long res = 0, cur = 0;\n        vector<int> dup;\n        unordered_set<int> seen;\n        for (int i = 0; i < A.size(); ++i) {\n            if (i < k) {\n                if (seen.count(A[i][1])) {\n                    dup.push_back(A[i][0]);\n                }\n                cur += A[i][0];\n            } else if (seen.find(A[i][1]) == seen.end()) {\n                if (dup.empty()) break;\n                cur += A[i][0] - dup.back();\n                dup.pop_back();\n            }\n            seen.insert(A[i][1]);\n            res = fmax(res, cur + 1L * seen.size() * seen.size());\n        }\n        return res;\n    }\n};"}
{"code": "class Solution {\n    public int maxSum(int[] nums) {\n    int ans = -1;\n    Map<Integer,List<Integer>> ump = new HashMap<>();\n    for(int i = 0; i < nums.length; ++i){\n        int t = nums[i], maxDigit = 0;\n        while(t != 0){ //evaluate max digit in the number\n            maxDigit = Math.max(t%10, maxDigit);\n            t = t/10;\n        }\n        if(!ump.containsKey(maxDigit)) ump.put(maxDigit, new ArrayList<>());\n        ump.get(maxDigit).add(nums[i]); // add the number to the map \n    }\n    for(Map.Entry<Integer, List<Integer>> entry: ump.entrySet()){\n        entry.getValue().sort(Comparator.reverseOrder()); //to find max two number in each max digit \n        if(entry.getValue().size() >= 2) ans = Math.max(ans, entry.getValue().get(0) + entry.getValue().get(1)); //sum max two number and take max\n    }\n    return ans;\n    }\n}"}
{"code": "class Solution:\n    def maxSum(self, nums: List[int]) -> int:\n        max_by_digit = defaultdict(int)\n        max_sum = -1\n\n        for num in nums:\n            digit = max(str(num))\n\n            if digit in max_by_digit:\n                max_sum = max(max_sum, max_by_digit[digit] + num)\n\n            max_by_digit[digit] = max(max_by_digit[digit], num)\n\n        return max_sum"}
{"code": "class Solution {\n    public:\n        int maxSum(vector<int>& nums) {\n        int res = -1, max_num[10] = {};\n        for (auto num : nums) {\n            int max_d = 0;\n            for (int v = num; v; v /= 10)\n                max_d = max(max_d, v % 10);\n            if (max_num[max_d])\n                res = max(res, max_num[max_d] + num);\n            max_num[max_d] = max(max_num[max_d], num);\n        }\n        return res;\n    }\n};"}
{"code": "class Solution {\n    public String finalString(String s) {\n        StringBuilder nm=new StringBuilder();\n        for(char c:s.toCharArray())\n        {\n            if(c=='i')\n            {\n                nm.reverse();\n            }\n            else\n            {\n                nm.append(c);\n            }\n        }\n        return nm.toString();\n    }\n}"}
{"code": "class Solution:\n    def finalString(self, s: str) -> str:\n        while \"i\" in s:\n            index=s.index(\"i\")\n\n            #first half and second half\n            first=s[:index][::-1]\n            second=s[index+1:]\n\n            s=\"\".join([first,second])\n        return s"}
{"code": "class Solution {\npublic:\n    string finalString(const string &s) {\n        string a, b;\n        for (char ch : s)\n            if (ch == 'i')\n                swap(a, b);\n            else\n                a += ch;\n        return string(rbegin(b), rend(b)) + a;\n    }\n};"}
{"code": "class Solution {\n    int minAbsoluteDifference(List<Integer> nums, int x) {\n        int ans = Integer.MAX_VALUE;\n        TreeSet<Integer> s = new TreeSet<>();\n        for(int i = x; i < nums.size(); ++i){\n            s.add(nums.get(i-x));\n            Integer high = s.ceiling(nums.get(i)), low = s.floor(nums.get(i));\n            if(high != null) ans = Math.min(ans, Math.abs(nums.get(i) - high));\n            if(low != null) ans = Math.min(ans, Math.abs(nums.get(i) - low));\n        }\n        return ans;\n    }\n}"}
{"code": "class Solution:\n  def minAbsoluteDifference(self, nums: List[int], x: int) -> int:\n    if x == 0:\n      return 0\n\n    arr, best_dist = SortedList([]), float('inf')\n    for i in range(x, len(nums)):\n      arr.add(nums[i - x])\n      v = nums[i]\n\n      pos = arr.bisect_left(v)\n      if pos < len(arr):\n        best_dist = min(best_dist, abs(arr[pos] - v))\n      if pos > 0:\n        best_dist = min(best_dist, abs(arr[pos - 1] - v))\n    \n    return best_dist"}
{"code": "class Solution {\npublic:\n    int minAbsoluteDifference(vector<int>& nums, int x) {\n        int ans = INT_MAX;\n        set<int> s;\n        for(int i = x; i < nums.size(); ++i){\n            s.insert(nums[i-x]);\n            auto it = s.upper_bound(nums[i]);\n            if(it != s.end()) ans = min(ans, abs(nums[i] - *it));\n            if(it != s.begin()) ans = min(ans, abs(nums[i] - *prev(it)));\n        }\n        return ans;\n    }\n};"}
{"code": "class Solution {\n    public ListNode doubleIt(ListNode head) {\n        if (head.val > 4)\n            head = new ListNode(0, head);\n        for(ListNode node = head; node != null; node = node.next) {\n            node.val = (node.val * 2) % 10;\n            if (node.next != null && node.next.val > 4)\n                node.val++;\n        }\n        return head;\n    }\n}"}
{"code": "class Solution:\n    def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if head.val > 4:\n            head = ListNode(0, head)\n        node = head\n        while node:\n            node.val = (node.val * 2) % 10\n            if node.next and node.next.val > 4:\n                node.val += 1\n            node = node.next\n        return head"}
{"code": "class Solution {\npublic:\n    ListNode* doubleIt(ListNode* head) {\n        if (head->val > 4)\n            head = new ListNode(0, head);\n        for(ListNode* node = head; node; node = node->next) {\n            node->val = (node->val * 2) % 10;\n            if (node->next && node->next->val > 4)\n                node->val++;\n        }\n        return head;\n    }\n};"}
{"code": "class Solution {\n    static final int MOD = 1000000007;\n\n    public int maximumScore(List<Integer> nums, int k) {\n        int n = nums.size();\n\n        int upper = Collections.max(nums) + 1;\n\n        boolean[] prime = new boolean[upper];\n        int[] primeScore = new int[upper];\n        Arrays.fill(prime, true);\n        prime[0] = prime[1] = false;\n        for (int i = 2; i < upper; i++) {\n            if (prime[i]) {\n                for (int j = i; j < upper; j += i) {\n                    primeScore[j]++;\n                    prime[j] = false;\n                }\n            }\n        }\n\n        int[] nextGreaterElement = new int[n];\n        Arrays.fill(nextGreaterElement, n);\n        Stack<Integer> s = new Stack<>();\n        for (int i = n - 1; i >= 0; i--) {\n            while (!s.empty() && primeScore[nums.get(i)] >= primeScore[nums.get(s.peek())]) {\n                s.pop();\n            }\n            nextGreaterElement[i] = s.empty() ? n : s.peek();\n            s.push(i);\n        }\n\n        int[] prevGreaterOrEqualElement = new int[n];\n        Arrays.fill(prevGreaterOrEqualElement, -1);\n        s = new Stack<>();\n        for (int i = 0; i < n; i++) {\n            while (!s.empty() && primeScore[nums.get(i)] > primeScore[nums.get(s.peek())]) {\n                s.pop();\n            }\n            prevGreaterOrEqualElement[i] = s.empty() ? -1 : s.peek();\n            s.push(i);\n        }\n\n        int res = 1;\n        int[][] tuples = new int[n][2];\n        for (int i = 0; i < n; i++) {\n            tuples[i][0] = nums.get(i);\n            tuples[i][1] = i;\n        }\n        Arrays.sort(tuples, new Comparator<int[]>() {\n            public int compare(int[] a, int[] b) {\n                return b[0] - a[0];\n            }\n        });\n        for (int i = 0; i < n; i++) {\n            int num = tuples[i][0];\n            int idx = tuples[i][1];\n            int operations = Math.min((idx - prevGreaterOrEqualElement[idx]) * (nextGreaterElement[idx] - idx), k);\n            res = (int)((1L * res * pow(num, operations)) % MOD);\n            k -= operations;\n            if (k == 0) {\n                return res;\n            }\n        }\n\n        return res;\n    }\n\n    public int pow(int x, int n) {\n        int res = 1;\n        while (n > 0) {\n            if (n % 2 == 1) {\n                res = (int)((1L * res * x) % MOD);\n            }\n            x = (int)((1L * x * x) % MOD);\n            n /= 2;\n        }\n        return res;\n    }\n}"}
{"code": "class Solution: \n    MOD = 1000000007\n\n    def maximumScore(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n\n        upper = max(nums) + 1\n\n        prime = [True]*upper\n        prime[0] = prime[1] = False\n        primeScore = [0]*upper\n        for i in range(2, upper):\n            if prime[i]:\n                for j in range(i, upper, i):\n                    primeScore[j] += 1\n                    prime[j] = False\n\n        nextGreaterElement = [n]*n\n        s = []\n        for i in range(n - 1, -1, -1):\n            while s and primeScore[nums[i]] >= primeScore[nums[s[-1]]]:\n                s.pop()\n            nextGreaterElement[i] = s[-1] if s else n\n            s.append(i)\n\n        prevGreaterOrEqualElement = [-1]*n\n        s = []\n        for i in range(n):\n            while s and primeScore[nums[i]] > primeScore[nums[s[-1]]]:\n                s.pop()\n            prevGreaterOrEqualElement[i] = s[-1] if s else -1\n            s.append(i)\n\n        res = 1\n        tuples = [[nums[i], i] for i in range(n)]\n        tuples.sort(reverse=True)\n        for num, idx in tuples:\n            operations = min((idx - prevGreaterOrEqualElement[idx]) * (nextGreaterElement[idx] - idx), k)\n            res = (res * self.pow(num, operations)) % self.MOD\n            k -= operations\n            if k == 0:\n                return res\n\n        return res\n\n    def pow(self, x: int, n: int) -> int:\n        res = 1\n        while n > 0:\n            if n % 2 == 1:\n                res = (res * x) % self.MOD\n            x = (x * x) % self.MOD\n            n //= 2\n        return res"}
{"code": "class Solution {\npublic:\n    const int MOD = 1000000007;\n\n    int maximumScore(vector<int>& nums, int k) {\n        int n = nums.size();\n\n        int upper = *max_element(nums.begin(), nums.end()) + 1;\n\n        vector<bool> prime(upper, true);\n        prime[0] = prime[1] = false;\n        vector<int> primeScore(upper, 0);\n        for (int i = 2; i < upper; i++) {\n            if (prime[i]) {\n                for (int j = i; j < upper; j += i) {\n                    primeScore[j]++;\n                    prime[j] = false;\n                }\n            }\n        }\n\n        vector<int> nextGreaterElement(n, n);\n        stack<int> s;\n        for (int i = n - 1; i >= 0; i--) {\n            while (!s.empty() && primeScore[nums[i]] >= primeScore[nums[s.top()]]) {\n                s.pop();\n            }\n            nextGreaterElement[i] = s.empty() ? n : s.top();\n            s.push(i);\n        }\n\n        vector<int> prevGreaterOrEqualElement(n, -1);\n        s = stack<int>();\n        for (int i = 0; i < n; i++) {\n            while (!s.empty() && primeScore[nums[i]] > primeScore[nums[s.top()]]) {\n                s.pop();\n            }\n            prevGreaterOrEqualElement[i] = s.empty() ? -1 : s.top();\n            s.push(i);\n        }\n\n        int res = 1;\n        vector<pair<int, int>> tuples(n);\n        for (int i = 0; i < n; i++) {\n            tuples[i].first = nums[i];\n            tuples[i].second = i;\n        }\n        sort(tuples.rbegin(), tuples.rend());\n        for (const auto& [num, i] : tuples) {\n            int operations = min((i - prevGreaterOrEqualElement[i]) * (nextGreaterElement[i] - i), k);\n            res = (int)((1L * res * pow(num, operations)) % MOD);\n            k -= operations;\n            if (k == 0) {\n                return res;\n            }\n        }\n\n        return res;\n    }\n\n    int pow(int x, int n) {\n        int res = 1;\n        while (n > 0) {\n            if (n % 2 == 1) {\n                res = (int)((1L * res * x) % MOD);\n            }\n            x = (int)((1L * x * x) % MOD);\n            n /= 2;\n        }\n        return res;\n    }\n};"}
{"code": "class Solution {\n    public long findMaximumElegance(int[][] A, int k) {\n        Arrays.sort(A, (a, b) -> b[0] - a[0]);\n        long res = 0, cur = 0;\n        List<Integer> dup = new ArrayList<>();\n        Set<Integer> seen = new HashSet<>();\n        for (int i = 0; i < A.length; ++i) {\n            if (i < k) {\n                if (seen.contains(A[i][1])) {\n                    dup.add(A[i][0]);\n                }\n                cur += A[i][0];\n            } else if (!seen.contains(A[i][1])) {\n                if (dup.isEmpty()) break;\n                cur += A[i][0] - dup.remove(dup.size() - 1);\n            }\n            seen.add(A[i][1]);\n            res = Math.max(res, cur + 1L * seen.size() * seen.size());\n        }\n        return res;\n    }\n}"}
{"code": "class Solution:\n    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:\n        items = sorted(items, key=lambda v: -v[0])\n        res = cur = 0\n        A = []\n        seen = set()\n        for i, (p, c) in enumerate(items):\n            if i < k:\n                if c in seen:\n                    A.append(p)\n                cur += p\n            elif c not in seen:\n                if not A: break\n                cur += p - A.pop()\n            seen.add(c)\n            res = max(res, cur + len(seen) * len(seen))\n        return res"}
{"code": "class Solution {\npublic:\n    long long findMaximumElegance(vector<vector<int>>& A, int k) {\n        sort(A.begin(), A.end(), [](const vector<int>& a, const vector<int>& b) {\n            return a[0] > b[0];\n        });\n        long long res = 0, cur = 0;\n        vector<int> dup;\n        unordered_set<int> seen;\n        for (int i = 0; i < A.size(); ++i) {\n            if (i < k) {\n                if (seen.count(A[i][1])) {\n                    dup.push_back(A[i][0]);\n                }\n                cur += A[i][0];\n            } else if (seen.find(A[i][1]) == seen.end()) {\n                if (dup.empty()) break;\n                cur += A[i][0] - dup.back();\n                dup.pop_back();\n            }\n            seen.insert(A[i][1]);\n            res = fmax(res, cur + 1L * seen.size() * seen.size());\n        }\n        return res;\n    }\n};"}
