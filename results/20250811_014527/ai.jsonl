{"code": "public class Solution {\n    public int maxSum(int[] nums) {\n        int[] maxSum = new int[10];\n        for (int num : nums) {\n            int maxDigit = 0;\n            int temp = num;\n            while (temp > 0) {\n                maxDigit = Math.max(maxDigit, temp % 10);\n                temp /= 10;\n            }\n            for (int i = 0; i < 10; i++) {\n                if (i == maxDigit) {\n                    maxSum[i] = Math.max(maxSum[i], num + maxSum[i]);\n                } else {\n                    maxSum[i] = Math.max(maxSum[i], num);\n                }\n            }\n        }\n        int res = -1;\n        for (int sum : maxSum) {\n            res = Math.max(res, sum);\n        }\n        return res == 0 ? -1 : res;\n    }\n}"}
{"code": "class Solution:\n    def maxSum(self, nums: List[int]) -> int:\n        max_digit = {}\n        for num in nums:\n            digit = max(int(d) for d in str(num))\n            if digit not in max_digit:\n                max_digit[digit] = []\n            max_digit[digit].append(num)\n        res = -1\n        for digit, values in max_digit.items():\n            if len(values) >= 2:\n                values.sort(reverse=True)\n                res = max(res, values[0] + values[1])\n        return res"}
{"code": "class Solution {\npublic:\n    int maxSum(std::vector<int>& nums) {\n        int maxSum = -1;\n        for (int i = 0; i < nums.size(); i++) {\n            for (int j = i + 1; j < nums.size(); j++) {\n                if (maxDigit(nums[i]) == maxDigit(nums[j])) {\n                    maxSum = std::max(maxSum, nums[i] + nums[j]);\n                }\n            }\n        }\n        return maxSum;\n    }\n\nprivate:\n    int maxDigit(int num) {\n        int maxDigit = 0;\n        while (num > 0) {\n            maxDigit = std::max(maxDigit, num % 10);\n            num /= 10;\n        }\n        return maxDigit;\n    }\n};"}
{"code": "class Solution {\n    public String finalString(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (char c : s.toCharArray()) {\n            if (c == 'i') {\n                sb.reverse();\n            } else {\n                sb.append(c);\n            }\n        }\n        return sb.toString();\n    }\n}"}
{"code": "class Solution:\n    def finalString(self, s: str) -> str:\n        res = \"\"\n        for c in s:\n            if c == 'i':\n                res = res[::-1]\n            else:\n                res += c\n        return res"}
{"code": "class Solution {\npublic:\n    std::string finalString(std::string s) {\n        std::string result = \"\";\n        for (char c : s) {\n            if (c == 'i') {\n                std::reverse(result.begin(), result.end());\n            } else {\n                result += c;\n            }\n        }\n        return result;\n    }\n};"}
{"code": "public class Solution {\n    public int minAbsoluteDifference(List<Integer> nums, int x) {\n        TreeMap<Integer, Integer> map = new TreeMap<>();\n        map.put(nums.get(0), 0);\n        int n = nums.size();\n        int minDiff = Integer.MAX_VALUE;\n\n        for (int i = 1; i < n; i++) {\n            if (i >= x) {\n                map.remove(nums.get(i - x));\n            }\n            Integer lower = map.floorKey(nums.get(i));\n            Integer higher = map.ceilingKey(nums.get(i));\n            if (lower != null) {\n                minDiff = Math.min(minDiff, Math.abs(nums.get(i) - lower));\n            }\n            if (higher != null) {\n                minDiff = Math.min(minDiff, Math.abs(nums.get(i) - higher));\n            }\n            map.put(nums.get(i), i);\n        }\n\n        return minDiff;\n    }\n}"}
{"code": "class Solution:\n    def minAbsoluteDifference(self, nums: List[int], x: int) -> int:\n        n = len(nums)\n        min_diff = float('inf')\n        for i in range(n):\n            for j in range(i + x, n):\n                min_diff = min(min_diff, abs(nums[i] - nums[j]))\n        return min_diff"}
{"code": "class Solution {\npublic:\n    int minAbsoluteDifference(std::vector<int>& nums, int x) {\n        int minDiff = INT_MAX;\n        for (int i = 0; i < nums.size(); i++) {\n            for (int j = i + x; j < nums.size(); j++) {\n                minDiff = std::min(minDiff, std::abs(nums[i] - nums[j]));\n            }\n        }\n        return minDiff;\n    }\n};"}
{"code": "class Solution {\n    public ListNode doubleIt(ListNode head) {\n        // Convert linked list to number\n        long num = 0;\n        while (head != null) {\n            num = num * 10 + head.val;\n            head = head.next;\n        }\n\n        // Double the number\n        num *= 2;\n\n        // Convert number back to linked list\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        do {\n            curr.next = new ListNode((int)(num % 10));\n            num /= 10;\n            curr = curr.next;\n        } while (num > 0);\n\n        // Reverse the linked list and return\n        return reverse(dummy.next);\n    }\n\n    private ListNode reverse(ListNode head) {\n        ListNode prev = null;\n        while (head != null) {\n            ListNode next = head.next;\n            head.next = prev;\n            prev = head;\n            head = next;\n        }\n        return prev;\n    }\n}"}
{"code": "class Solution:\n    def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        # Convert linked list to integer\n        num = 0\n        curr = head\n        while curr:\n            num = num * 10 + curr.val\n            curr = curr.next\n\n        # Double the integer\n        num *= 2\n\n        # Convert integer to linked list\n        dummy = ListNode(0)\n        curr = dummy\n        for digit in str(num):\n            curr.next = ListNode(int(digit))\n            curr = curr.next\n\n        return dummy.next"}
{"code": "class Solution {\npublic:\n    ListNode* doubleIt(ListNode* head) {\n        ListNode* current = head;\n        int carry = 0;\n        while (current != nullptr) {\n            int sum = current->val * 2 + carry;\n            current->val = sum % 10;\n            carry = sum / 10;\n            if (current->next == nullptr && carry > 0) {\n                current->next = new ListNode(carry);\n                break;\n            }\n            current = current->next;\n        }\n        return head;\n    }\n};"}
{"code": "public class Solution {\n    private static final int MOD = 1_000_000_007;\n    private List<Integer> nums;\n    private int n;\n    private List<Integer>[] factors;\n\n    public int maximumScore(List<Integer> nums, int k) {\n        this.nums = nums;\n        this.n = nums.size();\n        this.factors = new ArrayList[n];\n        for (int i = 0; i < n; i++) {\n            factors[i] = primeFactors(nums.get(i));\n        }\n\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> b[2] - a[2]);\n        pq.offer(new int[]{0, n - 1, maxPrimeScore(0, n - 1)});\n\n        long res = 1;\n        boolean[] chosen = new boolean[n];\n        while (k-- > 0) {\n            int[] cur = pq.poll();\n            int l = cur[0], r = cur[1], maxScore = cur[2];\n            res = (res * maxScore) % MOD;\n\n            int maxIdx = maxPrimeScoreIndex(l, r);\n            chosen[maxIdx] = true;\n\n            if (maxIdx - 1 >= l && !chosen[maxIdx - 1]) {\n                pq.offer(new int[]{l, maxIdx - 1, maxPrimeScore(l, maxIdx - 1)});\n            }\n            if (maxIdx + 1 <= r && !chosen[maxIdx + 1]) {\n                pq.offer(new int[]{maxIdx + 1, r, maxPrimeScore(maxIdx + 1, r)});\n            }\n        }\n\n        return (int) res;\n    }\n\n    private List<Integer> primeFactors(int num) {\n        List<Integer> factors = new ArrayList<>();\n        for (int i = 2; i * i <= num; i++) {\n            if (num % i == 0) {\n                factors.add(i);\n                while (num % i == 0) {\n                    num /= i;\n                }\n            }\n        }\n        if (num > 1) {\n            factors.add(num);\n        }\n        return factors;\n    }\n\n    private int maxPrimeScore(int l, int r) {\n        int maxScore = 0;\n        for (int i = l; i <= r; i++) {\n            maxScore = Math.max(maxScore, factors[i].size());\n        }\n        return maxScore;\n    }\n\n    private int maxPrimeScoreIndex(int l, int r) {\n        int maxScore = 0, idx = -1;\n        for (int i = l; i <= r; i++) {\n            if (factors[i].size() >= maxScore) {\n                maxScore = factors[i].size();\n                idx = i;\n            }\n        }\n        return idx;\n    }\n}"}
{"code": "class Solution:\n    def maximumScore(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        MOD = 10**9 + 7\n\n        # Precompute the prime score of all numbers in nums\n        prime_score = [0] * n\n        for i, num in enumerate(nums):\n            for j in range(2, int(sqrt(num)) + 1):\n                if num % j == 0:\n                    prime_score[i] += 1\n                    while num % j == 0:\n                        num //= j\n            if num > 1:\n                prime_score[i] += 1\n\n        # Compute the maximum score using dynamic programming\n        dp = [1]\n        for _ in range(k):\n            new_dp = [0] * (n + 1)\n            for l in range(n):\n                for r in range(l, n):\n                    max_prime_score = max(prime_score[l:r+1])\n                    max_index = prime_score[l:r+1].index(max_prime_score) + l\n                    new_dp[r+1] = max(new_dp[r+1], dp[l] * nums[max_index] % MOD)\n            dp = new_dp\n\n        return max(dp) % MOD"}
{"code": "class Solution {\npublic:\n    int maximumScore(std::vector<int>& nums, int k) {\n        const int MOD = 1e9 + 7;\n        int n = nums.size();\n        std::vector<int> primeScore(n);\n        for (int i = 0; i < n; i++) {\n            primeScore[i] = getPrimeScore(nums[i]);\n        }\n        std::vector<std::vector<long long>> dp(n, std::vector<long long>(k + 1));\n        for (int i = 0; i < n; i++) {\n            dp[i][0] = nums[i];\n            for (int j = 1; j <= k; j++) {\n                for (int l = 0; l < i; l++) {\n                    if (primeScore[l] >= primeScore[i]) {\n                        dp[i][j] = std::max(dp[i][j], dp[l][j - 1] * nums[i] % MOD);\n                    }\n                }\n            }\n        }\n        long long maxScore = 0;\n        for (int i = 0; i < n; i++) {\n            maxScore = std::max(maxScore, dp[i][k]);\n        }\n        return maxScore % MOD;\n    }\n\nprivate:\n    int getPrimeScore(int num) {\n        int score = 0;\n        for (int i = 2; i <= std::sqrt(num); i++) {\n            if (num % i == 0) {\n                score++;\n                while (num % i == 0) {\n                    num /= i;\n                }\n            }\n        }\n        if (num > 1) {\n            score++;\n        }\n        return score;\n    }\n};"}
{"code": "class Solution {\n    private static final int MOD = 1_000_000_007;\n\n    public int findMaximumElegance(int[][] items, int k) {\n        int n = items.length;\n        List<int[]>[] categoryItems = new List[n + 1];\n        for (int i = 0; i <= n; i++) {\n            categoryItems[i] = new ArrayList<>();\n        }\n        for (int[] item : items) {\n            categoryItems[item[1]].add(item);\n        }\n\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\n        long[] dp = new long[k + 1];\n        dp[0] = 0;\n        int totalItems = 0;\n        for (List<int[]> itemList : categoryItems) {\n            if (itemList.isEmpty()) continue;\n\n            Collections.sort(itemList, Comparator.comparingInt(a -> -a[0]));\n            int categoryProfit = 0;\n            for (int[] item : itemList) {\n                categoryProfit += item[0];\n                pq.offer(item[0]);\n                if (pq.size() > totalItems + 1) {\n                    categoryProfit -= pq.poll();\n                }\n            }\n\n            for (int j = Math.min(k, totalItems + itemList.size()); j >= 0; j--) {\n                for (int l = Math.max(0, j - totalItems); l <= Math.min(j, itemList.size()); l++) {\n                    dp[j] = Math.max(dp[j], (j - l > 0 ? dp[j - l - 1] : 0) + categoryProfit);\n                }\n            }\n\n            totalItems += itemList.size();\n        }\n\n        long res = 0;\n        for (int i = 1; i <= k; i++) {\n            res = Math.max(res, dp[i] + (long)i * i);\n        }\n\n        return (int)(res % MOD);\n    }\n}"}
{"code": "class Solution:\n    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:\n        n = len(items)\n        items.sort(key=lambda x: (-x[0], x[1]))\n        dp = [[0, 0] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1])\n            dp[i][1] = max(dp[i - 1][0] + items[i - 1][0], dp[i - 1][1] + items[i - 1][0])\n        return max(dp[k]) + len(set([item[1] for item in items[:k]])) ** 2"}
{"code": "class Solution {\npublic:\n    long long findMaximumElegance(std::vector<std::vector<int>>& items, int k) {\n        const int MOD = 1e9 + 7;\n        int n = items.size();\n        std::vector<std::unordered_map<int, long long>> dp(n);\n        for (int i = 0; i < n; i++) {\n            dp[i][1 << items[i][1]] = items[i][0];\n            for (int j = 0; j < i; j++) {\n                for (auto& [mask, val] : dp[j]) {\n                    int newMask = mask | (1 << items[i][1]);\n                    dp[i][newMask] = std::max(dp[i][newMask], val + items[i][0]);\n                }\n            }\n        }\n        long long maxElegance = 0;\n        for (int i = 0; i < n; i++) {\n            for (auto& [mask, val] : dp[i]) {\n                int cnt = __builtin_popcount(mask);\n                if (cnt >= k) {\n                    maxElegance = std::max(maxElegance, val + cnt * cnt);\n                }\n            }\n        }\n        return maxElegance % MOD;\n    }\n};"}
{"code": "public class Solution {\n    public int maxSum(int[] nums) {\n        // Create an array of size 10 to keep track of the maximum values for each digit (0-9)\n        int[] maxDigits = new int[10];\n        \n        // Iterate through the array and update the maxDigits array with the maximum values for each digit\n        for (int num : nums) {\n            int maxDigit = getMaxDigit(num);\n            maxDigits[maxDigit] = Math.max(maxDigits[maxDigit], num);\n        }\n        \n        int maxSum = -1;\n        \n        // Iterate through the maxDigits array to find pairs with equal maximum digits\n        for (int i = 0; i <= 9; i++) {\n            for (int j = i; j <= 9; j++) {\n                if (maxDigits[i] != 0 && maxDigits[j] != 0 && i == j) {\n                    maxSum = Math.max(maxSum, maxDigits[i] + maxDigits[j]);\n                }\n            }\n        }\n        \n        return maxSum;\n    }\n    \n    // Helper method to get the maximum digit from a number\n    private int getMaxDigit(int num) {\n        int maxDigit = 0;\n        while (num > 0) {\n            maxDigit = Math.max(maxDigit, num % 10);\n            num /= 10;\n        }\n        return maxDigit;\n    }\n    \n}"}
{"code": "class Solution:\n    def maxSum(self, nums: List[int]) -> int:\n        max_digit_sum = {}  # Dictionary to store the maximum sum for each maximum digit\n        \n        for num in nums:\n            max_digit = max(str(num))  # Find the maximum digit in the current number\n            if max_digit in max_digit_sum:\n                max_digit_sum[max_digit] = max(max_digit_sum[max_digit], num)\n            else:\n                max_digit_sum[max_digit] = num\n        \n        max_sum = -1  # Initialize the maximum sum to -1\n        \n        # Iterate through the dictionary to find the maximum sum\n        for digit, num in max_digit_sum.items():\n            if max_digit_sum[digit] != num:\n                max_sum = max(max_sum, num + max_digit_sum[digit])\n        \n        return max_sum"}
{"code": "class Solution {\npublic:\n    int maxSum(std::vector<int>& nums) {\n        std::vector<int> maxDigit(10, -1); // To store the maximum number for each digit (0-9)\n        int maxSum = -1; // Initialize maxSum to -1 as the minimum possible answer\n        \n        for (int num : nums) {\n            int maxDig = 0; // To store the maximum digit in the current number\n            int temp = num; // Temporary variable to avoid modifying num\n            \n            while (temp > 0) {\n                int digit = temp % 10;\n                maxDig = std::max(maxDig, digit); // Update maxDig if a larger digit is found\n                temp /= 10;\n            }\n            \n            if (maxDigit[maxDig] != -1) {\n                // If we have seen a number with the same maximum digit before, update maxSum\n                maxSum = std::max(maxSum, maxDigit[maxDig] + num);\n            }\n            \n            // Update maxDigit[maxDig] with the maximum of the current number and the previous maximum\n            maxDigit[maxDig] = std::max(maxDigit[maxDig], num);\n        }\n        \n        return maxSum;\n    }\n};"}
{"code": "public class Solution {\n    public String finalString(String s) {\n        StringBuilder result = new StringBuilder();\n        StringBuilder reverseBuffer = new StringBuilder();\n        \n        boolean reverse = false;\n        \n        for (char c : s.toCharArray()) {\n            if (c == 'i') {\n                reverse = !reverse;\n            } else {\n                if (reverse) {\n                    reverseBuffer.insert(0, c);\n                } else {\n                    result.append(c);\n                }\n            }\n        }\n        \n        result.append(reverseBuffer);\n        \n        return result.toString();\n    }\n    \n}"}
{"code": "class Solution:\n    def finalString(self, s: str) -> str:\n        stack = []  # Use a stack to simulate typing process\n        \n        for char in s:\n            if char == 'i':\n                # If the character is 'i', reverse the stack\n                stack.reverse()\n            else:\n                stack.append(char)\n        \n        # Convert the stack to a string and return\n        return ''.join(stack)"}
{"code": "class Solution {\npublic:\n    std::string finalString(std::string s) {\n        std::string result = \"\"; // Initialize the result string\n        \n        for (char c : s) {\n            if (c == 'i') {\n                // If the character is 'i', reverse the result string\n                std::reverse(result.begin(), result.end());\n            } else {\n                // Otherwise, append the character to the result string\n                result += c;\n            }\n        }\n        \n        return result;\n    }\n};"}
{"code": "public class Solution {\n    public int minAbsoluteDifference(List<Integer> nums, int x) {\n        int n = nums.size();\n        int minAbsDiff = Integer.MAX_VALUE;\n        \n        // Create a TreeMap to store the indices of elements\n        TreeMap<Integer, Integer> indexMap = new TreeMap<>();\n        \n        for (int i = 0; i < n; i++) {\n            int num = nums.get(i);\n            \n            // Check if there exists a number in the TreeMap with a difference of at least x\n            // from the current number, and update the minimum absolute difference accordingly.\n            Integer floorKey = indexMap.floorKey(num - x);\n            if (floorKey != null) {\n                int index = indexMap.get(floorKey);\n                minAbsDiff = Math.min(minAbsDiff, Math.abs(num - nums.get(index)));\n            }\n            \n            // Check if there exists a number in the TreeMap with a difference of at least x\n            // from the current number, and update the minimum absolute difference accordingly.\n            Integer ceilingKey = indexMap.ceilingKey(num + x);\n            if (ceilingKey != null) {\n                int index = indexMap.get(ceilingKey);\n                minAbsDiff = Math.min(minAbsDiff, Math.abs(num - nums.get(index)));\n            }\n            \n            // Update the index of the current number in the TreeMap.\n            indexMap.put(num, i);\n        }\n        \n        return minAbsDiff;\n    }\n   \n}"}
{"code": "class Solution:\n    def minAbsoluteDifference(self, nums: List[int], x: int) -> int:\n        nums.sort()  # Sort the input array\n        \n        min_diff = float('inf')  # Initialize the minimum difference to positive infinity\n        \n        left = 0  # Initialize the left pointer\n        right = x  # Initialize the right pointer\n        \n        while right < len(nums):\n            min_diff = min(min_diff, nums[right] - nums[left])  # Update the minimum difference\n            \n            left += 1  # Move the left pointer\n            right += 1  # Move the right pointer\n        \n        return min_diff"}
{"code": "class Solution {\npublic:\n    int minAbsoluteDifference(std::vector<int>& nums, int x) {\n        int n = nums.size();\n        std::vector<std::pair<int, int>> indexedNums; // Store the numbers along with their indices\n        \n        // Create a vector of pairs (number, index)\n        for (int i = 0; i < n; ++i) {\n            indexedNums.push_back({nums[i], i});\n        }\n        \n        // Sort the vector based on numbers\n        std::sort(indexedNums.begin(), indexedNums.end());\n        \n        int minDiff = INT_MAX; // Initialize the minimum difference to a large value\n        \n        // Traverse the sorted vector and find the minimum absolute difference\n        for (int i = 0; i < n; ++i) {\n            // Find the index of the element that is at least x indices apart\n            int j = i + x;\n            if (j < n) {\n                int diff = abs(indexedNums[i].first - indexedNums[j].first);\n                minDiff = std::min(minDiff, diff);\n            }\n        }\n        \n        return minDiff;\n    }\n};"}
{"code": "public class Solution {\n    public ListNode doubleIt(ListNode head) {\n        if (head == null) {\n            return null;\n        }\n\n        int carry = 0;\n        ListNode current = head;\n        ListNode prev = null;\n\n        // Traverse the list in reverse order and double the values\n        while (current != null) {\n            int newVal = current.val * 2 + carry;\n            carry = newVal / 10;\n            current.val = newVal % 10;\n\n            prev = current;\n            current = current.next;\n        }\n\n        // If there's a remaining carry, add a new node for it\n        if (carry > 0) {\n            ListNode newNode = new ListNode(carry);\n            prev.next = newNode;\n        }\n\n        return reverseList(head);\n    }\n\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode current = head;\n\n        while (current != null) {\n            ListNode nextNode = current.next;\n            current.next = prev;\n            prev = current;\n            current = nextNode;\n        }\n\n        return prev;\n    }\n}"}
{"code": "class Solution:\n    def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head:\n            return None\n        \n        carry = 0\n        current = head\n        prev = None\n        \n        # Traverse the list in reverse order and double the values\n        while current:\n            newVal = current.val * 2 + carry\n            carry = newVal // 10\n            current.val = newVal % 10\n            \n            prev = current\n            current = current.next\n        \n        # If there's a remaining carry, add a new node for it\n        if carry > 0:\n            newNode = ListNode(carry)\n            prev.next = newNode\n        \n        return self.reverseList(head)\n    \n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        current = head\n        \n        while current:\n            nextNode = current.next\n            current.next = prev\n            prev = current\n            current = nextNode\n        \n        return prev"}
{"code": "class Solution {\npublic:\n    ListNode* doubleIt(ListNode* head) {\n        if (!head) {\n            return nullptr;\n        }\n\n        int carry = 0;\n        ListNode* current = head;\n        ListNode* prev = nullptr;\n\n        // Traverse the list in reverse order and double the values\n        while (current) {\n            int newVal = current->val * 2 + carry;\n            carry = newVal / 10;\n            current->val = newVal % 10;\n\n            prev = current;\n            current = current->next;\n        }\n\n        // If there's a remaining carry, add a new node for it\n        if (carry > 0) {\n            ListNode* newNode = new ListNode(carry);\n            prev->next = newNode;\n        }\n\n        return reverseList(head);\n    }\n\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* current = head;\n\n        while (current) {\n            ListNode* nextNode = current->next;\n            current->next = prev;\n            prev = current;\n            current = nextNode;\n        }\n\n        return prev;\n    }\n};"}
{"code": "public class Solution {\n    public int maximumScore(List<Integer> nums, int k) {\n        int MOD = 1000000007;\n        int n = nums.size();\n        \n        // Create an array to store the prime scores for each element.\n        int[] primeScores = new int[n];\n        \n        // Calculate the prime scores for each element using a helper function.\n        for (int i = 0; i < n; i++) {\n            primeScores[i] = calculatePrimeScore(nums.get(i));\n        }\n        \n        long score = 1L; // Initialize the score as a long integer to avoid overflow.\n        \n        // Create a max heap to keep track of the elements with the highest prime scores.\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<>((a, b) -> Integer.compare(primeScores[b], primeScores[a]));\n        \n        // Initialize the max heap with the element at index k.\n        maxHeap.offer(k);\n        \n        // Create two arrays to keep track of the left and right boundaries of the subarray.\n        int[] left = new int[n];\n        int[] right = new int[n];\n        \n        // Initialize the left and right boundaries.\n        left[k] = k;\n        right[k] = k;\n        \n        // Perform at most k operations.\n        for (int i = 0; i < k; i++) {\n            int maxIndex = maxHeap.poll(); // Get the index with the highest prime score.\n            \n            // Calculate the new score by multiplying the current score by the selected element.\n            score = (score * nums.get(maxIndex)) % MOD;\n            \n            // Update the left and right boundaries for the subarray.\n            int newLeft = left[maxIndex] - 1;\n            int newRight = right[maxIndex] + 1;\n            \n            // Add the new potential candidates to the max heap.\n            if (newLeft >= 0) {\n                maxHeap.offer(newLeft);\n                left[newLeft] = newLeft;\n                right[newLeft] = right[maxIndex];\n            }\n            if (newRight < n) {\n                maxHeap.offer(newRight);\n                left[newRight] = left[maxIndex];\n                right[newRight] = newRight;\n            }\n        }\n        \n        return (int)score;\n    }\n    \n    // Helper function to calculate the prime score of an integer.\n    private int calculatePrimeScore(int num) {\n        Set<Integer> factors = new HashSet<>();\n        \n        // Find prime factors of the number.\n        while (num % 2 == 0) {\n            factors.add(2);\n            num /= 2;\n        }\n        \n        for (int i = 3; i <= Math.sqrt(num); i += 2) {\n            while (num % i == 0) {\n                factors.add(i);\n                num /= i;\n            }\n        }\n        \n        if (num > 2) {\n            factors.add(num);\n        }\n        \n        return factors.size();\n    }\n}"}
{"code": "class Solution:\n    def maximumScore(self, nums: List[int], k: int) -> int:\n        def prime_score(x):\n            factors = set()\n            while x % 2 == 0:\n                factors.add(2)\n                x //= 2\n            for i in range(3, int(x ** 0.5) + 1, 2):\n                while x % i == 0:\n                    factors.add(i)\n                    x //= i\n            if x > 2:\n                factors.add(x)\n            return len(factors)\n        \n        max_score = 1\n        MOD = 10 ** 9 + 7\n        \n        pq = []  # Priority queue to store elements by their prime scores\n        \n        for num in nums:\n            heapq.heappush(pq, (-prime_score(num), num))  # Use a negative score to get the maximum prime score first\n        \n        while k > 0:\n            prime_score, num = heapq.heappop(pq)  # Pop the element with the highest prime score\n            max_score = (max_score * num) % MOD\n            k -= 1\n        \n        return max_score"}
{"code": "class Solution {\npublic:\n    const int MOD = 1e9 + 7;\n\n    int maximumScore(std::vector<int>& nums, int k) {\n        int n = nums.size();\n        std::unordered_map<int, int> primeScore; // Map to store prime scores of elements\n        int left = 0; // Left pointer of the sliding window\n        long long score = 1; // Initial score\n        int maxScore = 1; // Maximum score\n\n        for (int right = 0; right < n; ++right) {\n            // Calculate prime score for the new element\n            int curScore = calculatePrimeScore(nums[right]);\n\n            // Update prime score map\n            primeScore[nums[right]]++;\n\n            // Increment the score by multiplying it with the prime score\n            score = (score * curScore) % MOD;\n\n            // Check if the window size exceeds k, then we need to shrink the window\n            while (right - left + 1 > k) {\n                int leftElem = nums[left];\n                primeScore[leftElem]--;\n\n                // If the left element has no more occurrences in the window, remove it from the map\n                if (primeScore[leftElem] == 0) {\n                    primeScore.erase(leftElem);\n                }\n\n                // Move the left pointer to the right\n                left++;\n            }\n\n            // Update the maximum score\n            maxScore = std::max(maxScore, static_cast<int>(score));\n        }\n\n        return maxScore;\n    }\n\n    // Helper function to calculate the prime score of an integer\n    int calculatePrimeScore(int x) {\n        int score = 0;\n        for (int i = 2; i * i <= x; ++i) {\n            while (x % i == 0) {\n                x /= i;\n                score++;\n            }\n        }\n        if (x > 1) {\n            score++;\n        }\n        return score;\n    }\n};"}
{"code": "public class Solution {\n    public int findMaximumElegance(int[][] items, int k) {\n        List<int[]> itemList = new ArrayList<>();\n        Map<Integer, Integer> categoryFreq = new HashMap<>();\n        int totalProfit = 0;\n        int distinctCategories = 0;\n        int maxElegance = 0;\n\n        for (int[] item : items) {\n            itemList.add(item);\n        }\n\n        Collections.sort(itemList, (a, b) -> b[0] - a[0]); // Sort by profit in descending order\n\n        for (int i = 0; i < itemList.size(); i++) {\n            int[] item = itemList.get(i);\n            int profit = item[0];\n            int category = item[1];\n\n            categoryFreq.put(category, categoryFreq.getOrDefault(category, 0) + 1);\n            totalProfit += profit;\n\n            if (categoryFreq.get(category) == 1) {\n                distinctCategories++;\n            }\n\n            int elegance = totalProfit + distinctCategories * distinctCategories;\n            maxElegance = Math.max(maxElegance, elegance);\n\n            if (distinctCategories == k) {\n                break; // We have reached the required number of distinct categories\n            }\n        }\n\n        return maxElegance;\n    }\n}"}
{"code": "class Solution:\n    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:\n        n = len(items)\n        max_elegance = 0\n        \n        # Generate all possible combinations of items with size k\n        for combo in combinations(items, k):\n            total_profit = sum(item[0] for item in combo)\n            categories = [item[1] for item in combo]\n            distinct_categories = len(Counter(categories))\n            elegance = total_profit + distinct_categories ** 2\n            max_elegance = max(max_elegance, elegance)\n        \n        return max_elegance"}
{"code": "class Solution {\npublic:\n    long long findMaximumElegance(std::vector<std::vector<int>>& items, int k) {\n        std::unordered_map<int, std::vector<int>> categoryToProfits;\n        std::unordered_map<int, long long> categoryToTotalProfit;\n\n        for (auto& item : items) {\n            int profit = item[0];\n            int category = item[1];\n            categoryToProfits[category].push_back(profit);\n            categoryToTotalProfit[category] += profit;\n        }\n\n        std::vector<long long> maxProfits;\n        long long totalElegance = 0;\n\n        for (auto& pair : categoryToProfits) {\n            int category = pair.first;\n            std::vector<int>& profits = pair.second;\n\n            std::sort(profits.rbegin(), profits.rend());\n\n            long long categoryTotalProfit = categoryToTotalProfit[category];\n            int categoryDistinctCount = profits.size();\n\n            for (int i = 0; i < k && i < categoryDistinctCount; ++i) {\n                totalElegance += profits[i] + static_cast<long long>(categoryDistinctCount) * categoryDistinctCount;\n                maxProfits.push_back(profits[i]);\n            }\n        }\n\n        std::sort(maxProfits.rbegin(), maxProfits.rend());\n\n        for (int i = k; i < maxProfits.size(); ++i) {\n            totalElegance -= maxProfits[i];\n        }\n\n        return totalElegance;\n    }\n};"}
{"code": "class Solution {\n    public int maxSum(int[] nums) {\n        int max = 0;\n        int maxDigit = 0;\n        for(int i = 0; i < nums.length; i++){\n            int digit = 0;\n            int num = nums[i];\n            while(num > 0){\n                digit = Math.max(digit, num % 10);\n                num /= 10;\n            }\n            if(digit > maxDigit){\n                maxDigit = digit;\n                max = nums[i];\n            }\n            else if(digit == maxDigit){\n                max = Math.max(max, nums[i]);\n            }\n        }\n        \n        int maxSum = 0;\n        for(int i = 0; i < nums.length; i++){\n            int digit = 0;\n            int num = nums[i];\n            while(num > 0){\n                digit = Math.max(digit, num % 10);\n                num /= 10;\n            }\n            if(digit == maxDigit){\n                maxSum = Math.max(maxSum, nums[i]);\n            }\n        }\n        \n        if(maxSum == 0){\n            return -1;\n        }\n        \n        int sum = 0;\n        for(int i = 0; i < nums.length; i++){\n            if(nums[i] == max){\n                sum += nums[i];\n            }\n            else if(nums[i] == maxSum){\n                sum += nums[i];\n            }\n        }\n        \n        return sum;\n    }\n}"}
{"code": "class Solution:\n    def maxSum(self, nums: List[int]) -> int:\n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if max(nums[i], nums[j]) % 10 == max(nums[i] // 10, nums[j] // 10):\n                    return max(nums[i], nums[j])\n        return -1"}
{"code": "class Solution {\npublic:\n    int maxSum(vector<int>& nums) {\n       int n = nums.size();\n        int max_digit = 0;\n        for(int i = 0; i < n; i++){\n            int digit = 0;\n            int num = nums[i];\n            while(num){\n                digit = max(digit, num % 10);\n                num /= 10;\n            }\n            max_digit = max(max_digit, digit);\n        }\n        \n        int max_sum = -1;\n        for(int i = 0; i < n; i++){\n            for(int j = i + 1; j < n; j++){\n                int digit = 0;\n                int num = nums[i] + nums[j];\n                while(num){\n                    digit = max(digit, num % 10);\n                    num /= 10;\n                }\n                if(digit == max_digit){\n                    max_sum = max(max_sum, nums[i] + nums[j]);\n                }\n            }\n        }\n        \n        return max_sum;\n    }\n};"}
{"code": "class Solution {\n    public String finalString(String s) {\n        StringBuilder sb = new StringBuilder();\n        for(int i = 0; i < s.length(); i++){\n            if(s.charAt(i) == 'i'){\n                sb.reverse();\n            }\n            else{\n                sb.append(s.charAt(i));\n            }\n        }\n        return sb.toString();\n    }\n}"}
{"code": "class Solution:\n    def finalString(self, s: str) -> str:\n        res = \"\"\n        for i in s:\n            if i == \"i\":\n                res = res[::-1]\n            else:\n                res += i\n        return res"}
{"code": "class Solution {\npublic:\n    string finalString(string s) {\n        string ans;\n        for(int i = 0; i < s.length(); i++){\n            if(s[i] == 'i'){\n                reverse(ans.begin(), ans.end());\n            }\n            else{\n                ans.push_back(s[i]);\n            }\n        }\n        return ans;\n    }\n};"}
{"code": "class Solution {\n    public int minAbsoluteDifference(List<Integer> nums, int x) {\n        int min = Integer.MAX_VALUE;\n        int n = nums.size();\n        for(int i = 0; i < n; i++){\n            for(int j = i + x; j < n; j++){\n                min = Math.min(min, Math.abs(nums.get(i) - nums.get(j)));\n            }\n        }\n        return min;\n    }\n}"}
{"code": "class Solution:\n    def minAbsoluteDifference(self, nums: List[int], x: int) -> int:\n        nums.sort()\n        min_diff = float('inf')\n        for i in range(len(nums)):\n            if i + x < len(nums):\n                min_diff = min(min_diff, abs(nums[i] - nums[i + x]))\n        return min_diff"}
{"code": "class Solution {\npublic:\n    int minAbsoluteDifference(vector<int>& nums, int x) {\n        int n=nums.size();\n        int min=INT_MAX;\n        int i=0;\n        int j=0;\n        for(i=0;i<n;i++){\n            for(j=i+1;j<n;j++){\n                if(abs(nums[i]-nums[j])<min && abs(i-j)>=x){\n                    min=abs(nums[i]-nums[j]);\n                }\n            }\n        }\n        return min;\n    }\n};"}
{"code": "class Solution {\n    public ListNode doubleIt(ListNode head) {\n        ListNode temp = head;\n        ListNode prev = null;\n        while(temp!=null){\n            int val = temp.val;\n            temp.val = val*2;\n            if(temp.val>9){\n                temp.val = temp.val%10;\n                if(prev!=null){\n                    prev.val+=1;\n                }\n            }\n            prev = temp;\n            temp = temp.next;\n        }\n        return head;\n    }\n}"}
{"code": "class Solution:\n    def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if head is None:\n            return None\n        \n        head.val = head.val * 2\n        \n        if head.next is None:\n            return head\n        \n        head.next = self.doubleIt(head.next)\n        \n        if head.val > 9:\n            head.val = head.val - 10\n            head.next.val = head.next.val + 1\n            \n        return head"}
{"code": "class Solution {\npublic:\n    ListNode* doubleIt(ListNode* head) {\n        ListNode* temp = head;\n         ListNode* temp2 = head;\n         while(temp->next!=NULL){\n             temp2 = temp2->next;\n             temp = temp->next;\n         }\n         temp2->next = head;\n         temp = temp2;\n         while(temp->next!=NULL){\n             temp->val = temp->val*2;\n             if(temp->val>9){\n                 temp->val = temp->val%10;\n                 temp->next->val = temp->next->val+1;\n             }\n             temp = temp->next;\n         }\n         if(temp->val>9){\n             temp->val = temp->val%10;\n             temp->next = new ListNode(1);\n         }\n         return head;\n    }\n};"}
{"code": "class Solution {\n    public int maximumScore(List<Integer> nums, int k) {\n        int n = nums.size();\n        int[][] dp = new int[n][k + 1];\n        for(int i = 0; i < n; i++)\n            Arrays.fill(dp[i], -1);\n        return dfs(nums, 0, k, dp);\n    }\n    public int dfs(List<Integer> nums, int i, int k, int[][] dp){\n        if(i == nums.size())\n            return 1;\n        if(k == 0)\n            return 0;\n        if(dp[i][k] != -1)\n            return dp[i][k];\n        int ans = 0;\n        for(int j = i; j < nums.size(); j++){\n            ans = Math.max(ans, nums.get(j) * dfs(nums, j + 1, k - 1, dp));\n        }\n        return dp[i][k] = ans;\n    }\n}"}
{"code": "class Solution:\n    def maximumScore(self, nums: List[int], k: int) -> int:\n        def prime_score(num):\n            prime_factors = set()\n            while num > 1:\n                for i in range(2, num + 1):\n                    if num % i == 0:\n                        prime_factors.add(i)\n                        num //= i\n                        break\n            return len(prime_factors)\n        \n        n = len(nums)\n        dp = [[0] * n for _ in range(k + 1)]\n        dp[0][0] = 1\n        for i in range(1, k + 1):\n            for j in range(1, n):\n                for k in range(j):\n                    if prime_score(nums[k]) > prime_score(nums[j]):\n                        dp[i][j] = max(dp[i][j], dp[i - 1][k] * nums[j])\n                    else:\n                        dp[i][j] = max(dp[i][j], dp[i][k] * nums[j])\n        return dp[k][n - 1] % (10 ** 9 + 7)"}
{"code": "class Solution {\npublic:\n    int maximumScore(vector<int>& nums, int k) { \n       int n = nums.size();\n        vector<int> primes;\n        for(int i = 2; i <= n; i++){\n            bool isPrime = true;\n            for(int j = 2; j <= sqrt(i); j++){\n                if(i % j == 0){\n                    isPrime = false;\n                    break;\n                }\n            }\n            if(isPrime){\n                primes.push_back(i);\n            }\n        }\n        vector<int> dp(n + 1, 0);\n        dp[0] = 1;\n        for(int i = 1; i <= n; i++){\n            for(int j = 0; j < primes.size(); j++){\n                if(primes[j] <= nums[i - 1]){\n                    dp[i] = (dp[i] + dp[i - 1]) % MOD;\n                }\n            }\n        }\n        int ans = 0;\n        for(int i = 0; i <= n; i++){\n            for(int j = 0; j <= n; j++){\n                if(i + j <= n){\n                    ans = (ans + dp[i] * dp[n - i - j] % MOD) % MOD;\n                }\n            }\n        }\n        return ans;\n    }\n    \n    int MOD = 1e9 + 7;\n};"}
{"code": "class Solution {\n    public long findMaximumElegance(int[][] items, int k) {\n        int n = items.length;\n        long[][] dp = new long[n + 1][k + 1];\n        for (int i = 1; i <= n; i++) {\n            int profit = items[i - 1][0];\n            int category = items[i - 1][1];\n            for (int j = 1; j <= k; j++) {\n                dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - 1] + profit);\n                if (category != items[i - 1][1]) {\n                    dp[i][j] = Math.max(dp[i][j], dp[i - 1][j] + profit);\n                }\n            }\n        }\n        long max = 0;\n        for (int i = 1; i <= k; i++) {\n            max = Math.max(max, dp[n][i]);\n        }\n        return max;\n    }\n}"}
{"code": "class Solution:\n    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:\n        n = len(items)\n        profit = [0] * n\n        category = [0] * n\n        for i in range(n):\n            profit[i] = items[i][0]\n            category[i] = items[i][1]\n        profit.sort(reverse=True)\n        category.sort(reverse=True)\n        profit = profit[:k]\n        category = category[:k]\n        \n        profit_set = set(profit)\n        category_set = set(category)\n        \n        profit_sum = sum(profit)\n        category_sum = sum(category)\n        \n        return profit_sum + category_sum ** 2"}
{"code": "class Solution {\npublic:\n    long long findMaximumElegance(vector<vector<int>>& items, int k) {\n        int n = items.size();\n        vector<int> profit(n);\n        vector<int> category(n);\n        \n        for(int i = 0; i < n; i++){\n            profit[i] = items[i][0];\n            category[i] = items[i][1];\n        }\n        \n        sort(profit.begin(), profit.end());\n        sort(category.begin(), category.end());\n        \n        int max_elegance = 0;\n        \n        for(int i = 0; i < n; i++){\n            int j = i + k - 1;\n            if(j >= n) break;\n            \n            int total_profit = profit[j] - profit[i];\n            int distinct_categories = upper_bound(category.begin(), category.end(), category[j]) - upper_bound(category.begin(), category.end(), category[i]);\n            \n            max_elegance = max(max_elegance, total_profit + distinct_categories * distinct_categories);\n        }\n        \n        return max_elegance;\n    }\n};"}
{"code": "public class Solution{\n    public int maxSum(int[] nums) {\n        int max = -1;\n        for(int i = 0; i < nums.length; i++) {\n            for(int j = i + 1; j < nums.length;\n                    j++) {\n                if(nums[i] % 10 == nums[j] % 10) {\n                    max = Math.max(max, nums[i] + nums[j]);\n                }\n            }\n            \n        }\n        return max;\n        \n    }\n    \n}"}
{"code": "class Solution:\n    def maxSum(self, nums: List[int]) -> int:\n        nums.sort(reverse=True)\n        for i in range(len(nums)-1):\n            if nums[i]%10==nums[i+1]%10:\n                return nums[i]+nums[i+1]\n        return -1"}
{"code": "class Solution {\npublic:\n    int maxSum(vector<int>& nums) {\n        int ans = -1;\n        int n = nums.size();\n        for(int i = 0; i < n; i++){\n            for(int j = i + 1; j < n; j++){\n                if(nums[i] % 10 == nums[j] % 10){\n                    ans = max(ans, nums[i] + nums[j]);\n                    break;\n                }\n            }\n        }\n        return ans;\n    }\n};"}
{"code": "public class Solution {\n    public String finalString(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            if (c == 'i') {\n                sb.append(s.substring(i));\n                break;\n            }\n            sb.append(c);\n        }\n        return sb.toString();\n        \n    }\n    \n}"}
{"code": "class Solution:\n    def finalString(self, s: str) -> str:\n        ans = \"\"\n        for i in range(len(s)):\n            if s[i] == 'i':\n                ans = ans[:-1]\n            else:\n                ans += s[i]\n        return ans"}
{"code": "class Solution {\npublic:\n    string finalString(string s) {\n        string ans=\"\";\n        for(int i=0;i<s.length();i++){\n            if(s[i]=='i'){\n                reverse(ans.begin(),ans.end());\n                ans=\"\";\n                continue;\n            }\n            ans+=s[i];\n        }\n        return ans;\n    }\n};"}
{"code": "class Solution {\n    public int minAbsoluteDifference(List<Integer> nums, int x) {\n        int min = Integer.MAX_VALUE;\n        int n = nums.size();\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                if (Math.abs(i - j) >= x) {\n                    min = Math.min(min, Math.abs(nums.get(i) - nums.get(j)));\n                }\n            }\n        }\n        return min;\n        \n    }\n    \n}"}
{"code": "class Solution:\n    def minAbsoluteDifference(self, nums: List[int], x: int) -> int:\n        nums.sort()\n        ans = float('inf')\n        for i in range(len(nums)):\n            j = bisect_left(nums, nums[i] + x)\n            if j < len(nums):\n                ans = min(ans, nums[j] - nums[i])\n            if i + 1 < len(nums):\n                ans = min(ans, nums[i + 1] - nums[i])\n        return ans"}
{"code": "class Solution {\npublic:\n    int minAbsoluteDifference(vector<int>& nums, int x) {\n        int n = nums.size();\n        int ans = INT_MAX;\n        for(int i = 0; i < n; i++){\n            for(int j = i + 1; j < n; j++){\n                if(abs(nums[i] - nums[j]) >= x){\n                    ans = min(ans, abs(nums[i] - nums[j]));\n                    break;\n                }\n            }\n        }\n        return ans;\n    }\n};"}
{"code": "class Solution {\n    public ListNode doubleIt(ListNode head) {\n        ListNode curr = head;\n        while (curr != null) {\n            curr.val *= 2;\n            curr = curr.next;\n        }\n        return head;\n        \n    }\n    \n}"}
{"code": "class Solution:\n    def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head:\n            return head\n        if not head.next:\n            head.val *= 2\n            return head\n        prev = head\n        curr = head.next\n        while curr:\n            curr.val *= 2\n            prev = curr\n            curr = curr.next\n        prev.val *= 2\n        return head"}
{"code": "class Solution {\npublic:\n    ListNode* doubleIt(ListNode* head) {\n        if(head == NULL)\n            return NULL;\n        ListNode* temp = head;\n        while(temp->next != NULL){\n            temp->val *= 2;\n            temp = temp->next;\n            if(temp->next != NULL) {\n                temp->val *= 2;\n                temp = temp->next;\n                continue;\n            }\n            else {\n                break;\n            }\n        }\n        return head;\n    }\n};"}
{"code": "public class Solution {\n    public int maximumScore(List<Integer> nums, int k) {\n        int n = nums.size();\n        int[] primes = new int[n];\n        for (int i = 0; i < n; i++) {\n            primes[i] = primeFactors(nums.get(i));\n            if (primes[i] == 0) primes[i] = 1;\n            //System.out.println(primes[i]);\n        }\n        int[][] dp = new int[n][k + 1];\n        for (int i = 0; i < n; i++) {\n            dp[i][0] = 1;\n        }\n        for (int i = 1; i <= k; i++) {\n            for (int j = 0; j < n; j++) {\n                dp[j][i] = Math.max(dp[j][i - 1], dp[j - 1][i - 1] * primes[j]);\n            }\n        }\n        return dp[n - 1][k];\n        \n    }\n    \n    public int primeFactors(int n) {\n        int count = 0;\n        for (int i = 2; i <= n / i; i++) {\n            while (n % i == 0) {\n                n /= i;\n                count++;\n            }\n        }\n        if (n > 1) count++;\n        return count;\n    }\n    \n}"}
{"code": "class Solution:\n    def maximumScore(self, nums: List[int], k: int) -> int:\n        def prime(n):\n            if n == 1:\n                return False\n            for i in range(2, int(n**0.5)+1):\n                if n % i == 0:\n                    return False\n            return True\n        ans = 1\n        for i in range(k, -1, -1):\n            if prime(nums[i]):\n                ans *= nums[i]\n        for i in range(k+1, len(nums)):\n            if prime(nums[i]):\n                ans *= nums[i]\n        return ans % (10**9 + 7)"}
{"code": "class Solution {\npublic:\n    int maximumScore(vector<int>& nums, int k) {\n        int n = nums.size();\n        int l = k, r = k;\n        int score = 1;\n        int ans = 0;\n        while(l >= 0 || r < n){\n            if(l < 0){\n                score *= nums[r++];\n                ans = max(ans, score);\n                continue;\n            }\n            if(r == n){\n                score *= nums[l--];\n                ans = max(ans, score);\n                continue;\n            }\n            if(nums[l] < nums[r]){\n                score *= nums[l--];\n                ans = max(ans, score);\n            }\n            else{\n                score *= nums[r++];\n                ans = max(ans, score);\n            }\n        }\n        return ans;\n    }\n};"}
{"code": "public class Solution {\n    public int findMaximumElegance(int[][] items, int k) {\n        int n = items.length;\n        int[] category = new int[n];\n        for (int i = 0; i < n; i++) {\n            category[i] = items[i][1];\n        }\n        int[] count = new int[n + 1];\n        for (int i = 0; i < n; i++) {\n            count[category[i]]++;\n        }\n        for (int i = 1; i <= n; i++) {\n            count[i] += count[i - 1];\n        }\n        int[] dp = new int[n + 1];\n        for (int i = 0; i < n; i++) {\n            int index = count[category[i]];\n            dp[index] = Math.max(dp[index], dp[index - 1] + items[i][0]);\n        }\n        return dp[n];\n        \n    }\n\n}"}
{"code": "class Solution:\n    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:\n        items.sort(key = lambda x: x[1])\n        ans = 0\n        for i in range(k):\n            ans += items[i][0]\n        return ans + (k * (k - 1) // 2) * items[k - 1][1]"}
{"code": "class Solution {\npublic:\n    long long findMaximumElegance(vector<vector<int>>& items, int k) {\n        int n=items.size();\n        vector<long long>profit(n);\n        vector<long long>category(n);\n        for(int i=0;i<n;i++){\n            profit[i]=items[i][0];\n            category[i]=items[i][1];\n        }\n        sort(profit.begin(),profit.end());\n        sort(category.begin(),category.end());\n        long long ans=0;\n        long long max_profit=0;\n        long long max_category=0;\n        for(int i=0;i<n;i++){\n            if(i<k){\n                max_profit+=profit[i];\n                max_category+=category[i];\n                ans=max(ans,max_profit+max_category*max_category);\n                continue;\n            }\n            max_profit-=profit[i-k];\n            max_profit+=profit[i];\n            max_category-=category[i-k];\n            max_category+=category[i];\n            ans=max(ans,max_profit+max_category*max_category);\n        }\n        return ans;\n    }\n};"}
{"code": "public class Solution {\n    public int maxSum(int[] nums) {\n        int max = -1;\n        for(int i = 0; i < nums.length; i++){\n            for(int j = i+1; j < nums.length;j++){\n                if(max < nums[i] + nums[j] && maxDigit(nums[i]) == maxDigit(nums[j])){\n                    max = nums[i] + nums[j];\n                }\n            }\n        }\n        return max;\n    }\n    public int maxDigit(int num){\n        int max = 0;\n        while(num > 0){\n            max = Math.max(max, num % 10);\n            num /= 10;\n        }\n        return max;\n    }\n}"}
{"code": "class Solution:\n    def maxSum(self, nums: List[int]) -> int:\n        maxSum = -1\n        maxDigit = [0] * 10\n        for num in nums:\n            maxDigit[int(str(num)[0])] = max(maxDigit[int(str(num)[0])], num)\n        for i in range(10):\n            \n            for j in range(i, 10):\n                if maxDigit[i] and maxDigit[j]:\n                    maxSum = max(maxSum, maxDigit[i] + maxDigit[j])\n        return maxSum"}
{"code": "class Solution {\npublic:\n    int maxSum(vector<int>& nums) {\n        int n = nums.size();\n        int maxSum = -1;\n        unordered_map<int, int> mp;\n        for(int i = 0; i < n; i++) {\n            int maxDigit = 0;\n            int temp = nums[i];\n            while(temp) {\n                maxDigit = max(maxDigit, temp % 10);\n                temp /= 10;\n            }\n            if(mp.find(maxDigit) != mp.end()) {\n                maxSum = max(maxSum, mp[maxDigit] + nums[i]);\n                mp[maxDigit] = max(mp[maxDigit], nums[i]);\n            } else {\n                mp[maxDigit] = nums[i];\n            }\n        }\n        return maxSum;\n    }\n};"}
{"code": "public class Solution {\n    public String finalString(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == 'i') {\n                sb.reverse();\n            } else {\n                sb.append(s.charAt(i));\n            }\n        }\n        return sb.toString();\n    }\n}"}
{"code": "class Solution:\n    def finalString(self, s: str) -> str:\n        stack = []\n        for i in range(len(s)):\n            if s[i] == 'i':\n                stack.reverse()\n            else:\n                stack.append(s[i])\n        return \"\".join(stack)"}
{"code": "class Solution {\npublic:\n    string finalString(string s) {\n        string ans = \"\";\n        int n = s.length();\n        int i = 0;\n        while(i < n) {\n            if(s[i] == 'i') {\n                reverse(ans.begin(), ans.end());\n            } else {\n                ans += s[i];\n            }\n            i++;\n        }\n        return ans;\n    }\n};"}
{"code": "class Solution {\n    public int minAbsoluteDifference(List<Integer> nums, int x) {\n        int min = Integer.MAX_VALUE;\n        int n = nums.size();\n        for(int i = 0; i < n; i++){\n            for(int j = i + x; j < n; j++){\n                min = Math.min(min, Math.abs(nums.get(i) - nums.get(j)));\n            }\n        }\n        return min;\n    }\n}"}
{"code": "class Solution:\n    def minAbsoluteDifference(self, nums: List[int], x: int) -> int:\n        nums.sort()\n        n = len(nums)\n        res = float('inf')\n        for i in range(n):\n            j = bisect_left(nums, nums[i] - x, i + 1)\n            if j < n:\n                res = min(res, abs(nums[i] - nums[j] + x))\n            if j > i + 1:\n                res = min(res, abs(nums[i] - nums[j - 1] + x))\n        return res"}
{"code": "class Solution {\npublic:\n    int minAbsoluteDifference(vector<int>& nums, int x) {\n        int n = nums.size();\n        int ans = INT_MAX;\n        for(int i = 0; i < n; i++){\n            for(int j = i + x; j < n; j++){\n                ans = min(ans, abs(nums[i] - nums[j]));\n            }\n        }\n        return ans;\n    }\n};"}
{"code": "class Solution {\n    public ListNode doubleIt(ListNode head) {\n        ListNode curr = head;\n        ListNode prev = null;\n        while(curr != null) {\n            ListNode next = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = next;\n        }\n        \n        ListNode newHead = prev;\n        ListNode newCurr = newHead;\n        ListNode carry = null;\n        while(newCurr != null) {\n            int sum = newCurr.val * 2;\n            if(carry != null) {\n                sum += carry.val;\n                carry = null;\n            }\n            if(sum > 9) {\n                carry = new ListNode(sum / 10);\n                sum = sum % 10;\n            }\n            newCurr.val = sum;\n            newCurr = newCurr.next;\n        }\n        if(carry != null) {\n            newCurr = newHead;\n            while(newCurr.next != null) {\n                newCurr = newCurr.next;\n            }\n            newCurr.next = carry;\n        }\n        return reverse(newHead);\n    }\n    \n    public ListNode reverse(ListNode head) {\n        ListNode curr = head;\n        ListNode prev = null;\n        while(curr != null) {\n            ListNode next = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = next;\n        }\n        \n        return prev;\n    }\n}"}
{"code": "class Solution:\n    def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if head is None:\n            return None\n        if head.next is None:\n            head.val = head.val * 2\n            return head\n        node = head\n        while node:\n            node.val = node.val * 2\n            node = node.next\n        node = head\n        while node:\n            if node.val > 9:\n                node.val = node.val % 10\n                if node.next is None:\n                    node.next = ListNode(1)\n                else:\n                    node.next.val += 1\n            node = node.next\n        return head"}
{"code": "class Solution {\npublic:\n    ListNode* doubleIt(ListNode* head) {\n        ListNode* temp = head;\n        ListNode* prev = NULL;\n        while(temp != NULL) {\n            temp->val *= 2;\n            if(temp->val > 9) {\n                if(prev == NULL) {\n                    ListNode* newHead = new ListNode(1);\n                    newHead->next = head;\n                    head = newHead;\n                    temp->val -= 10;\n                } else {\n                    prev->val += 1;\n                    temp->val -= 10;\n                }\n            }\n            prev = temp;\n            temp = temp->next;\n        }\n        return head;\n    }\n};"}
{"code": "public class Solution {\n    public int maximumScore(List<Integer> nums, int k) {\n        int n = nums.size();\n        int[] left = new int[n];\n        int[] right = new int[n];\n        Stack<Integer> stack = new Stack<>();\n        for (int i = 0; i < n; i++) {\n            while (!stack.isEmpty() && nums.get(stack.peek()) >= nums.get(i)) {\n                stack.pop();\n            }\n            left[i] = stack.isEmpty() ? -1 : stack.peek();\n            stack.push(i);\n        }\n        stack.clear();\n        for (int i = n - 1; i >= 0; i--) {\n            while (!stack.isEmpty() && nums.get(stack.peek()) >= nums.get(i)) {\n                stack.pop();\n            }\n            right[i] = stack.isEmpty() ? n : stack.peek();\n            stack.push(i);\n        }\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            if (left[i] < k && right[i] > k) {\n                ans = Math.max(ans, nums.get(i) * (right[i] - left[i] - 1));\n            }\n        }\n        return ans;\n    }\n}"}
{"code": "class Solution:\n    def maximumScore(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        left, right = k, k\n        res = nums[k]\n        min_val = nums[k]\n        while left > 0 or right < n - 1:\n            if left == 0:\n                right += 1\n            elif right == n - 1:\n                left -= 1\n            elif nums[left - 1] < nums[right + 1]:\n                right += 1\n            else:\n                left -= 1\n            min_val = min(min_val, nums[left], nums[right])\n            res = max(res, min_val * (right - left + 1))\n        return res"}
{"code": "class Solution {\npublic:\n    int maximumScore(vector<int>& nums, int k) {\n        int n = nums.size();\n        vector<int> left(n, -1), right(n, n);\n        stack<int> st;\n        for(int i = 0; i < n; i++) {\n            while(!st.empty() && nums[st.top()] >= nums[i]) {\n                st.pop();\n            }\n            if(!st.empty()) {\n                left[i] = st.top();\n            }\n            st.push(i);\n        }\n        while(!st.empty()) {\n            st.pop();\n        }\n        for(int i = n - 1; i >= 0; i--) {\n            while(!st.empty() && nums[st.top()] >= nums[i]) {\n                st.pop();\n            }\n            if(!st.empty()) {\n                right[i] = st.top();\n            }\n            st.push(i);\n        }\n        vector<int> primes(100001, 0);\n        for(int i = 2; i <= 100000; i++) {\n            if(primes[i] == 0) {\n                for(int j = i; j <= 100000; j += i) {\n                    primes[j]++;\n                }\n            }\n        }\n        vector<int> dp(n, 0);\n        for(int i = 0; i < n; i++) {\n            dp[i] = nums[i] * (primes[nums[i]] + 1);\n        }\n        for(int i = 1; i < n; i++) {\n            dp[i] = max(dp[i], dp[i - 1]);\n        }\n        int ans = 0;\n        for(int i = 0; i < n; i++) {\n            int l = left[i] + 1, r = right[i] - 1;\n            if(l <= k && k <= r) {\n                ans = max(ans, nums[i] * dp[r]);\n            }\n            if(l <= k - 1 && k - 1 <= r) {\n                ans = max(ans, nums[i] * dp[r]);\n            }\n            if(l <= k && k <= r + 1) {\n                ans = max(ans, nums[i] * dp[r]);\n            }\n            if(l <= k - 1 && k - 1 <= r + 1) {\n                ans = max(ans, nums[i] * dp[r]);\n            }\n        }\n        return ans;\n    }\n};"}
{"code": "public class Solution {\n    public int findMaximumElegance(int[][] items, int k) {\n        int n = items.length;\n        int[] dp = new int[n];\n        Arrays.sort(items, (a, b) -> a[0] - b[0]);\n        int max = 0;\n        for (int i = 0; i < n; i++) {\n            int profit = items[i][0];\n            int category = items[i][1];\n            dp[i] = profit + category * category;\n            for (int j = 0; j < i; j++) {\n                if (items[j][1] != category) {\n                    dp[i] = Math.max(dp[i], dp[j] + profit + category * category);\n                }\n            }\n            if (i >= k - 1) {\n                max = Math.max(max, dp[i]);\n            }\n        }\n        return max;\n    }\n}"}
{"code": "class Solution:\n    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:\n        items.sort(key = lambda x: x[0], reverse = True)\n        category = {}\n        for i in range(len(items)):\n            if items[i][1] not in category:\n                category[items[i][1]] = 1\n            else:\n                category[items[i][1]] += 1\n        category = sorted(category.items(), key = lambda x: x[1], reverse = True)\n        ans = 0\n        for i in range(k):\n            ans += items[i][0]\n        ans += len(category) ** 2\n        return ans"}
{"code": "class Solution {\npublic:\n    long long findMaximumElegance(vector<vector<int>>& items, int k) {\n        int n = items.size();\n        vector<pair<int,int>> v;\n        for(int i=0;i<n;i++){\n            v.push_back({items[i][0],items[i][1]});\n        }\n        sort(v.begin(),v.end(),greater<pair<int,int>>());\n        int i=0;\n        long long ans = 0;\n        unordered_map<int,int> mp;\n        while(i<n && k>0){\n            if(mp[v[i].second]==0){\n                ans += v[i].first;\n                mp[v[i].second]++;\n                k--;\n            }\n            i++;\n        }\n        return ans + (k*k);\n    }\n};"}
{"code": "class Solution {    \n    public int maxSum(int[] nums) {\n        int max = Integer.MIN_VALUE;\n        int sum = 0;\n        for (int i = 0; i < nums.length; i++) {\n            sum += nums[i];\n            if (nums[i] > max) {\n                max = nums[i];\n            }\n            if (max > 0 && nums[i] % max == 0) {\n                sum -= nums[i];\n            }\n        }\n        return sum;\n    }\n}"}
{"code": "class Solution:    \n    def maxSum (self, nums: List[int]) -> int:\n        \n        nums.sort()\n        \n        max_sum = 0\n        \n        for i in range(len(nums)-1):\n            if nums[i] == nums[i+1]:\n                max_sum = max(max_sum, nums[i]*(len(nums)-i-1))\n                \n        return max_sum"}
{"code": "class Solution {\npublic:    int maxSum(vector<int>& nums) {\n        int n = nums.size();\n        int max_sum = -1;\n        unordered_map<int, int> mp;\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                int sum = nums[i] + nums[j];\n                int max_digit = 0;\n                for (int k = 0; k < 10; k++) {\n                    if (sum % 10 == k) {\n                        max_digit = max(max_digit, k);\n                    }\n                    sum /= 10;\n                }\n                if (mp.find(max_digit)!= mp.end()) {\n                    max_sum = max(max_sum, sum + mp[max_digit]);\n                }\n                mp[max_digit] = sum;\n            }\n        }\n        return max_sum;\n    }\n};"}
{"code": "public class Solution {    \n    public String finalString(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            if (c == 'i') {\n                sb.append(c);\n            } else {\n                sb.append(c);\n                sb.append(c);\n            }\n        }\n        return sb.toString();\n    }\n}"}
{"code": "class Solution:\n    def finalString(self, s: str) -> str:\n        res = \"\"\n        for i in s:\n            if i!= 'i':\n                res += i\n            else:\n                res = res[::-1]\n        return res"}
{"code": "class Solution {\npublic:    \n    string finalString(string s) {\n        string res = \"\";\n        for (int i = 0; i < s.length(); i++) {\n            res += s[s.length() - i - 1];\n        }\n        return res;\n    }\n};"}
{"code": "class Solution {\n    int minAbsoluteDifference(List<Integer> nums, int x) {\n        int min = Integer.MAX_VALUE;\n        int max = Integer.MIN_VALUE;\n        for (int i = 0; i < nums.size(); i++) {\n            if (nums.get(i) < min) {\n                min = nums.get(i);\n            }\n            if (nums.get(i) > max) {\n                max = nums.get(i);\n            }\n        }\n        int diff = Integer.MAX_VALUE;\n        for (int i = 0; i < nums.size(); i++) {\n            if (Math.abs(nums.get(i) - min) >= x) {\n                diff = Math.min(diff, Math.abs(nums.get(i) - min));\n            }\n            if (Math.abs(nums.get(i) - max) >= x) {\n                diff = Math.min(diff, Math.abs(nums.get(i) - max));\n            }\n        }\n        return diff;\n    }\n}"}
{"code": "class Solution:\n    def minAbsoluteDifference(self, nums: List[int], x: int) -> int:\n        nums.sort()\n        res = float('inf')\n        for i in range(len(nums)-1):\n            res = min(res, abs(nums[i]-nums[i+1]))\n        return res"}
{"code": "class Solution {\npublic:    \n    int minAbsoluteDifference(vector<int>& nums, int x) {\n        int min = INT_MAX;\n        int n = nums.size();\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                if (abs(nums[i] - nums[j]) >= x)\n                    continue;\n                min = min < abs(nums[i] - nums[j])? abs(nums[i] - nums[j]) : min;\n            }\n        }\n        return min;\n    }\n};"}
{"code": "class Solution {\n    public ListNode doubleIt(ListNode head) {\n        ListNode curr = head;\n        int currVal = 0;\n        while (curr!= null) {\n            currVal += curr.val;\n            curr.val = currVal;\n            curr = curr.next;\n        }\n        curr = head;\n        while (curr!= null) {\n            curr.val = curr.val * 2;\n            curr = curr.next;\n        }\n        return head;\n    }\n}"}
{"code": "class Solution:\n    def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head:\n            return head\n        \n        curr = head\n        while curr:\n            curr.val *= 2\n            curr = curr.next\n        return head"}
{"code": "class Solution {\npublic:    \n    ListNode* doubleIt(ListNode* head) {\n        if(head == NULL) return NULL;\n        ListNode* cur = head;\n        ListNode* pre = NULL;\n        ListNode* next = NULL;\n        while(cur!= NULL) {\n            next = cur->next;\n            cur->next = pre;\n            pre = cur;\n            cur = next;\n        }\n        cur = pre;\n        while(cur!= NULL) {\n            cur->val *= 2;\n            cur = cur->next;\n        }\n        return pre;\n    }\n};"}
{"code": "class Solution {    public int maximumScore(List<Integer> nums, int k) {\n        int n = nums.size();\n        int[] primes = new int[n];\n        int[] scores = new int[n];\n        Arrays.fill(primes, -1);\n        Arrays.fill(scores, 1);\n        \n        for (int i = 0; i < n; i++) {\n            primes[i] = getPrime(nums.get(i));\n        }\n        \n        int maxScore = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                int l = Math.max(i, primes[i] - 1);\n                int r = Math.min(j, primes[j] - 1);\n                int score = (r - l + 1) * scores[j];\n                if (score > maxScore) {\n                    maxScore = score;\n                }\n            }\n        }\n        \n        return (int) (maxScore % (1e9 + 7));\n    }\n    \n    private int getPrime(int num) {\n        int res = num;\n        for (int i = 2; i * i <= num; i++) {\n            if (num % i == 0) {\n                res = i;\n                break;\n            }\n        }\n        return res;\n    }\n}"}
{"code": "class Solution:    \n    def maximumScore(self, nums: List[int], k: int) -> int:\n        \n        n = len(nums)\n        \n        @lru_cache(None)\n        def dp(l, r, k):\n            if k == 0:\n                return 0\n            if l > r:\n                return 0\n            if l == r:\n                return nums[l]\n            \n            res = 0\n            for i in range(l, r + 1):\n                if i == l:\n                    res = max(res, dp(l + 1, r, k - 1))\n                elif i == r:\n                    res = max(res, dp(l, r - 1, k - 1))\n                else:\n                    res = max(res, dp(l + 1, r, k - 1) + nums[i] * nums[i])\n                    res = max(res, dp(l, r - 1, k - 1) + nums[i] * nums[i])\n            return res % (10**9 + 7)\n        \n        return dp(0, n - 1, k)"}
{"code": "class Solution {\npublic:    \n    int getPrimeScore(int num) {\n        int count = 0;\n        for (int i = 2; i * i <= num; i++) {\n            while (num % i == 0) {\n                num /= i;\n                count++;\n            }\n        }\n        return count;\n    }\n\n    int getMaxPrimeScore(vector<int>& nums, int l, int r) {\n        int maxPrimeScore = 0;\n        for (int i = l; i <= r; i++) {\n            maxPrimeScore = max(maxPrimeScore, getPrimeScore(nums[i]));\n        }\n        return maxPrimeScore;\n    }\n\n    int getMaxScore(vector<int>& nums, int l, int r) {\n        int maxScore = 0;\n        for (int i = l; i <= r; i++) {\n            maxScore = max(maxScore, nums[i]);\n        }\n        return maxScore;\n    }\n\n    int maximumScore(vector<int>& nums, int k) {\n        int score = 1;\n        int maxScore = 0;\n\n        int l = 0;\n        int r = nums.size() - 1;\n        \n        for (int i = 0; i < k; i++) {\n            int temp = getMaxScore(nums, l, r);\n            maxScore = max(maxScore, temp);\n            int tempPrimeScore = getMaxPrimeScore(nums, l, r);\n            int tempScore = temp * tempPrimeScore;\n            l = l + 1;\n            r = r - 1;\n        }\n        \n        return maxScore;\n    }\n};"}
{"code": "class Solution {    \n    public long findMaximumElegance(int[][] items, int k) {\n        int n = items.length;\n        int[][] dp = new int[n + 1][k + 1];\n        for (int i = 0; i <= n; i++) {\n            for (int j = 0; j <= k; j++) {\n                if (i == 0) {\n                    dp[i][j] = 0;\n                } else if (j == 0) {\n                    dp[i][j] = 0;\n                } else if (j == 1) {\n                    dp[i][j] = items[i - 1][0];\n                } else {\n                    dp[i][j] = Math.max(dp[i - 1][j], items[i - 1][0] + dp[i - 1][j - 1]);\n                }\n            }\n        }\n        return dp[n][k];\n    }\n}"}
{"code": "class Solution:    \n    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:\n        \n        @lru_cache(None)\n        def dp(i, k):\n            if k == 0:\n                return 0\n            if i == len(items):\n                return float('-inf')\n            return max(dp(i + 1, k), items[i][0] + dp(i + 1, k - 1))\n        \n        return dp(0, k)"}
{"code": "class Solution {\npublic:    long long findMaximumElegance(vector<vector<int>>& items, int k) {\n        int n = items.size();\n        vector<vector<int>> dp(n, vector<int>(2, 0));\n        dp[0][0] = items[0][0];\n        dp[0][1] = 1;\n        for (int i = 1; i < n; i++) {\n            dp[i][0] = max(dp[i - 1][0], items[i][0]);\n            dp[i][1] = dp[i - 1][1] + 1;\n        }\n        long long res = 0;\n        for (int i = 0; i < n - k + 1; i++) {\n            res = max(res, static_cast<long long>(dp[i][0] + dp[i + k - 1][0] + dp[i][1] * dp[i + k - 1][1]));\n        }\n        return res;\n    }\n};"}
{"code": "public class Solution{\n    public int maxSum(int[] nums){\n        int maxSum = Integer.MIN_VALUE;\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[i] % 10 == nums[j] % 10) {\n                    maxSum = Math.max(maxSum, nums[i] + nums[j]);\n                }\n            }\n        }\n        return maxSum == Integer.MIN_VALUE? -1 : maxSum; \n    }\n    \n}"}
{"code": "class Solution:\n    def maxSum(self, nums: List[int]) -> int:\n        if len(nums) == 1:\n            return nums[0]\n        if len(nums) == 2:\n            return max(nums)\n        max_sum = 0\n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if nums[i] % 10 == nums[j] % 10:\n                    max_sum = max(max_sum, nums[i] + nums[j])\n        return max_sum if max_sum > 0 else -1"}
{"code": "class Solution {\npublic:\n    int maxSum(vector<int>& nums) {\n    int n=nums.size();\n    int maxi=0;\n    int maxj=0;\n    int maxsum=0;\n    for(int i=0;i<n;i++){\n        for(int j=i+1;j<n;j++){\n            if(nums[i]>maxi){\n                maxi=nums[i];\n            }\n            if(nums[j]>maxj){\n                maxj=nums[j];\n            }\n            if(maxi==maxj){\n                maxsum=max(maxsum,maxi+maxj);\n            }\n        }\n    }\n    if(maxsum==0){\n        return -1;\n    }\n    return maxsum;\n    }\n};"}
{"code": "public class Solution {\n    public String finalString(String s) {\n        String result = \"\";\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            if (c == 'i') {\n                result = new StringBuilder(result).reverse().toString();\n            } else {\n                result += c;\n            }\n        }\n        return result;\n    }\n}"}
{"code": "class Solution:\n    def finalString(self, s: str) -> str:\n        s = list(s)\n        for i in range(len(s)):\n            if s[i] == 'i':\n                s[i] = 'o'\n            else:\n                s[i] = 'i'\n        return ''.join(s)"}
{"code": "class Solution {\npublic:\n    string finalString(string s) {\n    int n=s.length();\n    string ans=\"\";\n    for(int i=0;i<n;i++){\n        if(s[i]=='i'){\n            ans=ans.substr(0,ans.length()-1);\n        }\n        else{\n            ans+=s[i];\n        }\n    }\n    return ans;\n    }\n};"}
{"code": "class Solution {\n    public int minAbsoluteDifference(List<Integer> nums, int x) {\n        int n = nums.size();\n        int[] arr  = new int[n];\n        for(int i = 0; i < n; i++) {\n            arr[i] = nums.get(i);\n        }\n        Arrays.sort(arr);\n        int res = Integer.MAX_VALUE;\n        for(int i =  0; i < n; i++) {\n            int left = i + 1;\n            int right = n - 1;\n            while(left <= right) {\n                int mid = left + (right - left) / 2;\n                if(arr[mid] - arr[  i] >= x) {\n                    right = mid - 1;\n                } else {\n                    left = mid + 1;\n                }\n            }\n            if(left < n) {\n                res = Math.min(res, arr[left] - arr[i]);\n            }\n            left  = 0;\n            right = i - 1;\n            while(left <= right) {\n                int mid = left + (right - left) / 2;\n                if(arr[i] - arr[mid] >= x) {\n                    left = mid + 1;\n                 } else {\n                    right = mid - 1;\n                }\n            }\n            if(right >= 0) {\n                res = Math.min(res, arr[i] - arr[right]);\n            }\n        }\n        return res;\n    }\n} "}
{"code": "class Solution:\n    def minAbsoluteDifference(self, nums: List[int], x: int) -> int:\n        nums.sort()\n        n = len(nums)\n        ans = float('inf')\n        for i in range(n):\n            for j in range(i+1, n):\n                if abs(nums[i] - nums[j]) < ans:\n                    ans = abs(nums[i] - nums[j])\n                if abs(nums[i] - nums[j]) == ans and abs(nums[i] - x) < abs(nums[j] - x):\n                    ans = abs(nums[i] - x)\n        return ans"}
{"code": "class Solution {\npublic:\n    int minAbsoluteDifference(vector<int>& nums, int x) {\n    int n=nums.size();\n    vector<int>v;\n    for(int i=0;i<n;i++)\n    {\n        v.push_back(abs(nums[i]-x));\n    }\n    sort(v.begin(),v.end());\n    int ans=v[0];\n    for(int i=1;i<n;i++)\n    {\n        ans=min(ans,v[i]-v[i-1]);\n    }\n    return ans;\n    }\n};"}
{"code": "class Solution {\n    public ListNode doubleIt(ListNode head) {\n    ListNode dummy = new ListNode(0);\n    dummy.next = head;\n    ListNode cur = dummy;\n    while (cur.next != null && cur.next.next != null) {\n        ListNode next = cur.next.next;\n        cur.next.next =  next.next;\n        next.next = cur.next;\n        cur.next = next;\n        cur = cur.next.next;\n    }\n    return dummy.next;\n    }\n}"}
{"code": "class Solution:\n    def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if head is None:\n            return None\n        temp = head\n        while temp is not None:\n            temp.val *= 2\n            temp = temp.next\n        return head"}
{"code": "class Solution {\npublic:\n    ListNode* doubleIt(ListNode* head) {\n        ListNode* temp=head;\n        while(temp!=NULL){\n            ListNode* temp2=temp->next;\n            temp->next=new ListNode(temp->val);\n            temp->next->next=temp2;\n            temp=temp2;\n        }\n        return head;\n    }\n};"}
{"code": "public class Solution {\n    public int maximumScore(List<Integer> nums, int k) {\n        \n        int n = nums.size();\n        int[] dp = new int[n];\n        int[] prime = new int[n];\n        int[] primeCount = new int[n];\n        int[] prefix = new int[n];\n        int[] suffix = new int[n];\n        \n        \n        for(int i = 0; i < n; i++){\n            dp[i] = nums.get(i);\n            prime[i] = getPrime(nums.get(i));\n            primeCount[i] = getPrimeCount(nums.get(i));\n            \n        }\n        \n        for(int i = 1; i < n; i++){\n            prefix[i] = prefix[i-1] + primeCount[i-1];\n        }\n        \n        for(int i = n-2; i >= 0; i--){\n            suffix[  i] = suffix[i+1] + primeCount[i+1];\n        }\n        \n        int[] dp2 = new int[n];\n        int[] dp3 = new int[n];\n        int[] dp4 = new int[n];\n        \n        for(int i = 0  ; i < n; i++){\n            dp2[i] = dp[i];\n            dp3[i] = dp[i];\n            dp4[i] = dp[i];\n        }\n        \n        for(int i = 0; i < k; i++){\n            int max  = -1;\n            int maxIndex = -1;\n            for(int j = 0; j < n; j++){\n                if(j == 0){\n                    dp2[j] = dp[j] * prime[j];\n                }else{\n                    dp2[j  ] = Math.max(dp2[j-1], dp[j] * prime[j]);\n                }\n                \n                if(j == n-1){\n                    dp3[j] = dp[j] * prime[j];\n                }else{\n                    dp3[j]  = Math.max(dp3[j+1], dp[j] * prime[j]);\n                }\n                \n                if(prefix[j] + suffix[j] - primeCount[j] > max){\n                    max = prefix[j] + suffix[j] - primeCount  [j];\n                    maxIndex = j;\n                }\n            }\n            \n            dp4[maxIndex] = 0;\n            \n            for(int j = 0; j < n; j++){\n                if(j == 0){\n                    dp4[j] = Math.max(dp4  [j], dp2[j]);\n                }else if(j == n-1){\n                    dp4[j] = Math.max(dp4[j], dp3[j]);\n                }else{\n                    dp4[j] = Math.max(dp4[j],  Math.max(dp2[j], dp3[j]));\n                }\n            }\n            \n            for(int j = 0; j < n; j++){\n                dp[j] = dp4[j];\n            }\n        }\n        \n        int sum = 0;\n        for(int i  = 0; i < n; i++){\n            sum = (sum + dp[i]) % 1000000007;\n        }\n        \n        return sum;\n    }\n    \n    public int getPrime(int num){\n        int count = 0;\n        for(  int i = 2; i <= num; i++){\n            if(num % i == 0){\n                count++;\n            }\n        }\n        return count;\n    }\n    \n    public int getPrimeCount(int num){\n        int count = 0;\n        for(  int i =  2; i <= num; i++){\n            if(num % i == 0){\n                count++;\n            }\n        }\n        return count - 1;\n    }\n}"}
{"code": "class Solution:\n    def maximumScore(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        dp = [0]*n\n        dp[0] = nums[0]\n        for i in range(1, n):\n            dp[i] = max(dp[i-1], nums[i])\n        ans = dp[k-1]\n        for i in range(k-1, n):\n            ans = max(ans, dp[i] * dp[k-1-i])\n        return ans % (10**9 + 7)"}
{"code": "class Solution {\npublic:\n    int maximumScore(vector<int>& nums, int k) {\n        int MOD=1e9+7;\n        int n=nums.size();\n        vector<int> dp(n+1,0);\n        vector<int> primes;\n        for(int i=2;i<=n;i++) {\n            if(dp[i]==0) {\n                primes.push_back(i);\n                for(int j=i;j<=n;j+=i) {\n                    dp[j]+=1;\n                }\n            }\n        }\n        int ans=0;\n        for(int i=0;i<k;i++) {\n            int mx=0;\n            int mx_idx=-1;\n            for(int j=i;j<n;j++) {\n                if(mx<dp[j]) {\n                    mx=dp[j];\n                    mx_idx=j;\n                }\n            }\n            ans=(ans+nums[mx_idx]*primes[mx-1])%MOD;\n            dp[mx_idx]=0;\n        }\n        return ans;\n    }\n};"}
{"code": "public class Solution {\n    public int findMaximumElegance(int[][] items, int k) {\n        int n = items.length;\n        int[][] dp = new int[n][k];\n        for(int i=0; i<n; i++) {\n            dp[i][0] = items[i][0];\n        }\n        for(int i=1; i  <n; i++) {\n            for(int j=1; j<k; j++) {\n                int max = Integer.MIN_VALUE;\n                for(int m=0; m<i; m++) {\n                    if(items[m][1] != items[i][ 1]) {\n                        max = Math.max(max, dp[m][j-1]);\n                    }\n                }\n                dp[i][j] = max + items[i][0];\n            }\n        }\n        int max = Integer.MIN_VALUE;\n        for(int i= 0; i<n; i++) {\n            max = Math.max(max, dp[i][k-1]);\n        }\n        return max;\n    }\n}"}
{"code": "class Solution:\n    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:\n        n = len(items)\n        dp = [[0]*n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = items[i][0]\n        for l in range(2, n+1):\n            for i in range(n-l+1):\n                j = i+l-1\n                dp[i][j] = max(dp[i][j-1], dp[i+1][j]) + items[j][0]\n        return max(dp[0][k-1], dp[n-k][n-1])"}
{"code": "class Solution {\npublic:\n    long long findMaximumElegance(vector<vector<int>>& items, int k) {\n  int n=items.size();\n  vector<vector<int>>dp(n,vector<int>(k,0));\n  for(int i=0;i<n;i++)\n  {\n    dp[i][0]=items[i][0];\n  }\n  for(int i=1;i<n;i++)\n  {\n    for(int j=1;j<k;j++)\n    {\n      dp[i][j]=max(dp[i-1][j],dp[i-1][j-1]);\n      if(items[i][1]!=items[i-1][1])\n      {\n        dp[i][j]=max(dp[i][j],dp[i-1][j]+items[i][0]);\n      }\n    }\n  }\n  return dp[n-1][k-1];\n    }\n};"}
