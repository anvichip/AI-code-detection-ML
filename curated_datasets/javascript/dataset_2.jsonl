{"code": "function findOddOccurringNumbers(arr) {\n    let xor = 0;\n\n    // Step 1: XOR all elements. Result is XOR of two odd occurring elements\n    for (let num of arr) {\n        xor ^= num;\n    }\n\n    // Step 2: Find a set bit in the result (there must be at least one)\n    let setBit = xor & -xor;\n\n    let num1 = 0, num2 = 0;\n\n    // Step 3: Divide all numbers into two groups and XOR separately\n    for (let num of arr) {\n        if ((num & setBit) === 0) {\n            num1 ^= num;\n        } else {\n            num2 ^= num;\n        }\n    }\n\n    return [num1, num2];\n}\n", "writer": "AI"}
{"code": "function isPalindrome(s) {\n    // Remove non-alphanumeric characters and convert to lower case\n    const cleaned = s.replace(/[^A-Za-z0-9]/g, '').toLowerCase();\n\n    // Initialize pointers for two ends\n    let left = 0;\n    let right = cleaned.length - 1;\n\n    // Compare characters from start to end, moving towards the center\n    while (left < right) {\n        if (cleaned[left] !== cleaned[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n\n    return true;\n}\n", "writer": "AI"}
{"code": "function findMaxNumber(numbers) {\n  // Return the maximum number in the array using Math.max and spread operator\n  return Math.max(...numbers);\n}\n\n// Examples\nconsole.log(findMaxNumber([1, 5, 9, 3, 7])); // Output: 9\nconsole.log(findMaxNumber([-2, 0, -5, -1])); // Output: 0\n", "writer": "AI"}
{"code": "function removeDuplicates(str) {\n    let result = ''; // Initialize result string without duplicates\n    let seen = new Set(); // Create an empty set to track seen characters\n\n    // Loop through each character in the string\n    for (let char of str) {\n        // If the character has not been seen, append it to the result\n        if (!seen.has(char)) {\n            result += char;\n            seen.add(char); // Add character to the set\n        }\n    }\n    return result; // Return the string with duplicates removed\n}\n", "writer": "AI"}
{"code": "function sumOfOddNumbers(arr) {\n    // Initialize sum to accumulate only odd numbers\n    let sum = 0;\n    \n    // Iterate through each number in the array\n    for (let num of arr) {\n        // Check if the number is odd\n        if (num % 2 !== 0) {\n            // Add the odd number to the sum\n            sum += num;\n        }\n    }\n    \n    // Return the total sum of all odd numbers\n    return sum;\n}\n\n// Example usage:\nconsole.log(sumOfOddNumbers([1, 2, 3, 4, 5])); // Output: 9\n", "writer": "AI"}
{"code": "// Node.js function to check if the parentheses are balanced\nfunction isBalanced(sequence) {\n  let balance = 0;\n  for (const char of sequence) {\n    if (char === '(') {\n      balance += 1;\n    } else if (char === ')') {\n      balance -= 1;\n    }\n    if (balance < 0) {\n      return false;\n    }\n  }\n  return balance === 0;\n}\n\n// React component to input sequence of parentheses and display the result\nimport React, { useState } from 'react';\n\nfunction ParenthesesValidator() {\n  const [input, setInput] = useState('');\n\n  const handleChange = (event) => {\n    setInput(event.target.value);\n  };\n\n  // Toggle the result based on current input using the isBalanced function\n  // It updates as the user types, showing whether the current sequence is balanced.\n  const result = isBalanced(input);\n\n  return (\n    <div>\n      <input type=\"text\" value={input} onChange={handleChange} placeholder=\"Enter parentheses\" />\n      <div>\n        {input ? (result ? 'Balanced' : 'Not balanced') : 'Enter a sequence to validate'}\n      </div>\n    </div>\n  );\n}\n\nexport default ParenthesesValidator;\n", "writer": "AI"}
{"code": "import React, { useState } from 'react';\n\nfunction HexToRGBConverter() {\n  const [hex, setHex] = useState('');\n  const [rgb, setRgb] = useState('');\n  const [isValid, setIsValid] = useState(true);\n\n  const handleChange = (event) => {\n    const hexValue = event.target.value;\n    // Check if the hex input is valid\n    if (/^#([0-9A-F]{3}){1,2}$/i.test(hexValue)) {\n      setHex(hexValue);\n      setIsValid(true);\n      convertToRGB(hexValue);\n    } else {\n      setIsValid(false);\n      setRgb('');\n    }\n  };\n\n  const convertToRGB = (hex) => {\n    let r = 0, g = 0, b = 0;\n\n    // 3 digits or 6 digits\n    if (hex.length === 4) {\n      r = parseInt(hex[1] + hex[1], 16);\n      g = parseInt(hex[2] + hex[2], 16);\n      b = parseInt(hex[3] + hex[3], 16);\n    } else if (hex.length === 7) {\n      r = parseInt(hex[1] + hex[2], 16);\n      g = parseInt(hex[3] + hex[4], 16);\n      b = parseInt(hex[5] + hex[6], 16);\n    }\n\n    setRgb(`RGB(${r}, ${g}, ${b})`);\n  };\n\n  return (\n    <div>\n      <input \n        type=\"text\" \n        value={hex} \n        onChange={handleChange} \n        placeholder=\"#FFFFFF\"\n        style={{ borderColor: isValid ? 'default' : 'red' }}\n      />\n      {isValid && rgb && (\n        <div>\n          <div style={{ backgroundColor: hex, width: '50px', height: '50px', display: 'inline-block', marginLeft: '10px' }}></div>\n          <span style={{ marginLeft: '10px' }}>{rgb}</span>\n        </div>\n      )}\n    </div>\n  );\n}\n\nexport default HexToRGBConverter;\n", "writer": "AI"}
{"code": "function stripHtmlTags(inputString) {\n    // Using a regular expression to remove any HTML tags\n    return inputString.replace(/<[^>]*>/g, '');\n}\n", "writer": "AI"}
{"code": "function isAnagram(str1, str2) {\n    // Normalize the strings: remove non-alphabet characters, convert to lowercase\n    const normalize = str => str.toLowerCase().replace(/[^a-z]/g, '');\n    str1 = normalize(str1);\n    str2 = normalize(str2);\n    \n    // Check if lengths are different\n    if (str1.length !== str2.length) {\n        return false;\n    }\n    \n    // Sort the letters of both strings\n    const sortedStr1 = str1.split('').sort().join('');\n    const sortedStr2 = str2.split('').sort().join('');\n    \n    // Compare sorted strings\n    return sortedStr1 === sortedStr2;\n}\n", "writer": "AI"}
{"code": "import React, { useMemo, useState, useCallback } from 'react';\n\n// Example component: Item\nconst Item = React.memo(({ itemData }) => {\n  console.log('Rendering Item:', itemData.id); // Check which Item is being re-rendered\n  return <div>{itemData.name}</div>;\n});\n\n// Parent component: ItemList\nconst ItemList = () => {\n  const [items, setItems] = useState([\n    { id: 1, name: 'Item 1' },\n    { id: 2, name: 'Item 2' }\n  ]);\n\n  const [filter, setFilter] = useState('');\n\n  // Handler to add a new item\n  const addItem = useCallback(() => {\n    setItems(prevItems => [...prevItems, { id: prevItems.length + 1, name: `Item ${prevItems.length + 1}` }]);\n  }, []);\n\n  // Handler to update filter\n  const updateFilter = useCallback((e) => {\n    setFilter(e.target.value);\n  }, []);\n\n  // Apply filter to items\n  const filteredItems = useMemo(() => {\n    console.log('Filtering items'); // Check when filtering happens\n    return items.filter(item => item.name.toLowerCase().includes(filter.toLowerCase()));\n  }, [items, filter]);\n\n  return (\n    <div>\n      <input type=\"text\" value={filter} onChange={updateFilter} placeholder=\"Filter items\" />\n      <button onClick={addItem}>Add Item</button>\n      {filteredItems.map(item => (\n        <Item key={item.id} itemData={item} />\n      ))}\n    </div>\n  );\n};\n\nexport default ItemList;\n", "writer": "AI"}
{"code": "function mergeSortedArrays(arr1, arr2) {\n    const mergedArray = [];\n    let i = 0, j = 0;\n\n    // Iterate over both arrays and insert the smallest value into mergedArray\n    while (i < arr1.length && j < arr2.length) {\n        if (arr1[i] < arr2[j]) {\n            mergedArray.push(arr1[i]);\n            i++;\n        } else {\n            mergedArray.push(arr2[j]);\n            j++;\n        }\n    }\n\n    // Append remaining elements from arr1 or arr2\n    while (i < arr1.length) {\n        mergedArray.push(arr1[i]);\n        i++;\n    }\n    \n    while (j < arr2.length) {\n        mergedArray.push(arr2[j]);\n        j++;\n    }\n\n    return mergedArray;\n}\n", "writer": "AI"}
{"code": "function matchUsersBySkills(users) {\n    const n = users.length;\n    let bestPairAverage = -1;\n    let bestPairs = [];\n\n    // This function will check if two users have at least one skill in common and calculate the average skill rating\n    function checkAndCalcAvgSkillRating(user1, user2) {\n        let commonSkills = [];\n        let totalRating = 0;\n        // Identify common skills between two users\n        for (let skill in user1.skills) {\n            if (skill in user2.skills) {\n                commonSkills.push(skill);\n                totalRating += Math.abs(user1.skills[skill] - user2.skills[skill]);\n            }\n        }\n        // Calculate the adjusted average skill rating only if there is common skill\n        if (commonSkills.length > 0) {\n            return totalRating / commonSkills.length;\n        }\n        return null;\n    }\n\n    // Function to find best pairs of users based on their skills\n    function findPairs(used, currentPairs, currentIndex) {\n        if (currentIndex >= n) {\n            let currentAverage = currentPairs.reduce((acc, pair) => acc + pair.avg, 0) / (currentPairs.length || 1);\n            if (currentPairs.length > 0 && (bestPairAverage === -1 || currentAverage < bestPairAverage)) {\n                bestPairAverage = currentAverage;\n                bestPairs = currentPairs.map(pair => [pair.user1.name, pair.user2.name]);\n            }\n            return;\n        }\n\n        if (used[currentIndex]) {\n            findPairs(used, currentPairs, currentIndex + 1);\n        } else {\n            used[currentIndex] = true;\n            // try pairing current user with any other user\n            for (let i = currentIndex + 1; i < n; i++) {\n                if (!used[i]) {\n                    let avg = checkAndCalcAvgSkillRating(users[currentIndex], users[i]);\n                    if (avg !== null) {\n                        used[i] = true;\n                        findPairs(used, [...currentPairs, { user1: users[currentIndex], user2: users[i], avg }], currentIndex + 1);\n                        used[i] = false;\n                    }\n                }\n            }\n            used[currentIndex] = false;\n            findPairs(used, currentPairs, currentIndex + 1);\n        }\n    }\n\n    // Start recursive pairing\n    findPairs(Array(n).fill(false), [], 0);\n\n    return bestPairs;\n}\n\n// Example usage:\nconst users = [\n    { name: 'Alice', skills: { Java: 5, C++: 3 } },\n    { name: 'Bob', skills: { Java: 6, Python: 4 } },\n    { name: 'Charlie', skills: { Python: 5, C++: 5 } }\n];\nconsole.log(matchUsersBySkills(users));\n", "writer": "AI"}
{"code": "// Laravel Controller Method\nuse App\\Models\\User;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Log;\nuse Illuminate\\Database\\Eloquent\\ModelNotFoundException;\n\nclass UserController extends Controller\n{\n    public function getUsers(Request $request)\n    {\n        try {\n            // Get page and username from query parameters\n            $username = $request->query('username', '');\n            $pageSize = $request->query('size', 15); // default page size to 15\n\n            // Query using Eloquent with conditions and pagination\n            $users = User::where('username', 'LIKE', \"%$username%\")->paginate($pageSize);\n\n            return response()->json($users);\n        } catch (\\Exception $e) {\n            Log::error('Failed to fetch users:', ['error' => $e->getMessage()]);\n            // Return a general HTTP 500 response if there is an error\n            return response()->json(['error' => 'Failed to fetch users'], 500);\n        }\n    }\n}\n", "writer": "AI"}
{"code": "function sortColorsByLuminance(colors) {\n    const colorToRgb = (color) => {\n        if (color.charAt(0) === '#') { // HEX color\n            const r = parseInt(color.substr(1, 2), 16);\n            const g = parseInt(color.substr(3, 2), 16);\n            const b = parseInt(color.substr(5, 2), 16);\n            return { r, g, b };\n        } else { // Name color\n            const ctx = document.createElement('canvas').getContext('2d');\n            ctx.fillStyle = color;\n            return ctx.fillStyle; // Convert name to rgb\n        }\n    };\n\n    const luminance = (color) => {\n        const { r, g, b } = colorToRgb(color);\n        // Standard RGB luminance formula\n        return 0.2126 * r + 0.7152 * g + 0.0722 * b;\n    };\n\n    return colors.sort((a, b) => luminance(a) - luminance(b))\n}\n\n// Example usage\nconst colors = ['black', '#FF0000', 'blue'];\nconst sortedColors = sortColorsByLuminance(colors);\nconsole.log(sortedColors);\n", "writer": "AI"}
{"code": "import React, { useState, useEffect } from 'react';\n\nfunction PasswordStrengthMeter() {\n  const [password, setPassword] = useState('');\n  const [strength, setStrength] = useState('Weak');\n\n  useEffect(() => {\n    evaluateStrength(password);\n  }, [password]);\n\n  // Function to evaluate strength of the password\n  const evaluateStrength = (password) => {\n    const len = password.length;\n    const hasNumbers = /\\d/.test(password);\n    const hasSpecialChars = /[!@#$%^&*(),.?\":{}|<>]/.test(password);\n\n    if (len > 8 && hasNumbers && hasSpecialChars) {\n      setStrength('Strong');\n    } else if (len > 5 && (hasNumbers || hasSpecialChars)) {\n      setStrength('Medium');\n    } else {\n      setStrength('Weak');\n    }\n  };\n\n  // Handle password input change\n  const handleChange = (event) => {\n    setPassword(event.target.value);\n  };\n\n  return (\n    <div>\n      <input type=\"password\" value={password} onChange={handleChange} />\n      <div>\n        Strength: <span style={{ fontWeight: 'bold', color: getStrengthColor(strength) }}>{strength}</span>\n      </div>\n    </div>\n  );\n}\n\n// Function to return color based on password strength\nfunction getStrengthColor(strength) {\n  switch (strength) {\n    case 'Strong':\n      return 'green';\n    case 'Medium':\n      return 'orange';\n    default:\n      return 'red';\n  }\n}\n\nexport default PasswordStrengthMeter;\n", "writer": "AI"}
{"code": "const findLongestSubstring = (str) => {\n    let start = 0;\n    let maxLength = 0;\n    let longestSub = '';\n    let map = {};\n\n    for (let i = 0; i < str.length; i++) {\n        const char = str[i];\n\n        if (map[char] >= start) {\n            start = map[char] + 1;\n        }\n\n        map[char] = i;\n\n        if (i - start + 1 > maxLength) {\n            maxLength = i - start + 1;\n            longestSub = str.substring(start, i + 1);\n        }\n    }\n\n    return { substring: longestSub, length: maxLength };\n}\n\n// Example usage\nconst input = 'abrkaabcdefghijjxxx';\nconst result = findLongestSubstring(input);\nconsole.log(result);\n", "writer": "AI"}
{"code": "import React, { useState, useEffect } from 'react';\n\nconst CountdownTimer = ({ predefinedTime }) => {\n  // Convert minutes to seconds\n  const totalSeconds = predefinedTime > 0 ? predefinedTime * 60 : 0;\n  const [secondsLeft, setSecondsLeft] = useState(totalSeconds);\n  const [timerActive, setTimerActive] = useState(totalSeconds > 0);\n\n  useEffect(() => {\n    let interval = null;\n\n    if (timerActive) {\n      interval = setInterval(() => {\n        setSecondsLeft((prevSeconds) => {\n          if (prevSeconds <= 1) {\n            clearInterval(interval);\n            setTimerActive(false);\n            return 0;\n          }\n          return prevSeconds - 1;\n        });\n      }, 1000);\n    }\n\n    return () => clearInterval(interval);\n  }, [timerActive]);\n\n  const formatTime = (seconds) => {\n    const minutes = Math.floor(seconds / 60);\n    const remainingSeconds = seconds % 60;\n    return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;\n  };\n\n  return (\n    <div>\n      <div>{timerActive ? formatTime(secondsLeft) : \"Time is up\"}</div>\n    </div>\n  );\n};\n\nexport default CountdownTimer;\n", "writer": "AI"}
{"code": "function sortPlayers(players) {\n    // Create a copy of the array to avoid mutating the original array\n    const playersCopy = [...players];\n\n    // Sort the array of player objects\n    return playersCopy.sort((a, b) => {\n        // Sort by score in descending order\n        if (a.score > b.score) {\n            return -1;\n        } else if (a.score < b.score) {\n            return 1;\n        } else {\n            // If scores are equal, sort by name in ascending order\n            return a.name.localeCompare(b.name);\n        }\n    });\n}\n", "writer": "AI"}
{"code": "function parseURL(url) {\n    const result = {\n        protocol: '',\n        host: '',\n        port: '',\n        path: '',\n        queryParams: {},\n        anchor: ''\n    };\n\n    // Extract the protocol\n    const protocolEndIndex = url.indexOf('://');\n    if (protocolEndIndex !== -1) {\n        result.protocol = url.substring(0, protocolEndIndex);\n        url = url.substring(protocolEndIndex + 3);\n    }\n\n    // Extract the anchor (hash)\n    const hashIndex = url.indexOf('#');\n    if (hashIndex !== -1) {\n        result.anchor = url.substring(hashIndex + 1);\n        url = url.substring(0, hashIndex);\n    }\n\n    // Extract the query parameters\n    const queryParamsIndex = url.indexOf('?');\n    if (queryParamsIndex !== -1) {\n        const queryParamsString = url.substring(queryParamsIndex + 1);\n        url = url.substring(0, queryParamsIndex);\n        const allParams = queryParamsString.split('&');\n        allParams.forEach(param => {\n            const [key, value] = param.split('=');\n            result.queryParams[key] = value;\n        });\n    }\n\n    // Extract port if it exists\n    const portIndex = url.lastIndexOf(':');\n    const pathIndex = url.indexOf('/');\n    if (portIndex !== -1 && portIndex < pathIndex) {\n        result.port = url.substring(portIndex + 1, pathIndex);\n        url = url.substring(0, portIndex);\n    }\n\n    // Extract host and path\n    const pathStartIndex = url.indexOf('/');\n    if (pathStartIndex !== -1) {\n        result.host = url.substring(0, pathStartIndex);\n        result.path = url.substring(pathStartIndex);\n    } else { // No path, URL ended with host and possibly port\n        result.host = url;\n    }\n\n    return result;\n}\n", "writer": "AI"}
{"code": "const https = require('https');\n\nfunction fetchStatusCodes(urls) {\n  // Create a function that returns a Promise\n  return new Promise((resolve, reject) => {\n    let results = {}; // Object to store URL and its corresponding status code\n    let completedRequests = 0; // Counter to track completed requests\n\n    urls.forEach((url) => {\n      https.get(url, (res) => {\n        // Increment the completed requests counter once each request finishes\n        completedRequests++;\n        \n        // Store the status code of the URL\n        results[url] = res.statusCode;\n\n        // If all requests are completed, resolve the Promise\n        if (completedRequests === urls.length) {\n          resolve(results);\n        }\n      }).on('error', (err) => {\n        // In case of an error, store 'null' as the status code for that URL\n        completedRequests++;\n        results[url] = null;\n\n        // Still continue with other requests, unless all failed\n        if (completedRequests === urls.length) {\n          resolve(results);\n        }\n      });\n    });\n  });\n}\n\n// Example usage:\n// fetchStatusCodes(['https://example.com', 'https://google.com']).then(console.log);\n", "writer": "AI"}
{"code": "function buildSentence(words, maxChars) {\n    // Initialize the result sentence with an empty string\n    let sentence = \"\";\n    // Initial used characters must account for the final full stop\n    let usedChars = 1; // For the full stop at the end\n\n    for (let word of words) {\n        // Check if adding this word plus a space surpasses the limit\n        if (usedChars + word.length + (sentence === \"\" ? 0 : 1) > maxChars) {\n            break;\n        }\n        // Add the word to the sentence, with a space if it's not the first word\n        sentence += (sentence === \"\" ? \"\" : \" \") + word;\n        // Update the count of used characters\n        usedChars += word.length + (sentence === \"\" ? 0 : 1);\n    }\n\n    // Add a full stop only if there is at least one word\n    return sentence.length > 0 ? sentence + '.' : '';\n}\n", "writer": "AI"}
{"code": "import React, { useState } from 'react';\n\nfunction DynamicTable() {\n  const [tableData, setTableData] = useState([['']]); // Initial state with one cell\n\n  // Add a new row to the table\n  const addRow = () => {\n    const newRow = new Array(tableData[0].length).fill(''); // Create a new row with empty cells\n    setTableData([...tableData, newRow]);\n  };\n\n  // Add a new column to the table\n  const addColumn = () => {\n    const newTableData = tableData.map(row => [...row, '']); // Add a new cell to each row\n    setTableData(newTableData);\n  };\n\n  // Remove a row from the table\n  const removeRow = rowIndex => {\n    if (tableData.length > 1) {\n      const newTableData = tableData.filter((_, index) => index !== rowIndex);\n      setTableData(newTableData);\n    }\n  };\n\n  // Remove a column from the table\n  const removeColumn = colIndex => {\n    if (tableData[0].length > 1) {\n      const newTableData = tableData.map(row => row.filter((_, index) => index !== colIndex));\n      setTableData(newTableData);\n    }\n  };\n\n  // Update cell data\n  const updateCell = (rowIndex, colIndex, value) => {\n    const updatedTableData = tableData.map((row, rIndex) => {\n      if (rIndex === rowIndex) {\n        return row.map((cell, cIndex) => (cIndex === colIndex ? value : cell));\n      }\n      return row;\n    });\n    setTableData(updatedTableData);\n  };\n\n  return (\n    <div>\n      <button onClick={addRow}>Add Row</button>\n      <button onClick={addColumn}>Add Column</button>\n      <table>\n        <tbody>\n          {tableData.map((row, rowIndex) => (\n            <tr key={rowIndex}>\n              {row.map((cell, colIndex) => (\n                <td key={`${rowIndex}-${colIndex}`}>\n                  <input \n                    value={cell}\n                    onChange={(e) => updateCell(rowIndex, colIndex, e.target.value)} \n                  />\n                </td>\n              ))}\n              <td>\n                <button onClick={() => removeRow(rowIndex)}>Remove Row</button>\n              </td>\n            </tr>\n          ))}\n        </tbody>\n      </table>\n      {tableData[0].length > 1 && <button onClick={() => removeColumn(tableData[0].length - 1)}>Remove Last Column</button>}\n    </div>\n  );\n}\n\nexport default DynamicTable;\n", "writer": "AI"}
{"code": "function bubbleSort(arr) {\n    let n = arr.length;\n    let swapped;\n    do {\n        swapped = false;\n        for (let i = 1; i < n; i++) {\n            if (arr[i - 1] > arr[i]) {\n                // Swap elements if they are in wrong order\n                [arr[i - 1], arr[i]] = [arr[i], arr[i - 1]];\n                swapped = true;\n            }\n        }\n        // Reduce n because the last element is already in place\n        n--;\n    } while (swapped);\n\n    return arr;\n}\n\n// Example usage:\n// console.log(bubbleSort([34, 17, 23, 67, 45]));  // Output: [17, 23, 34, 45, 67]\n", "writer": "AI"}
{"code": "function compressObject(obj) {\n  const result = {};\n\n  function helper(subObj, prefix) {\n    Object.keys(subObj).forEach(key => {\n      const value = subObj[key];\n      const newKey = prefix ? `${prefix}.${key}` : key;\n      if (value !== null && typeof value === 'object') {\n        helper(value, newKey);\n      } else if (value !== null) {\n        result[newKey] = value;\n      }\n    });\n  }\n\n  helper(obj, '');\n  return result;\n}\n", "writer": "AI"}
{"code": "// Provided example is incorrect it should return [5] not [1,5]\n\nfunction findOdd(arr) {\n  const map = arr.reduce((_map, next) => {\n    _map[next] = _map[next] || 0;\n    _map[next] ++;\n    return _map;\n  }, {});\n\n  const foundNumbers = [];\n  Object.keys(map).forEach((key) => {\n    const number = parseInt(key);\n    const isAppearOddTimes = map[key] % 2 !== 0;\n    if (isAppearOddTimes) {\n      foundNumbers.push(number);\n      if (foundNumbers.length === 2) {\n        return foundNumbers;\n      }\n    }\n  })\n  return foundNumbers;\n  \n}", "writer": "Human"}
{"code": "const checkIsPalindrome =(input: string)=>{\n  const parsedInput = input.toLowerCase().replace(/[^a-zA-Z0-9\\.?!]/g,'');\n  const reversedString = parsedInput.split('').reverse().join('');\n  return parsedInput === reversedString\n}", "writer": "Human"}
{"code": "function findMaxInArray(arr){\n let max = arr[0];\n for(let i=1; i<=arr.length; i++){\n   if(a[i]>max){\n   max = a[i]\n   }\n }\n return max;\n}", "writer": "Human"}
{"code": "function removeDuplicateChars(str) {\n  let result = '';\n  // loop through the string characters\n  for(let i=0; i<str.length; i++) {\n    const char = str.at(i);\n    // if the character is not in result string, append it\n    if(result.indexOf(char) === -1) {\n      result += char;\n    }\n  }\n\n  return result;\n}", "writer": "Human"}
{"code": "<?php>\n\n  $list = array(array[1, 2, 3, 4, 5], 9)\n\n  $num = 0\n\n  foreach ($list in $item) {\n    if(gettype($list) === \"array\") {\n      foreach($item in $subitem) {\n        if($subitem %2) {\n          \n        }else {\n          $num = $num + $subitem\n        }\n      }\n    } else {\n      $num = $num + $item\n    }\n    return \n  }\n  \n?>", "writer": "Human"}
{"code": "const fs = require('fs');\nconst Joi = require('joi');\n\n// Define your JSON schema using Joi\nconst schema = Joi.object({\n  // Define your schema structure here\n  name: Joi.string().required(),\n  age: Joi.number().integer().min(18),\n  email: Joi.string().email(),\n  // Add more properties as needed\n});\n\n// Function to read and validate JSON configuration\nfunction validateJsonConfig(filePath) {\n  try {\n    // Read the JSON configuration file\n    const jsonData = JSON.parse(fs.readFileSync(filePath, 'utf8'));\n\n    // Validate against the schema\n    const { error } = schema.validate(jsonData);\n\n    if (error) {\n      console.error('Validation Error:', error.message);\n    } else {\n      console.log('Validation Successful. Configuration is valid.');\n    }\n  } catch (err) {\n    console.error('Error reading or parsing the JSON file:', err.message);\n  }\n}\n\n// Provide the path to your JSON configuration file\nconst configFilePath = 'path/to/your/config.json';\n\n// Call the function to validate the JSON configuration\nvalidateJsonConfig(configFilePath);", "writer": "Human"}
{"code": "// src/index.js\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(<App />, document.getElementById('root'));", "writer": "Human"}
{"code": "function stripHtmlTags(str) {\n  return str.replace(/<[^>]*>/g, '');\n}\n\nconst input = '<p>Hello <em>World</em>!</p>';\n\nconst output = stripHtmlTags(input);\n\nconsole.log(output);", "writer": "Human"}
{"code": "function isAnagram(s1, s2) {\n  const a1 = s1.split('');\n  const a2 = s2.split('');\n  for (let c of a1) {\n    const idx = a2.indexOf(c)\n    if (idx == -1) {\n      return false;\n    }\n    a2.splice(idx, 1)\n  }\n  return a2.length == 0\n}", "writer": "Human"}
{"code": "// I have created a few components with an common scenario to prevent \n// children components from rerendering if the related props do not change\n// even when the parent component got updated using the HOC that is 'memo'\n\n// there will be different scenarios with different setup and complexity\n// in such cases, other approaching such as using useCallback for memoizing the function\n// useMemo for memoizing the result of the function\n\nimport { memo, useState } from 'react';\n\nconst App = () => {\n  const [counter, setCounter] = useState(0);\n  const [light, setLight] = useState(false);\n\n  return (\n    <div>\n      <Counter counter={counter} />\n      <button onClick={() => setCounter((c) => c - 1)}>Decrement</button>\n      <button onClick={() => setCounter((c) => c + 1)}>Increment</button>\n      <br /> <br /> <br />\n      <Light light={light} />\n      <button onClick={() => setLight((c) => !c)}>Toggle</button>\n    </div>\n  );\n};\n\nexport default App;\n\nconst Counter = memo(({ counter }) => {\n  console.log('counter', counter);\n  return <div>Counter: {counter}</div>;\n});\n\nconst Light = memo(({ light }) => {\n  console.log('light', light);\n  return <div>Light: {light ? 'On' : 'Off'}</div>;\n});", "writer": "Human"}
{"code": "jhjbhbkj", "writer": "Human"}
{"code": "function findBestPairings(users) {\n  const pairs = []\n\n  while (users.length > 1) {\n    let bestPair = null\n    let bestAverageRating = -1\n\n    for (let i = 0; i < users.length - 1; i++) {\n      for (let j = i + 1; j < users.length; j++) {\n        const commonSkills = getCommonSkills(users[i].skills, users[j].skills)\n\n        if (commonSkills.length > 0) {\n          const averageRating = calculateAverageRating(\n            commonSkills,\n            users[i],\n            users[j]\n          )\n\n          if (averageRating > bestAverageRating) {\n            bestAverageRating = averageRating\n            bestPair = [users[i].name, users[j].name]\n          }\n        }\n      }\n    }\n\n    if (bestPair) {\n      pairs.push(bestPair)\n      users = users.filter(\n        (user) => user.name !== bestPair[0] && user.name !== bestPair[1]\n      )\n    } else {\n      break\n    }\n  }\n\n  return pairs\n}\n\nfunction getCommonSkills(skills1, skills2) {\n  return Object.keys(skills1).filter((skill) => skills2.hasOwnProperty(skill))\n}\n\nfunction calculateAverageRating(commonSkills, user1, user2) {\n  const totalRating = commonSkills.reduce((sum, skill) => {\n    return sum + user1.skills[skill] + user2.skills[skill]\n  }, 0)\n\n  return totalRating / commonSkills.length\n}\n\nconst users = [\n  { name: 'Alice', skills: { Java: 5, C: 3 } },\n  { name: 'Bob', skills: { Java: 6, Python: 4 } },\n  { name: 'Charlie', skills: { Python: 5, C: 5 } }\n]\n\nconst pairings = findBestPairings(users)\nconsole.log(pairings)", "writer": "Human"}
{"code": "api file\nRoute::get('/users',UserController@index)\n\nUserController.php\n\n\nPublic function index(Request $request){\ntry{\n            $query = User::query();\n           if($request->has('username')){\n          $query->where(usersname,like,% $request->input('username')%);\n      }\n          \n       $users = $query->paginate(10)\n       return response()->json($users);\n      }\n      catch(/Exception $e){\n      return response()->json(['error'=>'error'],500);\n      }\n}\n\n\nuserList.file\n\n<template>\n<div>\n<input v-model=\"filter\" @input=\"fetchUsers\">\n<ul>\n<li v-for=\"u in users\">{{user.username}}</li>\n</ul>\n<pagination :data=\"users\" @pagination-change-page=\"fetchUsers\"></pagination>\n</div>\n</template>\n<script>\nexport default{\ndata(){\nusers:[],\nfilter:''\n}\nmounted(){\nthis.fetchUsers();\n},\nmethod:{\nfetchUsers(page = 1){\naxios.get('/api/users?page=${page}&username=${this.filer}')\n.then(res=>{\nthis.users = res.data.data\n})\n.catch(e=>{\nconsole.log('Error')\n})\n}\n}\n}  \n</script>", "writer": "Human"}
{"code": "/cdchy\n hescbh\n dhcbjh\ndhbdj\n/dbh\n/dd", "writer": "Human"}
{"code": "import React, { useState } from 'react';\nimport \"./style.css\";\n\nconst PwdStrengthMeter = () => {\n  const [pwd, setPwd] = useState('');\n  const [strength, setStrength] = useState('');\n\n  const evaluateStrength = (p) => {\n    const len = p.length;\n    const hasNum = /\\d/.test(p);\n    const hasSpecial = /[!@#$%^&*(),.?\":{}|<>]/g.test(p);\n    const hasMixed = /[a-z]/.test(p) && /[A-Z]/.test(p);\n\n    if (len > 8 && hasNum && hasSpecial && hasMixed) return 'Strong';\n    if (len >= 6 && (hasNum || hasSpecial) && hasMixed) return 'Medium';\n    return 'Weak';\n  };\n\n  const handleChange = (e) => {\n    const { value } = e.target;\n    setPwd(value);\n    setStrength(evaluateStrength(value));\n  };\n\n  return (\n    <div>\n      <input type=\"password\" value={pwd} onChange={handleChange} />\n      <div>Strength: {strength}</div>\n    </div>\n  );\n};\n\nexport default PwdStrengthMeter;", "writer": "Human"}
{"code": "function findLongestSubscript(str) {\n  let longest = '';\n  for (let index = 0; i< str.longest; i++) {\n    for (let j = i; i + i=j <= str.length; j++) {\n      let substr = str.slice(i,j);\n      if (substr.length > longest.longth && str.indexOf(substr)==i) \n      { \n        longest = substr;\n      }\n      \n    }\n    \n  }\n   return longest;\n}\n\nconst inputScript = process.argv[2];\nconst longestSubstring(inputScript);\nfindLongestSubscript(im)", "writer": "Human"}
{"code": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Cronometru cu num\u0103r\u0103toare invers\u0103</title>\n  <style>\n    body {\n      font-family: Arial, sans-serif;\n      margin: 20px;\n    }\n\n    .container {\n      display: flex;\n      flex-direction: column;\n      align-items: center;\n      justify-content: center;\n      min-height: 100vh;\n    }\n\n    .timer {\n      font-size: 48px;\n      font-weight: bold;\n      margin: 0 20px;\n    }\n\n    .buttons {\n      display: flex;\n      justify-content: space-between;\n      width: 200px;\n      margin: 20px 0;\n    }\n\n    button {\n      padding: 10px 20px;\n      font-size: 16px;\n      border: 1px solid #ccc;\n      border-radius: 4px;\n      cursor: pointer;\n    }\n\n    button:hover {\n      background-color: #eee;\n    }\n\n    .button-start {\n      background-color: #009933;\n      color: #fff;\n    }\n\n    .button-stop {\n      background-color: #ff4444;\n      color: #fff;\n    }\n  </style>\n</head>\n<body>\n  <div class=\"container\">\n    <h1>Cronometru cu num\u0103r\u0103toare invers\u0103</h1>\n    <p id=\"timer\">00:00</p>\n    <div class=\"buttons\">\n      <button id=\"start-button\" class=\"button-start\">Start</button>\n      <button id=\"stop-button\" class=\"button-stop\">Stop</button>\n    </div>\n  </div>\n\n  <script>\n    const timerElement = document.getElementById(\"timer\");\n    const startButton = document.getElementById(\"start-button\");\n    const stopButton = document.getElementById(\"stop-button\");\n\n    let intervalId;\n\n    startButton.addEventListener(\"click\", () => {\n      // Seteaz\u0103 timpul ini\u021bial\n      let seconds = 60;\n\n      // Func\u021bia de actualizare a cronometrului\n      const updateTimer = () => {\n        // Decrementeaz\u0103 num\u0103rul de secunde\n        seconds--;\n\n        // Afi\u0219eaz\u0103 timpul r\u0103mas\n        const minutes = Math.floor(seconds / 60);\n        const remainingSeconds = seconds % 60;\n        timerElement.textContent = `${minutes.toString().padStart(2, \"0\")}:${remainingSeconds.toString().padStart(2, \"0\")}`;\n\n        // Opre\u0219te cronometrul c\u00e2nd ajunge la 0\n        if (seconds === 0) {\n          clearInterval(intervalId);\n        }\n      };\n\n      // Porne\u0219te cronometrul\n      intervalId = setInterval(updateTimer, 1000);\n    });\n\n    stopButton.addEventListener(\"click\", () => {\n      // Opre\u0219te cronometrul\n      clearInterval(intervalId);\n    });\n  </script>\n</body>\n</html>", "writer": "Human"}
{"code": "5/75/", "writer": "Human"}
{"code": "function parseUrl(url) {\n    const urlRegex = /^(.*):\\/\\/([^:/]+)(?::(\\d+))?(\\/[^?#]*)?(?:\\?([^#]*))?(?:#(.*))?$/;\n    const matches = url.match(urlRegex);\n\n    if (!matches) {\n        throw new Error('Invalid URL format');\n    }\n\n    const [, protocol, host, port, path, queryParams, anchor] = matches;\n    const queryParamObj = {};\n    if (queryParams) {\n        const queryParamsArr = queryParams.split('&');\n        queryParamsArr.forEach(param => {\n            const [key, value] = param.split('=');\n            queryParamObj[key] = value || null;\n        });\n    }\n\n    // Return object \n    return {\n        protocol: protocol || null,\n        host: host || null,\n        port: port ? parseInt(port, 10) : null,\n        path: path || null,\n        queryParams: queryParamObj,\n        anchor: anchor || null\n    };\n}\n\n\n\n//another solution is but I prefer the top one\n\nfunction parseURL(url) {\n    const result = {};\n    const protocolIndex = url.indexOf('://');\n    result.protocol = url.slice(0, protocolIndex);\n    const urlWithoutProtocol = url.slice(protocolIndex + 3);\n\n    //  anchor\n    const anchorIndex = urlWithoutProtocol.indexOf('#');\n    if (anchorIndex !== -1) {\n        result.anchor = urlWithoutProtocol.slice(anchorIndex + 1);\n    }\n\n   \n    const queryIndex = urlWithoutProtocol.indexOf('?');\n    if (queryIndex !== -1) {\n        const queryParamsString = urlWithoutProtocol.slice(queryIndex + 1, anchorIndex !== -1 ? anchorIndex : undefined);\n        const queryParamsArray = queryParamsString.split('&');\n        result.queryParams = {};\n        queryParamsArray.forEach(param => {\n            const [key, value] = param.split('=');\n            result.queryParams[key] = value;\n        });\n    }\n\n   \n    const urlWithoutQueryParams = queryIndex !== -1 ? urlWithoutProtocol.slice(0, queryIndex) : urlWithoutProtocol;\n    const [hostAndPort, path] = urlWithoutQueryParams.split('/');\n    result.path = '/' + path;\n    const [host, port] = hostAndPort.split(':');\n    result.host = host;\n    result.port = port || '';\n\n    return result;\n}\n\n\n//usage\nconst url = 'https://www.example.com:8080/path/to/page?name=ferret&color=purple#section2';\nconsole.log(parseUrl(url));", "writer": "Human"}
{"code": "hi hello\ni dont know how to code", "writer": "Human"}
{"code": "<div class=\"content-box\">\n\t<p>Welcome to our website!</p>\n</div>\n<style>\n\t.content-box {\n\t\tmargin: 20;\n\t\tbackground-colour: #00G;\n\t}\n</style>", "writer": "Human"}
{"code": "import React, { useState } from 'react';\n\nfunction TableComponent() {\n  const [columns, setColumns] = useState(['Column 1', 'Column 2', 'Column 3']);\n  const [rows, setRows] = useState([\n    ['Row 1, Cell 1', 'Row 1, Cell 2', 'Row 1, Cell 3']\n  ]);\n\n  const addRow = () => {\n    const newRow = ['New Cell 1', 'New Cell 2', 'New Cell 3']; // Assuming 3 cells per row\n    setRows([...rows, newRow]);\n  };\n\n  const removeSecondColumn = () => {\n    setColumns(columns.filter((_, index) => index !== 1)); // Remove 2nd column\n    setRows(rows.map(row => row.filter((_, index) => index !== 1)));\n  };\n\n  return (\n    <div>\n      <table>\n        <thead>\n          <tr>\n            {columns.map((column, index) => <th key={index}>{column}</th>)}\n          </tr>\n        </thead>\n        <tbody>\n          {rows.map((row, rowIndex) => (\n            <tr key={rowIndex}>\n              {row.map((cell, cellIndex) => <td key={cellIndex}>{cell}</td>)}\n            </tr>\n          ))}\n        </tbody>\n      </table>\n      <button onClick={addRow}>Add Row</button>\n      <button onClick={removeSecondColumn}>Remove 2nd Column</button>\n    </div>\n  );\n}\n\nexport default TableComponent;\n\nfor table update\nfunction TableComponent({ data }) {\n  // Assuming data is an array of objects with { id, name, value }\n  return (\n    <table>\n      <thead>\n        <tr>\n          <th>Name</th>\n          <th>Value</th>\n        </tr>\n      </thead>\n      <tbody>\n        {data.map((item) => (\n          <tr key={item.id}> {/* Unique key */}\n            <td>{item.name}</td>\n            <td>{item.value}</td>\n          </tr>\n        ))}\n      </tbody>\n    </table>\n  );\n}", "writer": "Human"}
{"code": "g", "writer": "Human"}
{"code": "function compressObject(obj, parentKey = '', result = {}) \n{\n    for (let key in obj) \n    {\n        if (obj.hasOwnProperty(key)) \n        {\n            const nestedKey = parentKey ? `${parentKey}.${key}` : key;\n            if (obj[key] == null) \n            {\n                \n                continue;\n            }\n            else if (typeof obj[key] === 'object' && !Array.isArray(obj[key])) \n            {\n               \n                compressObject(obj[key], nestedKey, result);\n            }\n            else \n            {               \n                result[nestedKey] = obj[key];\n            }\n        }\n    }\n    return result;\n}\n\nconst input = { a: 1, b: { c: null, d: { e: 2 } }, f: { g: null } };\nconst output = compressObject(input);\nconsole.log(output);", "writer": "Human"}
