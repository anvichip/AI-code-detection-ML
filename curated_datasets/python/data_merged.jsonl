{"code": "class Solution:\n    def maxSum(self, nums: List[int]) -> int:\n        max_by_digit = defaultdict(int)\n        max_sum = -1\n\n        for num in nums:\n            digit = max(str(num))\n\n            if digit in max_by_digit:\n                max_sum = max(max_sum, max_by_digit[digit] + num)\n\n            max_by_digit[digit] = max(max_by_digit[digit], num)\n\n        return max_sum", "writer": "Human"}
{"code": "class Solution:\n    def finalString(self, s: str) -> str:\n        while \"i\" in s:\n            index=s.index(\"i\")\n\n            #first half and second half\n            first=s[:index][::-1]\n            second=s[index+1:]\n\n            s=\"\".join([first,second])\n        return s", "writer": "Human"}
{"code": "class Solution:\n  def minAbsoluteDifference(self, nums: List[int], x: int) -> int:\n    if x == 0:\n      return 0\n\n    arr, best_dist = SortedList([]), float('inf')\n    for i in range(x, len(nums)):\n      arr.add(nums[i - x])\n      v = nums[i]\n\n      pos = arr.bisect_left(v)\n      if pos < len(arr):\n        best_dist = min(best_dist, abs(arr[pos] - v))\n      if pos > 0:\n        best_dist = min(best_dist, abs(arr[pos - 1] - v))\n    \n    return best_dist", "writer": "Human"}
{"code": "class Solution:\n    def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if head.val > 4:\n            head = ListNode(0, head)\n        node = head\n        while node:\n            node.val = (node.val * 2) % 10\n            if node.next and node.next.val > 4:\n                node.val += 1\n            node = node.next\n        return head", "writer": "Human"}
{"code": "class Solution: \n    MOD = 1000000007\n\n    def maximumScore(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n\n        upper = max(nums) + 1\n\n        prime = [True]*upper\n        prime[0] = prime[1] = False\n        primeScore = [0]*upper\n        for i in range(2, upper):\n            if prime[i]:\n                for j in range(i, upper, i):\n                    primeScore[j] += 1\n                    prime[j] = False\n\n        nextGreaterElement = [n]*n\n        s = []\n        for i in range(n - 1, -1, -1):\n            while s and primeScore[nums[i]] >= primeScore[nums[s[-1]]]:\n                s.pop()\n            nextGreaterElement[i] = s[-1] if s else n\n            s.append(i)\n\n        prevGreaterOrEqualElement = [-1]*n\n        s = []\n        for i in range(n):\n            while s and primeScore[nums[i]] > primeScore[nums[s[-1]]]:\n                s.pop()\n            prevGreaterOrEqualElement[i] = s[-1] if s else -1\n            s.append(i)\n\n        res = 1\n        tuples = [[nums[i], i] for i in range(n)]\n        tuples.sort(reverse=True)\n        for num, idx in tuples:\n            operations = min((idx - prevGreaterOrEqualElement[idx]) * (nextGreaterElement[idx] - idx), k)\n            res = (res * self.pow(num, operations)) % self.MOD\n            k -= operations\n            if k == 0:\n                return res\n\n        return res\n\n    def pow(self, x: int, n: int) -> int:\n        res = 1\n        while n > 0:\n            if n % 2 == 1:\n                res = (res * x) % self.MOD\n            x = (x * x) % self.MOD\n            n //= 2\n        return res", "writer": "Human"}
{"code": "class Solution:\n    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:\n        items = sorted(items, key=lambda v: -v[0])\n        res = cur = 0\n        A = []\n        seen = set()\n        for i, (p, c) in enumerate(items):\n            if i < k:\n                if c in seen:\n                    A.append(p)\n                cur += p\n            elif c not in seen:\n                if not A: break\n                cur += p - A.pop()\n            seen.add(c)\n            res = max(res, cur + len(seen) * len(seen))\n        return res", "writer": "Human"}
{"code": "class Solution:\n    def maxSum(self, nums: List[int]) -> int:\n        max_by_digit = defaultdict(int)\n        max_sum = -1\n\n        for num in nums:\n            digit = max(str(num))\n\n            if digit in max_by_digit:\n                max_sum = max(max_sum, max_by_digit[digit] + num)\n\n            max_by_digit[digit] = max(max_by_digit[digit], num)\n\n        return max_sum", "writer": "Human"}
{"code": "class Solution:\n    def finalString(self, s: str) -> str:\n        while \"i\" in s:\n            index=s.index(\"i\")\n\n            #first half and second half\n            first=s[:index][::-1]\n            second=s[index+1:]\n\n            s=\"\".join([first,second])\n        return s", "writer": "Human"}
{"code": "class Solution:\n  def minAbsoluteDifference(self, nums: List[int], x: int) -> int:\n    if x == 0:\n      return 0\n\n    arr, best_dist = SortedList([]), float('inf')\n    for i in range(x, len(nums)):\n      arr.add(nums[i - x])\n      v = nums[i]\n\n      pos = arr.bisect_left(v)\n      if pos < len(arr):\n        best_dist = min(best_dist, abs(arr[pos] - v))\n      if pos > 0:\n        best_dist = min(best_dist, abs(arr[pos - 1] - v))\n    \n    return best_dist", "writer": "Human"}
{"code": "class Solution:\n    def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if head.val > 4:\n            head = ListNode(0, head)\n        node = head\n        while node:\n            node.val = (node.val * 2) % 10\n            if node.next and node.next.val > 4:\n                node.val += 1\n            node = node.next\n        return head", "writer": "Human"}
{"code": "class Solution: \n    MOD = 1000000007\n\n    def maximumScore(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n\n        upper = max(nums) + 1\n\n        prime = [True]*upper\n        prime[0] = prime[1] = False\n        primeScore = [0]*upper\n        for i in range(2, upper):\n            if prime[i]:\n                for j in range(i, upper, i):\n                    primeScore[j] += 1\n                    prime[j] = False\n\n        nextGreaterElement = [n]*n\n        s = []\n        for i in range(n - 1, -1, -1):\n            while s and primeScore[nums[i]] >= primeScore[nums[s[-1]]]:\n                s.pop()\n            nextGreaterElement[i] = s[-1] if s else n\n            s.append(i)\n\n        prevGreaterOrEqualElement = [-1]*n\n        s = []\n        for i in range(n):\n            while s and primeScore[nums[i]] > primeScore[nums[s[-1]]]:\n                s.pop()\n            prevGreaterOrEqualElement[i] = s[-1] if s else -1\n            s.append(i)\n\n        res = 1\n        tuples = [[nums[i], i] for i in range(n)]\n        tuples.sort(reverse=True)\n        for num, idx in tuples:\n            operations = min((idx - prevGreaterOrEqualElement[idx]) * (nextGreaterElement[idx] - idx), k)\n            res = (res * self.pow(num, operations)) % self.MOD\n            k -= operations\n            if k == 0:\n                return res\n\n        return res\n\n    def pow(self, x: int, n: int) -> int:\n        res = 1\n        while n > 0:\n            if n % 2 == 1:\n                res = (res * x) % self.MOD\n            x = (x * x) % self.MOD\n            n //= 2\n        return res", "writer": "Human"}
{"code": "class Solution:\n    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:\n        items = sorted(items, key=lambda v: -v[0])\n        res = cur = 0\n        A = []\n        seen = set()\n        for i, (p, c) in enumerate(items):\n            if i < k:\n                if c in seen:\n                    A.append(p)\n                cur += p\n            elif c not in seen:\n                if not A: break\n                cur += p - A.pop()\n            seen.add(c)\n            res = max(res, cur + len(seen) * len(seen))\n        return res", "writer": "Human"}
{"code": "class Solution:\n    def maxSum(self, nums: List[int]) -> int:\n        max_by_digit = defaultdict(int)\n        max_sum = -1\n\n        for num in nums:\n            digit = max(str(num))\n\n            if digit in max_by_digit:\n                max_sum = max(max_sum, max_by_digit[digit] + num)\n\n            max_by_digit[digit] = max(max_by_digit[digit], num)\n\n        return max_sum", "writer": "Human"}
{"code": "class Solution:\n    def finalString(self, s: str) -> str:\n        while \"i\" in s:\n            index=s.index(\"i\")\n\n            #first half and second half\n            first=s[:index][::-1]\n            second=s[index+1:]\n\n            s=\"\".join([first,second])\n        return s", "writer": "Human"}
{"code": "class Solution:\n  def minAbsoluteDifference(self, nums: List[int], x: int) -> int:\n    if x == 0:\n      return 0\n\n    arr, best_dist = SortedList([]), float('inf')\n    for i in range(x, len(nums)):\n      arr.add(nums[i - x])\n      v = nums[i]\n\n      pos = arr.bisect_left(v)\n      if pos < len(arr):\n        best_dist = min(best_dist, abs(arr[pos] - v))\n      if pos > 0:\n        best_dist = min(best_dist, abs(arr[pos - 1] - v))\n    \n    return best_dist", "writer": "Human"}
{"code": "class Solution:\n    def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if head.val > 4:\n            head = ListNode(0, head)\n        node = head\n        while node:\n            node.val = (node.val * 2) % 10\n            if node.next and node.next.val > 4:\n                node.val += 1\n            node = node.next\n        return head", "writer": "Human"}
{"code": "class Solution: \n    MOD = 1000000007\n\n    def maximumScore(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n\n        upper = max(nums) + 1\n\n        prime = [True]*upper\n        prime[0] = prime[1] = False\n        primeScore = [0]*upper\n        for i in range(2, upper):\n            if prime[i]:\n                for j in range(i, upper, i):\n                    primeScore[j] += 1\n                    prime[j] = False\n\n        nextGreaterElement = [n]*n\n        s = []\n        for i in range(n - 1, -1, -1):\n            while s and primeScore[nums[i]] >= primeScore[nums[s[-1]]]:\n                s.pop()\n            nextGreaterElement[i] = s[-1] if s else n\n            s.append(i)\n\n        prevGreaterOrEqualElement = [-1]*n\n        s = []\n        for i in range(n):\n            while s and primeScore[nums[i]] > primeScore[nums[s[-1]]]:\n                s.pop()\n            prevGreaterOrEqualElement[i] = s[-1] if s else -1\n            s.append(i)\n\n        res = 1\n        tuples = [[nums[i], i] for i in range(n)]\n        tuples.sort(reverse=True)\n        for num, idx in tuples:\n            operations = min((idx - prevGreaterOrEqualElement[idx]) * (nextGreaterElement[idx] - idx), k)\n            res = (res * self.pow(num, operations)) % self.MOD\n            k -= operations\n            if k == 0:\n                return res\n\n        return res\n\n    def pow(self, x: int, n: int) -> int:\n        res = 1\n        while n > 0:\n            if n % 2 == 1:\n                res = (res * x) % self.MOD\n            x = (x * x) % self.MOD\n            n //= 2\n        return res", "writer": "Human"}
{"code": "class Solution:\n    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:\n        items = sorted(items, key=lambda v: -v[0])\n        res = cur = 0\n        A = []\n        seen = set()\n        for i, (p, c) in enumerate(items):\n            if i < k:\n                if c in seen:\n                    A.append(p)\n                cur += p\n            elif c not in seen:\n                if not A: break\n                cur += p - A.pop()\n            seen.add(c)\n            res = max(res, cur + len(seen) * len(seen))\n        return res", "writer": "Human"}
{"code": "class Solution:\n    def maxSum(self, nums: List[int]) -> int:\n        max_by_digit = defaultdict(int)\n        max_sum = -1\n\n        for num in nums:\n            digit = max(str(num))\n\n            if digit in max_by_digit:\n                max_sum = max(max_sum, max_by_digit[digit] + num)\n\n            max_by_digit[digit] = max(max_by_digit[digit], num)\n\n        return max_sum", "writer": "Human"}
{"code": "class Solution:\n    def finalString(self, s: str) -> str:\n        while \"i\" in s:\n            index=s.index(\"i\")\n\n            #first half and second half\n            first=s[:index][::-1]\n            second=s[index+1:]\n\n            s=\"\".join([first,second])\n        return s", "writer": "Human"}
{"code": "class Solution:\n  def minAbsoluteDifference(self, nums: List[int], x: int) -> int:\n    if x == 0:\n      return 0\n\n    arr, best_dist = SortedList([]), float('inf')\n    for i in range(x, len(nums)):\n      arr.add(nums[i - x])\n      v = nums[i]\n\n      pos = arr.bisect_left(v)\n      if pos < len(arr):\n        best_dist = min(best_dist, abs(arr[pos] - v))\n      if pos > 0:\n        best_dist = min(best_dist, abs(arr[pos - 1] - v))\n    \n    return best_dist", "writer": "Human"}
{"code": "class Solution:\n    def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if head.val > 4:\n            head = ListNode(0, head)\n        node = head\n        while node:\n            node.val = (node.val * 2) % 10\n            if node.next and node.next.val > 4:\n                node.val += 1\n            node = node.next\n        return head", "writer": "Human"}
{"code": "class Solution: \n    MOD = 1000000007\n\n    def maximumScore(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n\n        upper = max(nums) + 1\n\n        prime = [True]*upper\n        prime[0] = prime[1] = False\n        primeScore = [0]*upper\n        for i in range(2, upper):\n            if prime[i]:\n                for j in range(i, upper, i):\n                    primeScore[j] += 1\n                    prime[j] = False\n\n        nextGreaterElement = [n]*n\n        s = []\n        for i in range(n - 1, -1, -1):\n            while s and primeScore[nums[i]] >= primeScore[nums[s[-1]]]:\n                s.pop()\n            nextGreaterElement[i] = s[-1] if s else n\n            s.append(i)\n\n        prevGreaterOrEqualElement = [-1]*n\n        s = []\n        for i in range(n):\n            while s and primeScore[nums[i]] > primeScore[nums[s[-1]]]:\n                s.pop()\n            prevGreaterOrEqualElement[i] = s[-1] if s else -1\n            s.append(i)\n\n        res = 1\n        tuples = [[nums[i], i] for i in range(n)]\n        tuples.sort(reverse=True)\n        for num, idx in tuples:\n            operations = min((idx - prevGreaterOrEqualElement[idx]) * (nextGreaterElement[idx] - idx), k)\n            res = (res * self.pow(num, operations)) % self.MOD\n            k -= operations\n            if k == 0:\n                return res\n\n        return res\n\n    def pow(self, x: int, n: int) -> int:\n        res = 1\n        while n > 0:\n            if n % 2 == 1:\n                res = (res * x) % self.MOD\n            x = (x * x) % self.MOD\n            n //= 2\n        return res", "writer": "Human"}
{"code": "class Solution:\n    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:\n        items = sorted(items, key=lambda v: -v[0])\n        res = cur = 0\n        A = []\n        seen = set()\n        for i, (p, c) in enumerate(items):\n            if i < k:\n                if c in seen:\n                    A.append(p)\n                cur += p\n            elif c not in seen:\n                if not A: break\n                cur += p - A.pop()\n            seen.add(c)\n            res = max(res, cur + len(seen) * len(seen))\n        return res", "writer": "Human"}
{"code": "class Solution:\n    def maxSum(self, nums: List[int]) -> int:\n        max_by_digit = defaultdict(int)\n        max_sum = -1\n\n        for num in nums:\n            digit = max(str(num))\n\n            if digit in max_by_digit:\n                max_sum = max(max_sum, max_by_digit[digit] + num)\n\n            max_by_digit[digit] = max(max_by_digit[digit], num)\n\n        return max_sum", "writer": "Human"}
{"code": "class Solution:\n    def finalString(self, s: str) -> str:\n        while \"i\" in s:\n            index=s.index(\"i\")\n\n            #first half and second half\n            first=s[:index][::-1]\n            second=s[index+1:]\n\n            s=\"\".join([first,second])\n        return s", "writer": "Human"}
{"code": "class Solution:\n  def minAbsoluteDifference(self, nums: List[int], x: int) -> int:\n    if x == 0:\n      return 0\n\n    arr, best_dist = SortedList([]), float('inf')\n    for i in range(x, len(nums)):\n      arr.add(nums[i - x])\n      v = nums[i]\n\n      pos = arr.bisect_left(v)\n      if pos < len(arr):\n        best_dist = min(best_dist, abs(arr[pos] - v))\n      if pos > 0:\n        best_dist = min(best_dist, abs(arr[pos - 1] - v))\n    \n    return best_dist", "writer": "Human"}
{"code": "class Solution:\n    def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if head.val > 4:\n            head = ListNode(0, head)\n        node = head\n        while node:\n            node.val = (node.val * 2) % 10\n            if node.next and node.next.val > 4:\n                node.val += 1\n            node = node.next\n        return head", "writer": "Human"}
{"code": "class Solution: \n    MOD = 1000000007\n\n    def maximumScore(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n\n        upper = max(nums) + 1\n\n        prime = [True]*upper\n        prime[0] = prime[1] = False\n        primeScore = [0]*upper\n        for i in range(2, upper):\n            if prime[i]:\n                for j in range(i, upper, i):\n                    primeScore[j] += 1\n                    prime[j] = False\n\n        nextGreaterElement = [n]*n\n        s = []\n        for i in range(n - 1, -1, -1):\n            while s and primeScore[nums[i]] >= primeScore[nums[s[-1]]]:\n                s.pop()\n            nextGreaterElement[i] = s[-1] if s else n\n            s.append(i)\n\n        prevGreaterOrEqualElement = [-1]*n\n        s = []\n        for i in range(n):\n            while s and primeScore[nums[i]] > primeScore[nums[s[-1]]]:\n                s.pop()\n            prevGreaterOrEqualElement[i] = s[-1] if s else -1\n            s.append(i)\n\n        res = 1\n        tuples = [[nums[i], i] for i in range(n)]\n        tuples.sort(reverse=True)\n        for num, idx in tuples:\n            operations = min((idx - prevGreaterOrEqualElement[idx]) * (nextGreaterElement[idx] - idx), k)\n            res = (res * self.pow(num, operations)) % self.MOD\n            k -= operations\n            if k == 0:\n                return res\n\n        return res\n\n    def pow(self, x: int, n: int) -> int:\n        res = 1\n        while n > 0:\n            if n % 2 == 1:\n                res = (res * x) % self.MOD\n            x = (x * x) % self.MOD\n            n //= 2\n        return res", "writer": "Human"}
{"code": "class Solution:\n    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:\n        items = sorted(items, key=lambda v: -v[0])\n        res = cur = 0\n        A = []\n        seen = set()\n        for i, (p, c) in enumerate(items):\n            if i < k:\n                if c in seen:\n                    A.append(p)\n                cur += p\n            elif c not in seen:\n                if not A: break\n                cur += p - A.pop()\n            seen.add(c)\n            res = max(res, cur + len(seen) * len(seen))\n        return res", "writer": "Human"}
{"code": "class Solution:\n    def maxSum(self, nums: List[int]) -> int:\n        max_by_digit = defaultdict(int)\n        max_sum = -1\n\n        for num in nums:\n            digit = max(str(num))\n\n            if digit in max_by_digit:\n                max_sum = max(max_sum, max_by_digit[digit] + num)\n\n            max_by_digit[digit] = max(max_by_digit[digit], num)\n\n        return max_sum", "writer": "Human"}
{"code": "class Solution:\n    def finalString(self, s: str) -> str:\n        while \"i\" in s:\n            index=s.index(\"i\")\n\n            #first half and second half\n            first=s[:index][::-1]\n            second=s[index+1:]\n\n            s=\"\".join([first,second])\n        return s", "writer": "Human"}
{"code": "class Solution:\n  def minAbsoluteDifference(self, nums: List[int], x: int) -> int:\n    if x == 0:\n      return 0\n\n    arr, best_dist = SortedList([]), float('inf')\n    for i in range(x, len(nums)):\n      arr.add(nums[i - x])\n      v = nums[i]\n\n      pos = arr.bisect_left(v)\n      if pos < len(arr):\n        best_dist = min(best_dist, abs(arr[pos] - v))\n      if pos > 0:\n        best_dist = min(best_dist, abs(arr[pos - 1] - v))\n    \n    return best_dist", "writer": "Human"}
{"code": "class Solution:\n    def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if head.val > 4:\n            head = ListNode(0, head)\n        node = head\n        while node:\n            node.val = (node.val * 2) % 10\n            if node.next and node.next.val > 4:\n                node.val += 1\n            node = node.next\n        return head", "writer": "Human"}
{"code": "class Solution: \n    MOD = 1000000007\n\n    def maximumScore(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n\n        upper = max(nums) + 1\n\n        prime = [True]*upper\n        prime[0] = prime[1] = False\n        primeScore = [0]*upper\n        for i in range(2, upper):\n            if prime[i]:\n                for j in range(i, upper, i):\n                    primeScore[j] += 1\n                    prime[j] = False\n\n        nextGreaterElement = [n]*n\n        s = []\n        for i in range(n - 1, -1, -1):\n            while s and primeScore[nums[i]] >= primeScore[nums[s[-1]]]:\n                s.pop()\n            nextGreaterElement[i] = s[-1] if s else n\n            s.append(i)\n\n        prevGreaterOrEqualElement = [-1]*n\n        s = []\n        for i in range(n):\n            while s and primeScore[nums[i]] > primeScore[nums[s[-1]]]:\n                s.pop()\n            prevGreaterOrEqualElement[i] = s[-1] if s else -1\n            s.append(i)\n\n        res = 1\n        tuples = [[nums[i], i] for i in range(n)]\n        tuples.sort(reverse=True)\n        for num, idx in tuples:\n            operations = min((idx - prevGreaterOrEqualElement[idx]) * (nextGreaterElement[idx] - idx), k)\n            res = (res * self.pow(num, operations)) % self.MOD\n            k -= operations\n            if k == 0:\n                return res\n\n        return res\n\n    def pow(self, x: int, n: int) -> int:\n        res = 1\n        while n > 0:\n            if n % 2 == 1:\n                res = (res * x) % self.MOD\n            x = (x * x) % self.MOD\n            n //= 2\n        return res", "writer": "Human"}
{"code": "class Solution:\n    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:\n        items = sorted(items, key=lambda v: -v[0])\n        res = cur = 0\n        A = []\n        seen = set()\n        for i, (p, c) in enumerate(items):\n            if i < k:\n                if c in seen:\n                    A.append(p)\n                cur += p\n            elif c not in seen:\n                if not A: break\n                cur += p - A.pop()\n            seen.add(c)\n            res = max(res, cur + len(seen) * len(seen))\n        return res", "writer": "Human"}
{"code": "class Solution:\n    def maxSum(self, nums: List[int]) -> int:\n        max_by_digit = defaultdict(int)\n        max_sum = -1\n\n        for num in nums:\n            digit = max(str(num))\n\n            if digit in max_by_digit:\n                max_sum = max(max_sum, max_by_digit[digit] + num)\n\n            max_by_digit[digit] = max(max_by_digit[digit], num)\n\n        return max_sum", "writer": "Human"}
{"code": "class Solution:\n    def finalString(self, s: str) -> str:\n        while \"i\" in s:\n            index=s.index(\"i\")\n\n            #first half and second half\n            first=s[:index][::-1]\n            second=s[index+1:]\n\n            s=\"\".join([first,second])\n        return s", "writer": "Human"}
{"code": "class Solution:\n  def minAbsoluteDifference(self, nums: List[int], x: int) -> int:\n    if x == 0:\n      return 0\n\n    arr, best_dist = SortedList([]), float('inf')\n    for i in range(x, len(nums)):\n      arr.add(nums[i - x])\n      v = nums[i]\n\n      pos = arr.bisect_left(v)\n      if pos < len(arr):\n        best_dist = min(best_dist, abs(arr[pos] - v))\n      if pos > 0:\n        best_dist = min(best_dist, abs(arr[pos - 1] - v))\n    \n    return best_dist", "writer": "Human"}
{"code": "class Solution:\n    def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if head.val > 4:\n            head = ListNode(0, head)\n        node = head\n        while node:\n            node.val = (node.val * 2) % 10\n            if node.next and node.next.val > 4:\n                node.val += 1\n            node = node.next\n        return head", "writer": "Human"}
{"code": "class Solution: \n    MOD = 1000000007\n\n    def maximumScore(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n\n        upper = max(nums) + 1\n\n        prime = [True]*upper\n        prime[0] = prime[1] = False\n        primeScore = [0]*upper\n        for i in range(2, upper):\n            if prime[i]:\n                for j in range(i, upper, i):\n                    primeScore[j] += 1\n                    prime[j] = False\n\n        nextGreaterElement = [n]*n\n        s = []\n        for i in range(n - 1, -1, -1):\n            while s and primeScore[nums[i]] >= primeScore[nums[s[-1]]]:\n                s.pop()\n            nextGreaterElement[i] = s[-1] if s else n\n            s.append(i)\n\n        prevGreaterOrEqualElement = [-1]*n\n        s = []\n        for i in range(n):\n            while s and primeScore[nums[i]] > primeScore[nums[s[-1]]]:\n                s.pop()\n            prevGreaterOrEqualElement[i] = s[-1] if s else -1\n            s.append(i)\n\n        res = 1\n        tuples = [[nums[i], i] for i in range(n)]\n        tuples.sort(reverse=True)\n        for num, idx in tuples:\n            operations = min((idx - prevGreaterOrEqualElement[idx]) * (nextGreaterElement[idx] - idx), k)\n            res = (res * self.pow(num, operations)) % self.MOD\n            k -= operations\n            if k == 0:\n                return res\n\n        return res\n\n    def pow(self, x: int, n: int) -> int:\n        res = 1\n        while n > 0:\n            if n % 2 == 1:\n                res = (res * x) % self.MOD\n            x = (x * x) % self.MOD\n            n //= 2\n        return res", "writer": "Human"}
{"code": "class Solution:\n    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:\n        items = sorted(items, key=lambda v: -v[0])\n        res = cur = 0\n        A = []\n        seen = set()\n        for i, (p, c) in enumerate(items):\n            if i < k:\n                if c in seen:\n                    A.append(p)\n                cur += p\n            elif c not in seen:\n                if not A: break\n                cur += p - A.pop()\n            seen.add(c)\n            res = max(res, cur + len(seen) * len(seen))\n        return res", "writer": "Human"}
{"code": "def is_prime(number):\n    if number <= 1:\n        return False  # 1 and all negative numbers are not prime\n\n    if number <= 3:\n        return True  # 2 and 3 are prime\n\n    if number % 2 == 0:\n        return False  # Even numbers greater than 2 are not prime\n\n    # Check for divisibility by odd numbers from 3 to the square root of the number\n    for i in range(3, int(number**0.5) + 1, 2):\n        if number % i == 0:\n            return False  # The number is divisible by 'i' and hence not prime\n\n    return True  # If no divisors were found, the number is prime\n\n# Test cases\ninput1 = 7\noutput1 = is_prime(input1)\nprint(output1)  # Output: True\n\ninput2 = 10\noutput2 = is_prime(input2)\nprint(output2)  # Output: False", "writer": "Human"}
{"code": "def avg_rating_of_books():\n  books = Books.objects.all()\n  total_rating = 0\n  for book in books:\n    total_rating += book.rating\n\n  total_books = books.count()\n  average_rating_of_books = total_rating/total_books\n  return average_rating_of_books", "writer": "Human"}
{"code": "def evenSum(numList):\n  if len(numList) == 0:\n    return 0\n  return sum(num for num in numList if num % 2 == 0)", "writer": "Human"}
{"code": "def first_non_repeated_char(string):\n    char_count = {}\n    non_repeated_chars = set()\n\n    for char in string:\n        if char in char_count:\n            non_repeated_chars.discard(char)\n        else:\n            char_count[char] = 1\n            non_repeated_chars.add(char)\n\n    for char in string:\n        if char in non_repeated_chars:\n            return char\n\n    return None\n\n# Example usage\nresult = first_non_repeated_char('abaccdeff')\nprint(result)  # Output: 'b'\n\nresult = first_non_repeated_char('abcdefggfedcba')\nprint(result)  # Output: None", "writer": "Human"}
{"code": "def move_zeroes(nums):\n  count = 0\n  for i in range(len(nums)):\n    if nums[i] != 0:\n      nums[count], nums[i]= nums[i], nums[count]\n      count += 1\n  for i in range(count, len(nums)):\n    nums[i] =0\n\ninput = [int(x) for x in input(\"Enter integers separated by spaces: \").split()]\nmove_zeroes(input)\n\nprint(input)", "writer": "Human"}
{"code": "from influxdb import InfluxDBCClient\nfrom datetime import timedelta, datetime\n\ndef calculate_percentage_change(measurement, feild, database, host = 'localhost', port = 8086, username = None, password = None):\n  try:\n    # Connect to Influx DB.\n    client = InfluxDBCClient(host, port, username, password, database)\n    \n    # Calculate the time range for the last two hours\n    end_time = datetime.utcnow()\n    start_time = end_time - timedelta(hours = 2)\n\n    # Build the Influx DB query\n    query = f'SELECT MAX(\"{field}\") FROM \"{measurement}\" WHERE time >= \\'{start_time.strftime(\"%Y-%m-%dT%H:%M:%SZ\")}\\' AND time <= \\'{end_time.strftime(\"%Y-%M-%dT%H:%M:%SZ\")}\\' GROUP BY time(1h)'\n\n    # Query InfluxDB\n    result = client.query(query)\n\n    # Extract max value for the last two hours\n    max_values = list(result.get_points())\n\n    if len(max_values)>= 2:\n      # Calculate percentage change\n      current_hour_value = max_values[-1]['max']\n      previous_hour_value = max_values[-2]['max']\n      percentage_change = ((current_hour_value-previous_hour_value) / abs(previous_hour_value)) * 100\n      return f'The percentage change in {feild} for the last hour is {percentage_change:.2f} %'\n      \n    else:\n      return f'Insufficient data to calculate percentage change.'\n\n  except Exception as e:\n    return f'Error: {str(e)}'\n    \n  finally:\n    if client:\n      client.close()", "writer": "Human"}
{"code": "from django.views.generic import ListView\n\nclass PersonListView(ListView):\n    model = Person\n    template_name = 'person_list.html'\n\n    def get_queryset(self):\n        return Person.objects.filter(birthdate__year__lte=2005)", "writer": "Human"}
{"code": "import random\n\ndef rolling():\n  rand_num = random.choice([1,2,3,4,5,6])\n  return rand_num\n\ndef prob(int(n)):\n  occurrence = dict()\n  for i in len(n):\n    num = rolling()\n    if num == 1:\n      count_1 = count_1 + 1\n    else if num == 2:\n      count_2 = count_2 + 1 \n    else if num == 3:\n      count_3 = count_3 + 1\n    else if num == 4:\n      count_4 = count_4 + 1\n    else if num == 5:\n      count_5 = count_5 + 1\n    else if num == 6:\n      count_6 = count_6 + 1\n\n    occurrence[\"count_1\"] = count_1\n    occurrence[\"count_2\"] = count_2\n    occurrence[\"count_3\"] = count_3\n    occurrence[\"count_4\"] = count_4\n    occurrence[\"count_5\"] = count_5\n    occurrence[\"count_6\"] = count_6\n    \n    return occurrence", "writer": "Human"}
{"code": "def merge_intervals(intervals):\n  if not intervals:\n    return []\n\n  intervals.sort(key =lambda x: x[0])\n  merged = [intervals[0]]\n  for i in range(1, len(intervals)):\n    current_interval = intervals[i]\n    last_merged = merged[-1]\n    if current_interval[0] <= last_merged[1]:\n      last_merged[1] = max(last_merged[1], current_interval[1])\n    else:\n      merged.append(current_interval)\n  return merged\n\n\n#testing the function with provided test cases/examples \nintervals1 = [[1,3],[2,6],[8,10],[15,18]]\nprint(merge_intervals(intervals1))\nintervals2 = [[1,4],[4,5]]\nprint(merge_intervals(intervals2))", "writer": "Human"}
{"code": "input_list = [\"appel\", \"kroket\", \"kaassouflé\", \"schoen\", \"auto\"]\ndef longest_word(input_list):\n\tlongest_word = \"\"\n\tword_count = 0\n\tfor word in input_list:\n\t\tif len(word) > word_count:\n\t\t\tlongest_word = word\n\t\t\tword_count = len(word)\n\treturn (longest_word, word_count)\nlongest_word(input_list)", "writer": "Human"}
{"code": "class Solution:\n    def maxSum(self, nums: List[int]) -> int:\n        max_digit = {}\n        for num in nums:\n            digit = max(int(d) for d in str(num))\n            if digit not in max_digit:\n                max_digit[digit] = []\n            max_digit[digit].append(num)\n        res = -1\n        for digit, values in max_digit.items():\n            if len(values) >= 2:\n                values.sort(reverse=True)\n                res = max(res, values[0] + values[1])\n        return res", "writer": "AI"}
{"code": "class Solution:\n    def finalString(self, s: str) -> str:\n        res = \"\"\n        for c in s:\n            if c == 'i':\n                res = res[::-1]\n            else:\n                res += c\n        return res", "writer": "AI"}
{"code": "class Solution:\n    def minAbsoluteDifference(self, nums: List[int], x: int) -> int:\n        n = len(nums)\n        min_diff = float('inf')\n        for i in range(n):\n            for j in range(i + x, n):\n                min_diff = min(min_diff, abs(nums[i] - nums[j]))\n        return min_diff", "writer": "AI"}
{"code": "class Solution:\n    def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        # Convert linked list to integer\n        num = 0\n        curr = head\n        while curr:\n            num = num * 10 + curr.val\n            curr = curr.next\n\n        # Double the integer\n        num *= 2\n\n        # Convert integer to linked list\n        dummy = ListNode(0)\n        curr = dummy\n        for digit in str(num):\n            curr.next = ListNode(int(digit))\n            curr = curr.next\n\n        return dummy.next", "writer": "AI"}
{"code": "class Solution:\n    def maximumScore(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        MOD = 10**9 + 7\n\n        # Precompute the prime score of all numbers in nums\n        prime_score = [0] * n\n        for i, num in enumerate(nums):\n            for j in range(2, int(sqrt(num)) + 1):\n                if num % j == 0:\n                    prime_score[i] += 1\n                    while num % j == 0:\n                        num //= j\n            if num > 1:\n                prime_score[i] += 1\n\n        # Compute the maximum score using dynamic programming\n        dp = [1]\n        for _ in range(k):\n            new_dp = [0] * (n + 1)\n            for l in range(n):\n                for r in range(l, n):\n                    max_prime_score = max(prime_score[l:r+1])\n                    max_index = prime_score[l:r+1].index(max_prime_score) + l\n                    new_dp[r+1] = max(new_dp[r+1], dp[l] * nums[max_index] % MOD)\n            dp = new_dp\n\n        return max(dp) % MOD", "writer": "AI"}
{"code": "class Solution:\n    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:\n        n = len(items)\n        items.sort(key=lambda x: (-x[0], x[1]))\n        dp = [[0, 0] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1])\n            dp[i][1] = max(dp[i - 1][0] + items[i - 1][0], dp[i - 1][1] + items[i - 1][0])\n        return max(dp[k]) + len(set([item[1] for item in items[:k]])) ** 2", "writer": "AI"}
{"code": "class Solution:\n    def maxSum(self, nums: List[int]) -> int:\n        max_digit_sum = {}  # Dictionary to store the maximum sum for each maximum digit\n        \n        for num in nums:\n            max_digit = max(str(num))  # Find the maximum digit in the current number\n            if max_digit in max_digit_sum:\n                max_digit_sum[max_digit] = max(max_digit_sum[max_digit], num)\n            else:\n                max_digit_sum[max_digit] = num\n        \n        max_sum = -1  # Initialize the maximum sum to -1\n        \n        # Iterate through the dictionary to find the maximum sum\n        for digit, num in max_digit_sum.items():\n            if max_digit_sum[digit] != num:\n                max_sum = max(max_sum, num + max_digit_sum[digit])\n        \n        return max_sum", "writer": "AI"}
{"code": "class Solution:\n    def finalString(self, s: str) -> str:\n        stack = []  # Use a stack to simulate typing process\n        \n        for char in s:\n            if char == 'i':\n                # If the character is 'i', reverse the stack\n                stack.reverse()\n            else:\n                stack.append(char)\n        \n        # Convert the stack to a string and return\n        return ''.join(stack)", "writer": "AI"}
{"code": "class Solution:\n    def minAbsoluteDifference(self, nums: List[int], x: int) -> int:\n        nums.sort()  # Sort the input array\n        \n        min_diff = float('inf')  # Initialize the minimum difference to positive infinity\n        \n        left = 0  # Initialize the left pointer\n        right = x  # Initialize the right pointer\n        \n        while right < len(nums):\n            min_diff = min(min_diff, nums[right] - nums[left])  # Update the minimum difference\n            \n            left += 1  # Move the left pointer\n            right += 1  # Move the right pointer\n        \n        return min_diff", "writer": "AI"}
{"code": "class Solution:\n    def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head:\n            return None\n        \n        carry = 0\n        current = head\n        prev = None\n        \n        # Traverse the list in reverse order and double the values\n        while current:\n            newVal = current.val * 2 + carry\n            carry = newVal // 10\n            current.val = newVal % 10\n            \n            prev = current\n            current = current.next\n        \n        # If there's a remaining carry, add a new node for it\n        if carry > 0:\n            newNode = ListNode(carry)\n            prev.next = newNode\n        \n        return self.reverseList(head)\n    \n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        current = head\n        \n        while current:\n            nextNode = current.next\n            current.next = prev\n            prev = current\n            current = nextNode\n        \n        return prev", "writer": "AI"}
{"code": "class Solution:\n    def maximumScore(self, nums: List[int], k: int) -> int:\n        def prime_score(x):\n            factors = set()\n            while x % 2 == 0:\n                factors.add(2)\n                x //= 2\n            for i in range(3, int(x ** 0.5) + 1, 2):\n                while x % i == 0:\n                    factors.add(i)\n                    x //= i\n            if x > 2:\n                factors.add(x)\n            return len(factors)\n        \n        max_score = 1\n        MOD = 10 ** 9 + 7\n        \n        pq = []  # Priority queue to store elements by their prime scores\n        \n        for num in nums:\n            heapq.heappush(pq, (-prime_score(num), num))  # Use a negative score to get the maximum prime score first\n        \n        while k > 0:\n            prime_score, num = heapq.heappop(pq)  # Pop the element with the highest prime score\n            max_score = (max_score * num) % MOD\n            k -= 1\n        \n        return max_score", "writer": "AI"}
{"code": "class Solution:\n    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:\n        n = len(items)\n        max_elegance = 0\n        \n        # Generate all possible combinations of items with size k\n        for combo in combinations(items, k):\n            total_profit = sum(item[0] for item in combo)\n            categories = [item[1] for item in combo]\n            distinct_categories = len(Counter(categories))\n            elegance = total_profit + distinct_categories ** 2\n            max_elegance = max(max_elegance, elegance)\n        \n        return max_elegance", "writer": "AI"}
{"code": "class Solution:\n    def maxSum(self, nums: List[int]) -> int:\n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if max(nums[i], nums[j]) % 10 == max(nums[i] // 10, nums[j] // 10):\n                    return max(nums[i], nums[j])\n        return -1", "writer": "AI"}
{"code": "class Solution:\n    def finalString(self, s: str) -> str:\n        res = \"\"\n        for i in s:\n            if i == \"i\":\n                res = res[::-1]\n            else:\n                res += i\n        return res", "writer": "AI"}
{"code": "class Solution:\n    def minAbsoluteDifference(self, nums: List[int], x: int) -> int:\n        nums.sort()\n        min_diff = float('inf')\n        for i in range(len(nums)):\n            if i + x < len(nums):\n                min_diff = min(min_diff, abs(nums[i] - nums[i + x]))\n        return min_diff", "writer": "AI"}
{"code": "class Solution:\n    def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if head is None:\n            return None\n        \n        head.val = head.val * 2\n        \n        if head.next is None:\n            return head\n        \n        head.next = self.doubleIt(head.next)\n        \n        if head.val > 9:\n            head.val = head.val - 10\n            head.next.val = head.next.val + 1\n            \n        return head", "writer": "AI"}
{"code": "class Solution:\n    def maximumScore(self, nums: List[int], k: int) -> int:\n        def prime_score(num):\n            prime_factors = set()\n            while num > 1:\n                for i in range(2, num + 1):\n                    if num % i == 0:\n                        prime_factors.add(i)\n                        num //= i\n                        break\n            return len(prime_factors)\n        \n        n = len(nums)\n        dp = [[0] * n for _ in range(k + 1)]\n        dp[0][0] = 1\n        for i in range(1, k + 1):\n            for j in range(1, n):\n                for k in range(j):\n                    if prime_score(nums[k]) > prime_score(nums[j]):\n                        dp[i][j] = max(dp[i][j], dp[i - 1][k] * nums[j])\n                    else:\n                        dp[i][j] = max(dp[i][j], dp[i][k] * nums[j])\n        return dp[k][n - 1] % (10 ** 9 + 7)", "writer": "AI"}
{"code": "class Solution:\n    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:\n        n = len(items)\n        profit = [0] * n\n        category = [0] * n\n        for i in range(n):\n            profit[i] = items[i][0]\n            category[i] = items[i][1]\n        profit.sort(reverse=True)\n        category.sort(reverse=True)\n        profit = profit[:k]\n        category = category[:k]\n        \n        profit_set = set(profit)\n        category_set = set(category)\n        \n        profit_sum = sum(profit)\n        category_sum = sum(category)\n        \n        return profit_sum + category_sum ** 2", "writer": "AI"}
{"code": "class Solution:\n    def maxSum(self, nums: List[int]) -> int:\n        nums.sort(reverse=True)\n        for i in range(len(nums)-1):\n            if nums[i]%10==nums[i+1]%10:\n                return nums[i]+nums[i+1]\n        return -1", "writer": "AI"}
{"code": "class Solution:\n    def finalString(self, s: str) -> str:\n        ans = \"\"\n        for i in range(len(s)):\n            if s[i] == 'i':\n                ans = ans[:-1]\n            else:\n                ans += s[i]\n        return ans", "writer": "AI"}
{"code": "class Solution:\n    def minAbsoluteDifference(self, nums: List[int], x: int) -> int:\n        nums.sort()\n        ans = float('inf')\n        for i in range(len(nums)):\n            j = bisect_left(nums, nums[i] + x)\n            if j < len(nums):\n                ans = min(ans, nums[j] - nums[i])\n            if i + 1 < len(nums):\n                ans = min(ans, nums[i + 1] - nums[i])\n        return ans", "writer": "AI"}
{"code": "class Solution:\n    def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head:\n            return head\n        if not head.next:\n            head.val *= 2\n            return head\n        prev = head\n        curr = head.next\n        while curr:\n            curr.val *= 2\n            prev = curr\n            curr = curr.next\n        prev.val *= 2\n        return head", "writer": "AI"}
{"code": "class Solution:\n    def maximumScore(self, nums: List[int], k: int) -> int:\n        def prime(n):\n            if n == 1:\n                return False\n            for i in range(2, int(n**0.5)+1):\n                if n % i == 0:\n                    return False\n            return True\n        ans = 1\n        for i in range(k, -1, -1):\n            if prime(nums[i]):\n                ans *= nums[i]\n        for i in range(k+1, len(nums)):\n            if prime(nums[i]):\n                ans *= nums[i]\n        return ans % (10**9 + 7)", "writer": "AI"}
{"code": "class Solution:\n    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:\n        items.sort(key = lambda x: x[1])\n        ans = 0\n        for i in range(k):\n            ans += items[i][0]\n        return ans + (k * (k - 1) // 2) * items[k - 1][1]", "writer": "AI"}
{"code": "class Solution:\n    def maxSum(self, nums: List[int]) -> int:\n        maxSum = -1\n        maxDigit = [0] * 10\n        for num in nums:\n            maxDigit[int(str(num)[0])] = max(maxDigit[int(str(num)[0])], num)\n        for i in range(10):\n            \n            for j in range(i, 10):\n                if maxDigit[i] and maxDigit[j]:\n                    maxSum = max(maxSum, maxDigit[i] + maxDigit[j])\n        return maxSum", "writer": "AI"}
{"code": "class Solution:\n    def finalString(self, s: str) -> str:\n        stack = []\n        for i in range(len(s)):\n            if s[i] == 'i':\n                stack.reverse()\n            else:\n                stack.append(s[i])\n        return \"\".join(stack)", "writer": "AI"}
{"code": "class Solution:\n    def minAbsoluteDifference(self, nums: List[int], x: int) -> int:\n        nums.sort()\n        n = len(nums)\n        res = float('inf')\n        for i in range(n):\n            j = bisect_left(nums, nums[i] - x, i + 1)\n            if j < n:\n                res = min(res, abs(nums[i] - nums[j] + x))\n            if j > i + 1:\n                res = min(res, abs(nums[i] - nums[j - 1] + x))\n        return res", "writer": "AI"}
{"code": "class Solution:\n    def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if head is None:\n            return None\n        if head.next is None:\n            head.val = head.val * 2\n            return head\n        node = head\n        while node:\n            node.val = node.val * 2\n            node = node.next\n        node = head\n        while node:\n            if node.val > 9:\n                node.val = node.val % 10\n                if node.next is None:\n                    node.next = ListNode(1)\n                else:\n                    node.next.val += 1\n            node = node.next\n        return head", "writer": "AI"}
{"code": "class Solution:\n    def maximumScore(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        left, right = k, k\n        res = nums[k]\n        min_val = nums[k]\n        while left > 0 or right < n - 1:\n            if left == 0:\n                right += 1\n            elif right == n - 1:\n                left -= 1\n            elif nums[left - 1] < nums[right + 1]:\n                right += 1\n            else:\n                left -= 1\n            min_val = min(min_val, nums[left], nums[right])\n            res = max(res, min_val * (right - left + 1))\n        return res", "writer": "AI"}
{"code": "class Solution:\n    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:\n        items.sort(key = lambda x: x[0], reverse = True)\n        category = {}\n        for i in range(len(items)):\n            if items[i][1] not in category:\n                category[items[i][1]] = 1\n            else:\n                category[items[i][1]] += 1\n        category = sorted(category.items(), key = lambda x: x[1], reverse = True)\n        ans = 0\n        for i in range(k):\n            ans += items[i][0]\n        ans += len(category) ** 2\n        return ans", "writer": "AI"}
{"code": "class Solution:    \n    def maxSum (self, nums: List[int]) -> int:\n        \n        nums.sort()\n        \n        max_sum = 0\n        \n        for i in range(len(nums)-1):\n            if nums[i] == nums[i+1]:\n                max_sum = max(max_sum, nums[i]*(len(nums)-i-1))\n                \n        return max_sum", "writer": "AI"}
{"code": "class Solution:\n    def finalString(self, s: str) -> str:\n        res = \"\"\n        for i in s:\n            if i!= 'i':\n                res += i\n            else:\n                res = res[::-1]\n        return res", "writer": "AI"}
{"code": "class Solution:\n    def minAbsoluteDifference(self, nums: List[int], x: int) -> int:\n        nums.sort()\n        res = float('inf')\n        for i in range(len(nums)-1):\n            res = min(res, abs(nums[i]-nums[i+1]))\n        return res", "writer": "AI"}
{"code": "class Solution:\n    def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head:\n            return head\n        \n        curr = head\n        while curr:\n            curr.val *= 2\n            curr = curr.next\n        return head", "writer": "AI"}
{"code": "class Solution:    \n    def maximumScore(self, nums: List[int], k: int) -> int:\n        \n        n = len(nums)\n        \n        @lru_cache(None)\n        def dp(l, r, k):\n            if k == 0:\n                return 0\n            if l > r:\n                return 0\n            if l == r:\n                return nums[l]\n            \n            res = 0\n            for i in range(l, r + 1):\n                if i == l:\n                    res = max(res, dp(l + 1, r, k - 1))\n                elif i == r:\n                    res = max(res, dp(l, r - 1, k - 1))\n                else:\n                    res = max(res, dp(l + 1, r, k - 1) + nums[i] * nums[i])\n                    res = max(res, dp(l, r - 1, k - 1) + nums[i] * nums[i])\n            return res % (10**9 + 7)\n        \n        return dp(0, n - 1, k)", "writer": "AI"}
{"code": "class Solution:    \n    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:\n        \n        @lru_cache(None)\n        def dp(i, k):\n            if k == 0:\n                return 0\n            if i == len(items):\n                return float('-inf')\n            return max(dp(i + 1, k), items[i][0] + dp(i + 1, k - 1))\n        \n        return dp(0, k)", "writer": "AI"}
{"code": "class Solution:\n    def maxSum(self, nums: List[int]) -> int:\n        if len(nums) == 1:\n            return nums[0]\n        if len(nums) == 2:\n            return max(nums)\n        max_sum = 0\n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if nums[i] % 10 == nums[j] % 10:\n                    max_sum = max(max_sum, nums[i] + nums[j])\n        return max_sum if max_sum > 0 else -1", "writer": "AI"}
{"code": "class Solution:\n    def finalString(self, s: str) -> str:\n        s = list(s)\n        for i in range(len(s)):\n            if s[i] == 'i':\n                s[i] = 'o'\n            else:\n                s[i] = 'i'\n        return ''.join(s)", "writer": "AI"}
{"code": "class Solution:\n    def minAbsoluteDifference(self, nums: List[int], x: int) -> int:\n        nums.sort()\n        n = len(nums)\n        ans = float('inf')\n        for i in range(n):\n            for j in range(i+1, n):\n                if abs(nums[i] - nums[j]) < ans:\n                    ans = abs(nums[i] - nums[j])\n                if abs(nums[i] - nums[j]) == ans and abs(nums[i] - x) < abs(nums[j] - x):\n                    ans = abs(nums[i] - x)\n        return ans", "writer": "AI"}
{"code": "class Solution:\n    def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if head is None:\n            return None\n        temp = head\n        while temp is not None:\n            temp.val *= 2\n            temp = temp.next\n        return head", "writer": "AI"}
{"code": "class Solution:\n    def maximumScore(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        dp = [0]*n\n        dp[0] = nums[0]\n        for i in range(1, n):\n            dp[i] = max(dp[i-1], nums[i])\n        ans = dp[k-1]\n        for i in range(k-1, n):\n            ans = max(ans, dp[i] * dp[k-1-i])\n        return ans % (10**9 + 7)", "writer": "AI"}
{"code": "class Solution:\n    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:\n        n = len(items)\n        dp = [[0]*n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = items[i][0]\n        for l in range(2, n+1):\n            for i in range(n-l+1):\n                j = i+l-1\n                dp[i][j] = max(dp[i][j-1], dp[i+1][j]) + items[j][0]\n        return max(dp[0][k-1], dp[n-k][n-1])", "writer": "AI"}
{"code": "def is_prime(num):\n    # Handle special cases\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    \n    # Check for even numbers and multiples of 3\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    \n    # Use the 6k +/- 1 rule to check for factors up to the square root of num\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n        \n    return True\n\n# Example usage\nprint(is_prime(7))  # Output: True\nprint(is_prime(10)) # Output: False\n", "writer": "AI"}
{"code": "def average_rating(books):\n    # Ensure that there is at least one book to calculate the average\n    if not books:\n        return 0\n\n    total_rating = 0\n    book_count = 0\n\n    # Summing up all ratings and counting books\n    for book in books:\n        total_rating += book.rating\n        book_count += 1\n\n    # Calculating the average rating\n    if book_count == 0:\n        return 0\n\n    return total_rating / book_count\n", "writer": "AI"}
{"code": "def sum_of_evens(numbers):\n    # Sum all even numbers in the input list\n    return sum(num for num in numbers if num % 2 == 0)\n", "writer": "AI"}
{"code": "def first_non_repeated_char(s):\n    # Dictionary to store count of each character\n    char_count = {}\n    \n    # Count each character in the string\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    # Find the first character with a count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n\n    # Return None if no non-repeated character is found\n    return None\n", "writer": "AI"}
{"code": "def move_zeros_to_end(nums):\n    # Index to place the next non-zero element\n    position = 0\n\n    # First pass to handle all non-zero elements\n    for num in nums:\n        if num != 0:\n            nums[position] = num\n            position += 1\n\n    # Fill the rest of the array with zeros\n    for i in range(position, len(nums)):\n        nums[i] = 0\n\n# Example usage:\nnums1 = [0, 1, 0, 3, 12]\nmove_zeros_to_end(nums1)\nprint(nums1)  # Output: [1, 3, 12, 0, 0]\n\nnums2 = [0, 0, 1]\nmove_zeros_to_end(nums2)\nprint(nums2)  # Output: [1, 0, 0]\n", "writer": "AI"}
{"code": "import influxdb\nimport datetime\n\ndef get_percentage_change(measurement, field, database_url='http://localhost:8086', database_name='example_db'):\n    # Create a client and connect to the InfluxDB instance\n    client = influxdb.InfluxDBClient(host=database_url, port=8086)\n    \n    try:\n        # Connect to the specified database\n        client.switch_database(database_name)\n        \n        # Calculate the time range for the last two hours\n        end_time = datetime.datetime.utcnow()\n        start_time = end_time - datetime.timedelta(hours=2)\n        \n        # Query for maximum value of the given field from the specified measurement over the last two one-hour periods\n        query = f\"\"\"\n        SELECT MAX(\"{field}\") FROM \"{measurement}\"\n        WHERE time >= '{start_time.isoformat()}Z' AND time < '{end_time.isoformat()}Z'\n        GROUP BY time(1h) fill(none)\n        \"\"\"\n        \n        # Execute the query\n        results = client.query(query)\n        \n        # Extract the maximum values from the query results\n        max_values = list(results.get_points())\n\n        if len(max_values) != 2:\n            return \"Insufficient data for calculation\"\n        \n        # Obtain the maximum values for the last two hours\n        max_prev_hour = max_values[0]['max']\n        max_last_hour = max_values[1]['max']\n        \n        # Calculate the percentage change between the two hours\n        if max_prev_hour is None or max_last_hour is None:\n            return \"Insufficient data for calculation\"\n        \n        percentage_change = ((max_last_hour - max_prev_hour) / max_prev_hour) * 100 if max_prev_hour != 0 else float('inf')\n        \n        return f\"The percentage change in {field} for the last hour is {percentage_change:.2f}%\"\n    \n    except influxdb.exceptions.InfluxDBClientError as e:\n        return f\"Database error: {str(e)}\"\n    \n    except Exception as e:\n        return f\"An error occurred: {str(e)}\"\n    \n    finally:\n        client.close()\n\n# Example usage (uncomment to test in a real environment):\n# print(get_percentage_change('stock_prices', 'closing_price', 'http://localhost:8086', 'financial_data'))\n", "writer": "AI"}
{"code": "from django.db.models import Q\n\ndef get_customers_by_zip_prefix():\n    # Query Customer models where the zip_code starts with '123'\n    customers = Customer.objects.filter(zip_code__startswith='123')\n    \n    # Convert the QuerySet to a list of dictionaries\n    customer_list = list(customers.values())\n    \n    return customer_list\n", "writer": "AI"}
{"code": "import random\n\ndef roll_die():\n    \"\"\"Simulate rolling a six-sided die using random.randint.\"\"\"\n    return random.randint(1, 6)\n\ndef roll_die_n_times(n):\n    \"\"\"Simulate rolling a six-sided die n times and return a count of each result.\"\"\"\n    results = {1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0}\n    for _ in range(n):\n        result = roll_die()\n        results[result] += 1\n    return results\n", "writer": "AI"}
{"code": "def merge_intervals(intervals):\n    # Sort the list of intervals by their start values\n    intervals.sort(key=lambda x: x[0])\n    \n    merged = []\n    \n    for interval in intervals:\n        # If the list of merged intervals is empty or if the current interval does not overlap with the previous one\n        if not merged or merged[-1][1] < interval[0]:\n            merged.append(interval)\n        else:\n            # There is overlap, merge the current interval with the previous one\n            merged[-1][1] = max(merged[-1][1], interval[1])\n    \n    return merged\n", "writer": "AI"}
{"code": "def find_longest_word(word_list):\n    # Initialize the default variable for the longest word and its length\n    longest_word = ''\n    max_length = 0\n    \n    # Loop through each word in the list\n    for word in word_list:\n        # Check if the current word's length is greater than the max length found so far\n        if len(word) > max_length:\n            longest_word = word\n            max_length = len(word)\n    \n    # Return the longest word and its length as a tuple\n    return (longest_word, max_length)\n", "writer": "AI"}
