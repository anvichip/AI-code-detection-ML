{"code": "class Solution:\n    def maxSum(self, nums: List[int]) -> int:\n        max_digit = {}\n        for num in nums:\n            digit = max(int(d) for d in str(num))\n            if digit not in max_digit:\n                max_digit[digit] = []\n            max_digit[digit].append(num)\n        res = -1\n        for digit, values in max_digit.items():\n            if len(values) >= 2:\n                values.sort(reverse=True)\n                res = max(res, values[0] + values[1])\n        return res", "writer": "AI"}
{"code": "class Solution:\n    def maxSum(self, nums: List[int]) -> int:\n        max_by_digit = defaultdict(int)\n        max_sum = -1\n\n        for num in nums:\n            digit = max(str(num))\n\n            if digit in max_by_digit:\n                max_sum = max(max_sum, max_by_digit[digit] + num)\n\n            max_by_digit[digit] = max(max_by_digit[digit], num)\n\n        return max_sum", "writer": "Human"}
{"code": "class Solution:\n    def finalString(self, s: str) -> str:\n        res = \"\"\n        for c in s:\n            if c == 'i':\n                res = res[::-1]\n            else:\n                res += c\n        return res", "writer": "AI"}
{"code": "class Solution:\n    def finalString(self, s: str) -> str:\n        while \"i\" in s:\n            index=s.index(\"i\")\n\n            #first half and second half\n            first=s[:index][::-1]\n            second=s[index+1:]\n\n            s=\"\".join([first,second])\n        return s", "writer": "Human"}
{"code": "class Solution:\n    def minAbsoluteDifference(self, nums: List[int], x: int) -> int:\n        n = len(nums)\n        min_diff = float('inf')\n        for i in range(n):\n            for j in range(i + x, n):\n                min_diff = min(min_diff, abs(nums[i] - nums[j]))\n        return min_diff", "writer": "AI"}
{"code": "class Solution:\n  def minAbsoluteDifference(self, nums: List[int], x: int) -> int:\n    if x == 0:\n      return 0\n\n    arr, best_dist = SortedList([]), float('inf')\n    for i in range(x, len(nums)):\n      arr.add(nums[i - x])\n      v = nums[i]\n\n      pos = arr.bisect_left(v)\n      if pos < len(arr):\n        best_dist = min(best_dist, abs(arr[pos] - v))\n      if pos > 0:\n        best_dist = min(best_dist, abs(arr[pos - 1] - v))\n    \n    return best_dist", "writer": "Human"}
{"code": "class Solution:\n    def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        # Convert linked list to integer\n        num = 0\n        curr = head\n        while curr:\n            num = num * 10 + curr.val\n            curr = curr.next\n\n        # Double the integer\n        num *= 2\n\n        # Convert integer to linked list\n        dummy = ListNode(0)\n        curr = dummy\n        for digit in str(num):\n            curr.next = ListNode(int(digit))\n            curr = curr.next\n\n        return dummy.next", "writer": "AI"}
{"code": "class Solution:\n    def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if head.val > 4:\n            head = ListNode(0, head)\n        node = head\n        while node:\n            node.val = (node.val * 2) % 10\n            if node.next and node.next.val > 4:\n                node.val += 1\n            node = node.next\n        return head", "writer": "Human"}
{"code": "class Solution:\n    def maximumScore(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        MOD = 10**9 + 7\n\n        # Precompute the prime score of all numbers in nums\n        prime_score = [0] * n\n        for i, num in enumerate(nums):\n            for j in range(2, int(sqrt(num)) + 1):\n                if num % j == 0:\n                    prime_score[i] += 1\n                    while num % j == 0:\n                        num //= j\n            if num > 1:\n                prime_score[i] += 1\n\n        # Compute the maximum score using dynamic programming\n        dp = [1]\n        for _ in range(k):\n            new_dp = [0] * (n + 1)\n            for l in range(n):\n                for r in range(l, n):\n                    max_prime_score = max(prime_score[l:r+1])\n                    max_index = prime_score[l:r+1].index(max_prime_score) + l\n                    new_dp[r+1] = max(new_dp[r+1], dp[l] * nums[max_index] % MOD)\n            dp = new_dp\n\n        return max(dp) % MOD", "writer": "AI"}
{"code": "class Solution: \n    MOD = 1000000007\n\n    def maximumScore(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n\n        upper = max(nums) + 1\n\n        prime = [True]*upper\n        prime[0] = prime[1] = False\n        primeScore = [0]*upper\n        for i in range(2, upper):\n            if prime[i]:\n                for j in range(i, upper, i):\n                    primeScore[j] += 1\n                    prime[j] = False\n\n        nextGreaterElement = [n]*n\n        s = []\n        for i in range(n - 1, -1, -1):\n            while s and primeScore[nums[i]] >= primeScore[nums[s[-1]]]:\n                s.pop()\n            nextGreaterElement[i] = s[-1] if s else n\n            s.append(i)\n\n        prevGreaterOrEqualElement = [-1]*n\n        s = []\n        for i in range(n):\n            while s and primeScore[nums[i]] > primeScore[nums[s[-1]]]:\n                s.pop()\n            prevGreaterOrEqualElement[i] = s[-1] if s else -1\n            s.append(i)\n\n        res = 1\n        tuples = [[nums[i], i] for i in range(n)]\n        tuples.sort(reverse=True)\n        for num, idx in tuples:\n            operations = min((idx - prevGreaterOrEqualElement[idx]) * (nextGreaterElement[idx] - idx), k)\n            res = (res * self.pow(num, operations)) % self.MOD\n            k -= operations\n            if k == 0:\n                return res\n\n        return res\n\n    def pow(self, x: int, n: int) -> int:\n        res = 1\n        while n > 0:\n            if n % 2 == 1:\n                res = (res * x) % self.MOD\n            x = (x * x) % self.MOD\n            n //= 2\n        return res", "writer": "Human"}
{"code": "class Solution:\n    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:\n        n = len(items)\n        items.sort(key=lambda x: (-x[0], x[1]))\n        dp = [[0, 0] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1])\n            dp[i][1] = max(dp[i - 1][0] + items[i - 1][0], dp[i - 1][1] + items[i - 1][0])\n        return max(dp[k]) + len(set([item[1] for item in items[:k]])) ** 2", "writer": "AI"}
{"code": "class Solution:\n    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:\n        items = sorted(items, key=lambda v: -v[0])\n        res = cur = 0\n        A = []\n        seen = set()\n        for i, (p, c) in enumerate(items):\n            if i < k:\n                if c in seen:\n                    A.append(p)\n                cur += p\n            elif c not in seen:\n                if not A: break\n                cur += p - A.pop()\n            seen.add(c)\n            res = max(res, cur + len(seen) * len(seen))\n        return res", "writer": "Human"}
{"code": "class Solution:\n    def maxSum(self, nums: List[int]) -> int:\n        max_digit_sum = {}  # Dictionary to store the maximum sum for each maximum digit\n        \n        for num in nums:\n            max_digit = max(str(num))  # Find the maximum digit in the current number\n            if max_digit in max_digit_sum:\n                max_digit_sum[max_digit] = max(max_digit_sum[max_digit], num)\n            else:\n                max_digit_sum[max_digit] = num\n        \n        max_sum = -1  # Initialize the maximum sum to -1\n        \n        # Iterate through the dictionary to find the maximum sum\n        for digit, num in max_digit_sum.items():\n            if max_digit_sum[digit] != num:\n                max_sum = max(max_sum, num + max_digit_sum[digit])\n        \n        return max_sum", "writer": "AI"}
{"code": "class Solution:\n    def maxSum(self, nums: List[int]) -> int:\n        max_by_digit = defaultdict(int)\n        max_sum = -1\n\n        for num in nums:\n            digit = max(str(num))\n\n            if digit in max_by_digit:\n                max_sum = max(max_sum, max_by_digit[digit] + num)\n\n            max_by_digit[digit] = max(max_by_digit[digit], num)\n\n        return max_sum", "writer": "Human"}
{"code": "class Solution:\n    def finalString(self, s: str) -> str:\n        stack = []  # Use a stack to simulate typing process\n        \n        for char in s:\n            if char == 'i':\n                # If the character is 'i', reverse the stack\n                stack.reverse()\n            else:\n                stack.append(char)\n        \n        # Convert the stack to a string and return\n        return ''.join(stack)", "writer": "AI"}
{"code": "class Solution:\n    def finalString(self, s: str) -> str:\n        while \"i\" in s:\n            index=s.index(\"i\")\n\n            #first half and second half\n            first=s[:index][::-1]\n            second=s[index+1:]\n\n            s=\"\".join([first,second])\n        return s", "writer": "Human"}
{"code": "class Solution:\n    def minAbsoluteDifference(self, nums: List[int], x: int) -> int:\n        nums.sort()  # Sort the input array\n        \n        min_diff = float('inf')  # Initialize the minimum difference to positive infinity\n        \n        left = 0  # Initialize the left pointer\n        right = x  # Initialize the right pointer\n        \n        while right < len(nums):\n            min_diff = min(min_diff, nums[right] - nums[left])  # Update the minimum difference\n            \n            left += 1  # Move the left pointer\n            right += 1  # Move the right pointer\n        \n        return min_diff", "writer": "AI"}
{"code": "class Solution:\n  def minAbsoluteDifference(self, nums: List[int], x: int) -> int:\n    if x == 0:\n      return 0\n\n    arr, best_dist = SortedList([]), float('inf')\n    for i in range(x, len(nums)):\n      arr.add(nums[i - x])\n      v = nums[i]\n\n      pos = arr.bisect_left(v)\n      if pos < len(arr):\n        best_dist = min(best_dist, abs(arr[pos] - v))\n      if pos > 0:\n        best_dist = min(best_dist, abs(arr[pos - 1] - v))\n    \n    return best_dist", "writer": "Human"}
{"code": "class Solution:\n    def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head:\n            return None\n        \n        carry = 0\n        current = head\n        prev = None\n        \n        # Traverse the list in reverse order and double the values\n        while current:\n            newVal = current.val * 2 + carry\n            carry = newVal // 10\n            current.val = newVal % 10\n            \n            prev = current\n            current = current.next\n        \n        # If there's a remaining carry, add a new node for it\n        if carry > 0:\n            newNode = ListNode(carry)\n            prev.next = newNode\n        \n        return self.reverseList(head)\n    \n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        current = head\n        \n        while current:\n            nextNode = current.next\n            current.next = prev\n            prev = current\n            current = nextNode\n        \n        return prev", "writer": "AI"}
{"code": "class Solution:\n    def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if head.val > 4:\n            head = ListNode(0, head)\n        node = head\n        while node:\n            node.val = (node.val * 2) % 10\n            if node.next and node.next.val > 4:\n                node.val += 1\n            node = node.next\n        return head", "writer": "Human"}
{"code": "class Solution:\n    def maximumScore(self, nums: List[int], k: int) -> int:\n        def prime_score(x):\n            factors = set()\n            while x % 2 == 0:\n                factors.add(2)\n                x //= 2\n            for i in range(3, int(x ** 0.5) + 1, 2):\n                while x % i == 0:\n                    factors.add(i)\n                    x //= i\n            if x > 2:\n                factors.add(x)\n            return len(factors)\n        \n        max_score = 1\n        MOD = 10 ** 9 + 7\n        \n        pq = []  # Priority queue to store elements by their prime scores\n        \n        for num in nums:\n            heapq.heappush(pq, (-prime_score(num), num))  # Use a negative score to get the maximum prime score first\n        \n        while k > 0:\n            prime_score, num = heapq.heappop(pq)  # Pop the element with the highest prime score\n            max_score = (max_score * num) % MOD\n            k -= 1\n        \n        return max_score", "writer": "AI"}
{"code": "class Solution: \n    MOD = 1000000007\n\n    def maximumScore(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n\n        upper = max(nums) + 1\n\n        prime = [True]*upper\n        prime[0] = prime[1] = False\n        primeScore = [0]*upper\n        for i in range(2, upper):\n            if prime[i]:\n                for j in range(i, upper, i):\n                    primeScore[j] += 1\n                    prime[j] = False\n\n        nextGreaterElement = [n]*n\n        s = []\n        for i in range(n - 1, -1, -1):\n            while s and primeScore[nums[i]] >= primeScore[nums[s[-1]]]:\n                s.pop()\n            nextGreaterElement[i] = s[-1] if s else n\n            s.append(i)\n\n        prevGreaterOrEqualElement = [-1]*n\n        s = []\n        for i in range(n):\n            while s and primeScore[nums[i]] > primeScore[nums[s[-1]]]:\n                s.pop()\n            prevGreaterOrEqualElement[i] = s[-1] if s else -1\n            s.append(i)\n\n        res = 1\n        tuples = [[nums[i], i] for i in range(n)]\n        tuples.sort(reverse=True)\n        for num, idx in tuples:\n            operations = min((idx - prevGreaterOrEqualElement[idx]) * (nextGreaterElement[idx] - idx), k)\n            res = (res * self.pow(num, operations)) % self.MOD\n            k -= operations\n            if k == 0:\n                return res\n\n        return res\n\n    def pow(self, x: int, n: int) -> int:\n        res = 1\n        while n > 0:\n            if n % 2 == 1:\n                res = (res * x) % self.MOD\n            x = (x * x) % self.MOD\n            n //= 2\n        return res", "writer": "Human"}
{"code": "class Solution:\n    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:\n        n = len(items)\n        max_elegance = 0\n        \n        # Generate all possible combinations of items with size k\n        for combo in combinations(items, k):\n            total_profit = sum(item[0] for item in combo)\n            categories = [item[1] for item in combo]\n            distinct_categories = len(Counter(categories))\n            elegance = total_profit + distinct_categories ** 2\n            max_elegance = max(max_elegance, elegance)\n        \n        return max_elegance", "writer": "AI"}
{"code": "class Solution:\n    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:\n        items = sorted(items, key=lambda v: -v[0])\n        res = cur = 0\n        A = []\n        seen = set()\n        for i, (p, c) in enumerate(items):\n            if i < k:\n                if c in seen:\n                    A.append(p)\n                cur += p\n            elif c not in seen:\n                if not A: break\n                cur += p - A.pop()\n            seen.add(c)\n            res = max(res, cur + len(seen) * len(seen))\n        return res", "writer": "Human"}
{"code": "class Solution:\n    def maxSum(self, nums: List[int]) -> int:\n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if max(nums[i], nums[j]) % 10 == max(nums[i] // 10, nums[j] // 10):\n                    return max(nums[i], nums[j])\n        return -1", "writer": "AI"}
{"code": "class Solution:\n    def maxSum(self, nums: List[int]) -> int:\n        max_by_digit = defaultdict(int)\n        max_sum = -1\n\n        for num in nums:\n            digit = max(str(num))\n\n            if digit in max_by_digit:\n                max_sum = max(max_sum, max_by_digit[digit] + num)\n\n            max_by_digit[digit] = max(max_by_digit[digit], num)\n\n        return max_sum", "writer": "Human"}
{"code": "class Solution:\n    def finalString(self, s: str) -> str:\n        res = \"\"\n        for i in s:\n            if i == \"i\":\n                res = res[::-1]\n            else:\n                res += i\n        return res", "writer": "AI"}
{"code": "class Solution:\n    def finalString(self, s: str) -> str:\n        while \"i\" in s:\n            index=s.index(\"i\")\n\n            #first half and second half\n            first=s[:index][::-1]\n            second=s[index+1:]\n\n            s=\"\".join([first,second])\n        return s", "writer": "Human"}
{"code": "class Solution:\n    def minAbsoluteDifference(self, nums: List[int], x: int) -> int:\n        nums.sort()\n        min_diff = float('inf')\n        for i in range(len(nums)):\n            if i + x < len(nums):\n                min_diff = min(min_diff, abs(nums[i] - nums[i + x]))\n        return min_diff", "writer": "AI"}
{"code": "class Solution:\n  def minAbsoluteDifference(self, nums: List[int], x: int) -> int:\n    if x == 0:\n      return 0\n\n    arr, best_dist = SortedList([]), float('inf')\n    for i in range(x, len(nums)):\n      arr.add(nums[i - x])\n      v = nums[i]\n\n      pos = arr.bisect_left(v)\n      if pos < len(arr):\n        best_dist = min(best_dist, abs(arr[pos] - v))\n      if pos > 0:\n        best_dist = min(best_dist, abs(arr[pos - 1] - v))\n    \n    return best_dist", "writer": "Human"}
{"code": "class Solution:\n    def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if head is None:\n            return None\n        \n        head.val = head.val * 2\n        \n        if head.next is None:\n            return head\n        \n        head.next = self.doubleIt(head.next)\n        \n        if head.val > 9:\n            head.val = head.val - 10\n            head.next.val = head.next.val + 1\n            \n        return head", "writer": "AI"}
{"code": "class Solution:\n    def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if head.val > 4:\n            head = ListNode(0, head)\n        node = head\n        while node:\n            node.val = (node.val * 2) % 10\n            if node.next and node.next.val > 4:\n                node.val += 1\n            node = node.next\n        return head", "writer": "Human"}
{"code": "class Solution:\n    def maximumScore(self, nums: List[int], k: int) -> int:\n        def prime_score(num):\n            prime_factors = set()\n            while num > 1:\n                for i in range(2, num + 1):\n                    if num % i == 0:\n                        prime_factors.add(i)\n                        num //= i\n                        break\n            return len(prime_factors)\n        \n        n = len(nums)\n        dp = [[0] * n for _ in range(k + 1)]\n        dp[0][0] = 1\n        for i in range(1, k + 1):\n            for j in range(1, n):\n                for k in range(j):\n                    if prime_score(nums[k]) > prime_score(nums[j]):\n                        dp[i][j] = max(dp[i][j], dp[i - 1][k] * nums[j])\n                    else:\n                        dp[i][j] = max(dp[i][j], dp[i][k] * nums[j])\n        return dp[k][n - 1] % (10 ** 9 + 7)", "writer": "AI"}
{"code": "class Solution: \n    MOD = 1000000007\n\n    def maximumScore(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n\n        upper = max(nums) + 1\n\n        prime = [True]*upper\n        prime[0] = prime[1] = False\n        primeScore = [0]*upper\n        for i in range(2, upper):\n            if prime[i]:\n                for j in range(i, upper, i):\n                    primeScore[j] += 1\n                    prime[j] = False\n\n        nextGreaterElement = [n]*n\n        s = []\n        for i in range(n - 1, -1, -1):\n            while s and primeScore[nums[i]] >= primeScore[nums[s[-1]]]:\n                s.pop()\n            nextGreaterElement[i] = s[-1] if s else n\n            s.append(i)\n\n        prevGreaterOrEqualElement = [-1]*n\n        s = []\n        for i in range(n):\n            while s and primeScore[nums[i]] > primeScore[nums[s[-1]]]:\n                s.pop()\n            prevGreaterOrEqualElement[i] = s[-1] if s else -1\n            s.append(i)\n\n        res = 1\n        tuples = [[nums[i], i] for i in range(n)]\n        tuples.sort(reverse=True)\n        for num, idx in tuples:\n            operations = min((idx - prevGreaterOrEqualElement[idx]) * (nextGreaterElement[idx] - idx), k)\n            res = (res * self.pow(num, operations)) % self.MOD\n            k -= operations\n            if k == 0:\n                return res\n\n        return res\n\n    def pow(self, x: int, n: int) -> int:\n        res = 1\n        while n > 0:\n            if n % 2 == 1:\n                res = (res * x) % self.MOD\n            x = (x * x) % self.MOD\n            n //= 2\n        return res", "writer": "Human"}
{"code": "class Solution:\n    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:\n        n = len(items)\n        profit = [0] * n\n        category = [0] * n\n        for i in range(n):\n            profit[i] = items[i][0]\n            category[i] = items[i][1]\n        profit.sort(reverse=True)\n        category.sort(reverse=True)\n        profit = profit[:k]\n        category = category[:k]\n        \n        profit_set = set(profit)\n        category_set = set(category)\n        \n        profit_sum = sum(profit)\n        category_sum = sum(category)\n        \n        return profit_sum + category_sum ** 2", "writer": "AI"}
{"code": "class Solution:\n    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:\n        items = sorted(items, key=lambda v: -v[0])\n        res = cur = 0\n        A = []\n        seen = set()\n        for i, (p, c) in enumerate(items):\n            if i < k:\n                if c in seen:\n                    A.append(p)\n                cur += p\n            elif c not in seen:\n                if not A: break\n                cur += p - A.pop()\n            seen.add(c)\n            res = max(res, cur + len(seen) * len(seen))\n        return res", "writer": "Human"}
{"code": "class Solution:\n    def maxSum(self, nums: List[int]) -> int:\n        nums.sort(reverse=True)\n        for i in range(len(nums)-1):\n            if nums[i]%10==nums[i+1]%10:\n                return nums[i]+nums[i+1]\n        return -1", "writer": "AI"}
{"code": "class Solution:\n    def maxSum(self, nums: List[int]) -> int:\n        max_by_digit = defaultdict(int)\n        max_sum = -1\n\n        for num in nums:\n            digit = max(str(num))\n\n            if digit in max_by_digit:\n                max_sum = max(max_sum, max_by_digit[digit] + num)\n\n            max_by_digit[digit] = max(max_by_digit[digit], num)\n\n        return max_sum", "writer": "Human"}
{"code": "class Solution:\n    def finalString(self, s: str) -> str:\n        ans = \"\"\n        for i in range(len(s)):\n            if s[i] == 'i':\n                ans = ans[:-1]\n            else:\n                ans += s[i]\n        return ans", "writer": "AI"}
{"code": "class Solution:\n    def finalString(self, s: str) -> str:\n        while \"i\" in s:\n            index=s.index(\"i\")\n\n            #first half and second half\n            first=s[:index][::-1]\n            second=s[index+1:]\n\n            s=\"\".join([first,second])\n        return s", "writer": "Human"}
{"code": "class Solution:\n    def minAbsoluteDifference(self, nums: List[int], x: int) -> int:\n        nums.sort()\n        ans = float('inf')\n        for i in range(len(nums)):\n            j = bisect_left(nums, nums[i] + x)\n            if j < len(nums):\n                ans = min(ans, nums[j] - nums[i])\n            if i + 1 < len(nums):\n                ans = min(ans, nums[i + 1] - nums[i])\n        return ans", "writer": "AI"}
{"code": "class Solution:\n  def minAbsoluteDifference(self, nums: List[int], x: int) -> int:\n    if x == 0:\n      return 0\n\n    arr, best_dist = SortedList([]), float('inf')\n    for i in range(x, len(nums)):\n      arr.add(nums[i - x])\n      v = nums[i]\n\n      pos = arr.bisect_left(v)\n      if pos < len(arr):\n        best_dist = min(best_dist, abs(arr[pos] - v))\n      if pos > 0:\n        best_dist = min(best_dist, abs(arr[pos - 1] - v))\n    \n    return best_dist", "writer": "Human"}
{"code": "class Solution:\n    def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head:\n            return head\n        if not head.next:\n            head.val *= 2\n            return head\n        prev = head\n        curr = head.next\n        while curr:\n            curr.val *= 2\n            prev = curr\n            curr = curr.next\n        prev.val *= 2\n        return head", "writer": "AI"}
{"code": "class Solution:\n    def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if head.val > 4:\n            head = ListNode(0, head)\n        node = head\n        while node:\n            node.val = (node.val * 2) % 10\n            if node.next and node.next.val > 4:\n                node.val += 1\n            node = node.next\n        return head", "writer": "Human"}
{"code": "class Solution:\n    def maximumScore(self, nums: List[int], k: int) -> int:\n        def prime(n):\n            if n == 1:\n                return False\n            for i in range(2, int(n**0.5)+1):\n                if n % i == 0:\n                    return False\n            return True\n        ans = 1\n        for i in range(k, -1, -1):\n            if prime(nums[i]):\n                ans *= nums[i]\n        for i in range(k+1, len(nums)):\n            if prime(nums[i]):\n                ans *= nums[i]\n        return ans % (10**9 + 7)", "writer": "AI"}
{"code": "class Solution: \n    MOD = 1000000007\n\n    def maximumScore(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n\n        upper = max(nums) + 1\n\n        prime = [True]*upper\n        prime[0] = prime[1] = False\n        primeScore = [0]*upper\n        for i in range(2, upper):\n            if prime[i]:\n                for j in range(i, upper, i):\n                    primeScore[j] += 1\n                    prime[j] = False\n\n        nextGreaterElement = [n]*n\n        s = []\n        for i in range(n - 1, -1, -1):\n            while s and primeScore[nums[i]] >= primeScore[nums[s[-1]]]:\n                s.pop()\n            nextGreaterElement[i] = s[-1] if s else n\n            s.append(i)\n\n        prevGreaterOrEqualElement = [-1]*n\n        s = []\n        for i in range(n):\n            while s and primeScore[nums[i]] > primeScore[nums[s[-1]]]:\n                s.pop()\n            prevGreaterOrEqualElement[i] = s[-1] if s else -1\n            s.append(i)\n\n        res = 1\n        tuples = [[nums[i], i] for i in range(n)]\n        tuples.sort(reverse=True)\n        for num, idx in tuples:\n            operations = min((idx - prevGreaterOrEqualElement[idx]) * (nextGreaterElement[idx] - idx), k)\n            res = (res * self.pow(num, operations)) % self.MOD\n            k -= operations\n            if k == 0:\n                return res\n\n        return res\n\n    def pow(self, x: int, n: int) -> int:\n        res = 1\n        while n > 0:\n            if n % 2 == 1:\n                res = (res * x) % self.MOD\n            x = (x * x) % self.MOD\n            n //= 2\n        return res", "writer": "Human"}
{"code": "class Solution:\n    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:\n        items.sort(key = lambda x: x[1])\n        ans = 0\n        for i in range(k):\n            ans += items[i][0]\n        return ans + (k * (k - 1) // 2) * items[k - 1][1]", "writer": "AI"}
{"code": "class Solution:\n    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:\n        items = sorted(items, key=lambda v: -v[0])\n        res = cur = 0\n        A = []\n        seen = set()\n        for i, (p, c) in enumerate(items):\n            if i < k:\n                if c in seen:\n                    A.append(p)\n                cur += p\n            elif c not in seen:\n                if not A: break\n                cur += p - A.pop()\n            seen.add(c)\n            res = max(res, cur + len(seen) * len(seen))\n        return res", "writer": "Human"}
{"code": "class Solution:\n    def maxSum(self, nums: List[int]) -> int:\n        maxSum = -1\n        maxDigit = [0] * 10\n        for num in nums:\n            maxDigit[int(str(num)[0])] = max(maxDigit[int(str(num)[0])], num)\n        for i in range(10):\n            \n            for j in range(i, 10):\n                if maxDigit[i] and maxDigit[j]:\n                    maxSum = max(maxSum, maxDigit[i] + maxDigit[j])\n        return maxSum", "writer": "AI"}
{"code": "class Solution:\n    def maxSum(self, nums: List[int]) -> int:\n        max_by_digit = defaultdict(int)\n        max_sum = -1\n\n        for num in nums:\n            digit = max(str(num))\n\n            if digit in max_by_digit:\n                max_sum = max(max_sum, max_by_digit[digit] + num)\n\n            max_by_digit[digit] = max(max_by_digit[digit], num)\n\n        return max_sum", "writer": "Human"}
{"code": "class Solution:\n    def finalString(self, s: str) -> str:\n        stack = []\n        for i in range(len(s)):\n            if s[i] == 'i':\n                stack.reverse()\n            else:\n                stack.append(s[i])\n        return \"\".join(stack)", "writer": "AI"}
{"code": "class Solution:\n    def finalString(self, s: str) -> str:\n        while \"i\" in s:\n            index=s.index(\"i\")\n\n            #first half and second half\n            first=s[:index][::-1]\n            second=s[index+1:]\n\n            s=\"\".join([first,second])\n        return s", "writer": "Human"}
{"code": "class Solution:\n    def minAbsoluteDifference(self, nums: List[int], x: int) -> int:\n        nums.sort()\n        n = len(nums)\n        res = float('inf')\n        for i in range(n):\n            j = bisect_left(nums, nums[i] - x, i + 1)\n            if j < n:\n                res = min(res, abs(nums[i] - nums[j] + x))\n            if j > i + 1:\n                res = min(res, abs(nums[i] - nums[j - 1] + x))\n        return res", "writer": "AI"}
{"code": "class Solution:\n  def minAbsoluteDifference(self, nums: List[int], x: int) -> int:\n    if x == 0:\n      return 0\n\n    arr, best_dist = SortedList([]), float('inf')\n    for i in range(x, len(nums)):\n      arr.add(nums[i - x])\n      v = nums[i]\n\n      pos = arr.bisect_left(v)\n      if pos < len(arr):\n        best_dist = min(best_dist, abs(arr[pos] - v))\n      if pos > 0:\n        best_dist = min(best_dist, abs(arr[pos - 1] - v))\n    \n    return best_dist", "writer": "Human"}
{"code": "class Solution:\n    def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if head is None:\n            return None\n        if head.next is None:\n            head.val = head.val * 2\n            return head\n        node = head\n        while node:\n            node.val = node.val * 2\n            node = node.next\n        node = head\n        while node:\n            if node.val > 9:\n                node.val = node.val % 10\n                if node.next is None:\n                    node.next = ListNode(1)\n                else:\n                    node.next.val += 1\n            node = node.next\n        return head", "writer": "AI"}
{"code": "class Solution:\n    def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if head.val > 4:\n            head = ListNode(0, head)\n        node = head\n        while node:\n            node.val = (node.val * 2) % 10\n            if node.next and node.next.val > 4:\n                node.val += 1\n            node = node.next\n        return head", "writer": "Human"}
{"code": "class Solution:\n    def maximumScore(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        left, right = k, k\n        res = nums[k]\n        min_val = nums[k]\n        while left > 0 or right < n - 1:\n            if left == 0:\n                right += 1\n            elif right == n - 1:\n                left -= 1\n            elif nums[left - 1] < nums[right + 1]:\n                right += 1\n            else:\n                left -= 1\n            min_val = min(min_val, nums[left], nums[right])\n            res = max(res, min_val * (right - left + 1))\n        return res", "writer": "AI"}
{"code": "class Solution: \n    MOD = 1000000007\n\n    def maximumScore(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n\n        upper = max(nums) + 1\n\n        prime = [True]*upper\n        prime[0] = prime[1] = False\n        primeScore = [0]*upper\n        for i in range(2, upper):\n            if prime[i]:\n                for j in range(i, upper, i):\n                    primeScore[j] += 1\n                    prime[j] = False\n\n        nextGreaterElement = [n]*n\n        s = []\n        for i in range(n - 1, -1, -1):\n            while s and primeScore[nums[i]] >= primeScore[nums[s[-1]]]:\n                s.pop()\n            nextGreaterElement[i] = s[-1] if s else n\n            s.append(i)\n\n        prevGreaterOrEqualElement = [-1]*n\n        s = []\n        for i in range(n):\n            while s and primeScore[nums[i]] > primeScore[nums[s[-1]]]:\n                s.pop()\n            prevGreaterOrEqualElement[i] = s[-1] if s else -1\n            s.append(i)\n\n        res = 1\n        tuples = [[nums[i], i] for i in range(n)]\n        tuples.sort(reverse=True)\n        for num, idx in tuples:\n            operations = min((idx - prevGreaterOrEqualElement[idx]) * (nextGreaterElement[idx] - idx), k)\n            res = (res * self.pow(num, operations)) % self.MOD\n            k -= operations\n            if k == 0:\n                return res\n\n        return res\n\n    def pow(self, x: int, n: int) -> int:\n        res = 1\n        while n > 0:\n            if n % 2 == 1:\n                res = (res * x) % self.MOD\n            x = (x * x) % self.MOD\n            n //= 2\n        return res", "writer": "Human"}
{"code": "class Solution:\n    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:\n        items.sort(key = lambda x: x[0], reverse = True)\n        category = {}\n        for i in range(len(items)):\n            if items[i][1] not in category:\n                category[items[i][1]] = 1\n            else:\n                category[items[i][1]] += 1\n        category = sorted(category.items(), key = lambda x: x[1], reverse = True)\n        ans = 0\n        for i in range(k):\n            ans += items[i][0]\n        ans += len(category) ** 2\n        return ans", "writer": "AI"}
{"code": "class Solution:\n    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:\n        items = sorted(items, key=lambda v: -v[0])\n        res = cur = 0\n        A = []\n        seen = set()\n        for i, (p, c) in enumerate(items):\n            if i < k:\n                if c in seen:\n                    A.append(p)\n                cur += p\n            elif c not in seen:\n                if not A: break\n                cur += p - A.pop()\n            seen.add(c)\n            res = max(res, cur + len(seen) * len(seen))\n        return res", "writer": "Human"}
{"code": "class Solution:    \n    def maxSum (self, nums: List[int]) -> int:\n        \n        nums.sort()\n        \n        max_sum = 0\n        \n        for i in range(len(nums)-1):\n            if nums[i] == nums[i+1]:\n                max_sum = max(max_sum, nums[i]*(len(nums)-i-1))\n                \n        return max_sum", "writer": "AI"}
{"code": "class Solution:\n    def maxSum(self, nums: List[int]) -> int:\n        max_by_digit = defaultdict(int)\n        max_sum = -1\n\n        for num in nums:\n            digit = max(str(num))\n\n            if digit in max_by_digit:\n                max_sum = max(max_sum, max_by_digit[digit] + num)\n\n            max_by_digit[digit] = max(max_by_digit[digit], num)\n\n        return max_sum", "writer": "Human"}
{"code": "class Solution:\n    def finalString(self, s: str) -> str:\n        res = \"\"\n        for i in s:\n            if i!= 'i':\n                res += i\n            else:\n                res = res[::-1]\n        return res", "writer": "AI"}
{"code": "class Solution:\n    def finalString(self, s: str) -> str:\n        while \"i\" in s:\n            index=s.index(\"i\")\n\n            #first half and second half\n            first=s[:index][::-1]\n            second=s[index+1:]\n\n            s=\"\".join([first,second])\n        return s", "writer": "Human"}
{"code": "class Solution:\n    def minAbsoluteDifference(self, nums: List[int], x: int) -> int:\n        nums.sort()\n        res = float('inf')\n        for i in range(len(nums)-1):\n            res = min(res, abs(nums[i]-nums[i+1]))\n        return res", "writer": "AI"}
{"code": "class Solution:\n  def minAbsoluteDifference(self, nums: List[int], x: int) -> int:\n    if x == 0:\n      return 0\n\n    arr, best_dist = SortedList([]), float('inf')\n    for i in range(x, len(nums)):\n      arr.add(nums[i - x])\n      v = nums[i]\n\n      pos = arr.bisect_left(v)\n      if pos < len(arr):\n        best_dist = min(best_dist, abs(arr[pos] - v))\n      if pos > 0:\n        best_dist = min(best_dist, abs(arr[pos - 1] - v))\n    \n    return best_dist", "writer": "Human"}
{"code": "class Solution:\n    def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head:\n            return head\n        \n        curr = head\n        while curr:\n            curr.val *= 2\n            curr = curr.next\n        return head", "writer": "AI"}
{"code": "class Solution:\n    def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if head.val > 4:\n            head = ListNode(0, head)\n        node = head\n        while node:\n            node.val = (node.val * 2) % 10\n            if node.next and node.next.val > 4:\n                node.val += 1\n            node = node.next\n        return head", "writer": "Human"}
{"code": "class Solution:    \n    def maximumScore(self, nums: List[int], k: int) -> int:\n        \n        n = len(nums)\n        \n        @lru_cache(None)\n        def dp(l, r, k):\n            if k == 0:\n                return 0\n            if l > r:\n                return 0\n            if l == r:\n                return nums[l]\n            \n            res = 0\n            for i in range(l, r + 1):\n                if i == l:\n                    res = max(res, dp(l + 1, r, k - 1))\n                elif i == r:\n                    res = max(res, dp(l, r - 1, k - 1))\n                else:\n                    res = max(res, dp(l + 1, r, k - 1) + nums[i] * nums[i])\n                    res = max(res, dp(l, r - 1, k - 1) + nums[i] * nums[i])\n            return res % (10**9 + 7)\n        \n        return dp(0, n - 1, k)", "writer": "AI"}
{"code": "class Solution: \n    MOD = 1000000007\n\n    def maximumScore(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n\n        upper = max(nums) + 1\n\n        prime = [True]*upper\n        prime[0] = prime[1] = False\n        primeScore = [0]*upper\n        for i in range(2, upper):\n            if prime[i]:\n                for j in range(i, upper, i):\n                    primeScore[j] += 1\n                    prime[j] = False\n\n        nextGreaterElement = [n]*n\n        s = []\n        for i in range(n - 1, -1, -1):\n            while s and primeScore[nums[i]] >= primeScore[nums[s[-1]]]:\n                s.pop()\n            nextGreaterElement[i] = s[-1] if s else n\n            s.append(i)\n\n        prevGreaterOrEqualElement = [-1]*n\n        s = []\n        for i in range(n):\n            while s and primeScore[nums[i]] > primeScore[nums[s[-1]]]:\n                s.pop()\n            prevGreaterOrEqualElement[i] = s[-1] if s else -1\n            s.append(i)\n\n        res = 1\n        tuples = [[nums[i], i] for i in range(n)]\n        tuples.sort(reverse=True)\n        for num, idx in tuples:\n            operations = min((idx - prevGreaterOrEqualElement[idx]) * (nextGreaterElement[idx] - idx), k)\n            res = (res * self.pow(num, operations)) % self.MOD\n            k -= operations\n            if k == 0:\n                return res\n\n        return res\n\n    def pow(self, x: int, n: int) -> int:\n        res = 1\n        while n > 0:\n            if n % 2 == 1:\n                res = (res * x) % self.MOD\n            x = (x * x) % self.MOD\n            n //= 2\n        return res", "writer": "Human"}
{"code": "class Solution:    \n    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:\n        \n        @lru_cache(None)\n        def dp(i, k):\n            if k == 0:\n                return 0\n            if i == len(items):\n                return float('-inf')\n            return max(dp(i + 1, k), items[i][0] + dp(i + 1, k - 1))\n        \n        return dp(0, k)", "writer": "AI"}
{"code": "class Solution:\n    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:\n        items = sorted(items, key=lambda v: -v[0])\n        res = cur = 0\n        A = []\n        seen = set()\n        for i, (p, c) in enumerate(items):\n            if i < k:\n                if c in seen:\n                    A.append(p)\n                cur += p\n            elif c not in seen:\n                if not A: break\n                cur += p - A.pop()\n            seen.add(c)\n            res = max(res, cur + len(seen) * len(seen))\n        return res", "writer": "Human"}
{"code": "class Solution:\n    def maxSum(self, nums: List[int]) -> int:\n        if len(nums) == 1:\n            return nums[0]\n        if len(nums) == 2:\n            return max(nums)\n        max_sum = 0\n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if nums[i] % 10 == nums[j] % 10:\n                    max_sum = max(max_sum, nums[i] + nums[j])\n        return max_sum if max_sum > 0 else -1", "writer": "AI"}
{"code": "class Solution:\n    def maxSum(self, nums: List[int]) -> int:\n        max_by_digit = defaultdict(int)\n        max_sum = -1\n\n        for num in nums:\n            digit = max(str(num))\n\n            if digit in max_by_digit:\n                max_sum = max(max_sum, max_by_digit[digit] + num)\n\n            max_by_digit[digit] = max(max_by_digit[digit], num)\n\n        return max_sum", "writer": "Human"}
{"code": "class Solution:\n    def finalString(self, s: str) -> str:\n        s = list(s)\n        for i in range(len(s)):\n            if s[i] == 'i':\n                s[i] = 'o'\n            else:\n                s[i] = 'i'\n        return ''.join(s)", "writer": "AI"}
{"code": "class Solution:\n    def finalString(self, s: str) -> str:\n        while \"i\" in s:\n            index=s.index(\"i\")\n\n            #first half and second half\n            first=s[:index][::-1]\n            second=s[index+1:]\n\n            s=\"\".join([first,second])\n        return s", "writer": "Human"}
{"code": "class Solution:\n    def minAbsoluteDifference(self, nums: List[int], x: int) -> int:\n        nums.sort()\n        n = len(nums)\n        ans = float('inf')\n        for i in range(n):\n            for j in range(i+1, n):\n                if abs(nums[i] - nums[j]) < ans:\n                    ans = abs(nums[i] - nums[j])\n                if abs(nums[i] - nums[j]) == ans and abs(nums[i] - x) < abs(nums[j] - x):\n                    ans = abs(nums[i] - x)\n        return ans", "writer": "AI"}
{"code": "class Solution:\n  def minAbsoluteDifference(self, nums: List[int], x: int) -> int:\n    if x == 0:\n      return 0\n\n    arr, best_dist = SortedList([]), float('inf')\n    for i in range(x, len(nums)):\n      arr.add(nums[i - x])\n      v = nums[i]\n\n      pos = arr.bisect_left(v)\n      if pos < len(arr):\n        best_dist = min(best_dist, abs(arr[pos] - v))\n      if pos > 0:\n        best_dist = min(best_dist, abs(arr[pos - 1] - v))\n    \n    return best_dist", "writer": "Human"}
{"code": "class Solution:\n    def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if head is None:\n            return None\n        temp = head\n        while temp is not None:\n            temp.val *= 2\n            temp = temp.next\n        return head", "writer": "AI"}
{"code": "class Solution:\n    def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if head.val > 4:\n            head = ListNode(0, head)\n        node = head\n        while node:\n            node.val = (node.val * 2) % 10\n            if node.next and node.next.val > 4:\n                node.val += 1\n            node = node.next\n        return head", "writer": "Human"}
{"code": "class Solution:\n    def maximumScore(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        dp = [0]*n\n        dp[0] = nums[0]\n        for i in range(1, n):\n            dp[i] = max(dp[i-1], nums[i])\n        ans = dp[k-1]\n        for i in range(k-1, n):\n            ans = max(ans, dp[i] * dp[k-1-i])\n        return ans % (10**9 + 7)", "writer": "AI"}
{"code": "class Solution: \n    MOD = 1000000007\n\n    def maximumScore(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n\n        upper = max(nums) + 1\n\n        prime = [True]*upper\n        prime[0] = prime[1] = False\n        primeScore = [0]*upper\n        for i in range(2, upper):\n            if prime[i]:\n                for j in range(i, upper, i):\n                    primeScore[j] += 1\n                    prime[j] = False\n\n        nextGreaterElement = [n]*n\n        s = []\n        for i in range(n - 1, -1, -1):\n            while s and primeScore[nums[i]] >= primeScore[nums[s[-1]]]:\n                s.pop()\n            nextGreaterElement[i] = s[-1] if s else n\n            s.append(i)\n\n        prevGreaterOrEqualElement = [-1]*n\n        s = []\n        for i in range(n):\n            while s and primeScore[nums[i]] > primeScore[nums[s[-1]]]:\n                s.pop()\n            prevGreaterOrEqualElement[i] = s[-1] if s else -1\n            s.append(i)\n\n        res = 1\n        tuples = [[nums[i], i] for i in range(n)]\n        tuples.sort(reverse=True)\n        for num, idx in tuples:\n            operations = min((idx - prevGreaterOrEqualElement[idx]) * (nextGreaterElement[idx] - idx), k)\n            res = (res * self.pow(num, operations)) % self.MOD\n            k -= operations\n            if k == 0:\n                return res\n\n        return res\n\n    def pow(self, x: int, n: int) -> int:\n        res = 1\n        while n > 0:\n            if n % 2 == 1:\n                res = (res * x) % self.MOD\n            x = (x * x) % self.MOD\n            n //= 2\n        return res", "writer": "Human"}
{"code": "class Solution:\n    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:\n        n = len(items)\n        dp = [[0]*n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = items[i][0]\n        for l in range(2, n+1):\n            for i in range(n-l+1):\n                j = i+l-1\n                dp[i][j] = max(dp[i][j-1], dp[i+1][j]) + items[j][0]\n        return max(dp[0][k-1], dp[n-k][n-1])", "writer": "AI"}
{"code": "class Solution:\n    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:\n        items = sorted(items, key=lambda v: -v[0])\n        res = cur = 0\n        A = []\n        seen = set()\n        for i, (p, c) in enumerate(items):\n            if i < k:\n                if c in seen:\n                    A.append(p)\n                cur += p\n            elif c not in seen:\n                if not A: break\n                cur += p - A.pop()\n            seen.add(c)\n            res = max(res, cur + len(seen) * len(seen))\n        return res", "writer": "Human"}
