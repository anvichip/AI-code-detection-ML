{"code": "class Solution {\n    public int maxSum(int[] nums) {\n    int ans = -1;\n    Map<Integer,List<Integer>> ump = new HashMap<>();\n    for(int i = 0; i < nums.length; ++i){\n        int t = nums[i], maxDigit = 0;\n        while(t != 0){ //evaluate max digit in the number\n            maxDigit = Math.max(t%10, maxDigit);\n            t = t/10;\n        }\n        if(!ump.containsKey(maxDigit)) ump.put(maxDigit, new ArrayList<>());\n        ump.get(maxDigit).add(nums[i]); // add the number to the map \n    }\n    for(Map.Entry<Integer, List<Integer>> entry: ump.entrySet()){\n        entry.getValue().sort(Comparator.reverseOrder()); //to find max two number in each max digit \n        if(entry.getValue().size() >= 2) ans = Math.max(ans, entry.getValue().get(0) + entry.getValue().get(1)); //sum max two number and take max\n    }\n    return ans;\n    }\n}", "writer": "Human"}
{"code": "class Solution {\n    public String finalString(String s) {\n        StringBuilder nm=new StringBuilder();\n        for(char c:s.toCharArray())\n        {\n            if(c=='i')\n            {\n                nm.reverse();\n            }\n            else\n            {\n                nm.append(c);\n            }\n        }\n        return nm.toString();\n    }\n}", "writer": "Human"}
{"code": "class Solution {\n    int minAbsoluteDifference(List<Integer> nums, int x) {\n        int ans = Integer.MAX_VALUE;\n        TreeSet<Integer> s = new TreeSet<>();\n        for(int i = x; i < nums.size(); ++i){\n            s.add(nums.get(i-x));\n            Integer high = s.ceiling(nums.get(i)), low = s.floor(nums.get(i));\n            if(high != null) ans = Math.min(ans, Math.abs(nums.get(i) - high));\n            if(low != null) ans = Math.min(ans, Math.abs(nums.get(i) - low));\n        }\n        return ans;\n    }\n}", "writer": "Human"}
{"code": "class Solution {\n    public ListNode doubleIt(ListNode head) {\n        if (head.val > 4)\n            head = new ListNode(0, head);\n        for(ListNode node = head; node != null; node = node.next) {\n            node.val = (node.val * 2) % 10;\n            if (node.next != null && node.next.val > 4)\n                node.val++;\n        }\n        return head;\n    }\n}", "writer": "Human"}
{"code": "class Solution {\n    static final int MOD = 1000000007;\n\n    public int maximumScore(List<Integer> nums, int k) {\n        int n = nums.size();\n\n        int upper = Collections.max(nums) + 1;\n\n        boolean[] prime = new boolean[upper];\n        int[] primeScore = new int[upper];\n        Arrays.fill(prime, true);\n        prime[0] = prime[1] = false;\n        for (int i = 2; i < upper; i++) {\n            if (prime[i]) {\n                for (int j = i; j < upper; j += i) {\n                    primeScore[j]++;\n                    prime[j] = false;\n                }\n            }\n        }\n\n        int[] nextGreaterElement = new int[n];\n        Arrays.fill(nextGreaterElement, n);\n        Stack<Integer> s = new Stack<>();\n        for (int i = n - 1; i >= 0; i--) {\n            while (!s.empty() && primeScore[nums.get(i)] >= primeScore[nums.get(s.peek())]) {\n                s.pop();\n            }\n            nextGreaterElement[i] = s.empty() ? n : s.peek();\n            s.push(i);\n        }\n\n        int[] prevGreaterOrEqualElement = new int[n];\n        Arrays.fill(prevGreaterOrEqualElement, -1);\n        s = new Stack<>();\n        for (int i = 0; i < n; i++) {\n            while (!s.empty() && primeScore[nums.get(i)] > primeScore[nums.get(s.peek())]) {\n                s.pop();\n            }\n            prevGreaterOrEqualElement[i] = s.empty() ? -1 : s.peek();\n            s.push(i);\n        }\n\n        int res = 1;\n        int[][] tuples = new int[n][2];\n        for (int i = 0; i < n; i++) {\n            tuples[i][0] = nums.get(i);\n            tuples[i][1] = i;\n        }\n        Arrays.sort(tuples, new Comparator<int[]>() {\n            public int compare(int[] a, int[] b) {\n                return b[0] - a[0];\n            }\n        });\n        for (int i = 0; i < n; i++) {\n            int num = tuples[i][0];\n            int idx = tuples[i][1];\n            int operations = Math.min((idx - prevGreaterOrEqualElement[idx]) * (nextGreaterElement[idx] - idx), k);\n            res = (int)((1L * res * pow(num, operations)) % MOD);\n            k -= operations;\n            if (k == 0) {\n                return res;\n            }\n        }\n\n        return res;\n    }\n\n    public int pow(int x, int n) {\n        int res = 1;\n        while (n > 0) {\n            if (n % 2 == 1) {\n                res = (int)((1L * res * x) % MOD);\n            }\n            x = (int)((1L * x * x) % MOD);\n            n /= 2;\n        }\n        return res;\n    }\n}", "writer": "Human"}
{"code": "class Solution {\n    public long findMaximumElegance(int[][] A, int k) {\n        Arrays.sort(A, (a, b) -> b[0] - a[0]);\n        long res = 0, cur = 0;\n        List<Integer> dup = new ArrayList<>();\n        Set<Integer> seen = new HashSet<>();\n        for (int i = 0; i < A.length; ++i) {\n            if (i < k) {\n                if (seen.contains(A[i][1])) {\n                    dup.add(A[i][0]);\n                }\n                cur += A[i][0];\n            } else if (!seen.contains(A[i][1])) {\n                if (dup.isEmpty()) break;\n                cur += A[i][0] - dup.remove(dup.size() - 1);\n            }\n            seen.add(A[i][1]);\n            res = Math.max(res, cur + 1L * seen.size() * seen.size());\n        }\n        return res;\n    }\n}", "writer": "Human"}
{"code": "class Solution {\n    public int maxSum(int[] nums) {\n    int ans = -1;\n    Map<Integer,List<Integer>> ump = new HashMap<>();\n    for(int i = 0; i < nums.length; ++i){\n        int t = nums[i], maxDigit = 0;\n        while(t != 0){ //evaluate max digit in the number\n            maxDigit = Math.max(t%10, maxDigit);\n            t = t/10;\n        }\n        if(!ump.containsKey(maxDigit)) ump.put(maxDigit, new ArrayList<>());\n        ump.get(maxDigit).add(nums[i]); // add the number to the map \n    }\n    for(Map.Entry<Integer, List<Integer>> entry: ump.entrySet()){\n        entry.getValue().sort(Comparator.reverseOrder()); //to find max two number in each max digit \n        if(entry.getValue().size() >= 2) ans = Math.max(ans, entry.getValue().get(0) + entry.getValue().get(1)); //sum max two number and take max\n    }\n    return ans;\n    }\n}", "writer": "Human"}
{"code": "class Solution {\n    public String finalString(String s) {\n        StringBuilder nm=new StringBuilder();\n        for(char c:s.toCharArray())\n        {\n            if(c=='i')\n            {\n                nm.reverse();\n            }\n            else\n            {\n                nm.append(c);\n            }\n        }\n        return nm.toString();\n    }\n}", "writer": "Human"}
{"code": "class Solution {\n    int minAbsoluteDifference(List<Integer> nums, int x) {\n        int ans = Integer.MAX_VALUE;\n        TreeSet<Integer> s = new TreeSet<>();\n        for(int i = x; i < nums.size(); ++i){\n            s.add(nums.get(i-x));\n            Integer high = s.ceiling(nums.get(i)), low = s.floor(nums.get(i));\n            if(high != null) ans = Math.min(ans, Math.abs(nums.get(i) - high));\n            if(low != null) ans = Math.min(ans, Math.abs(nums.get(i) - low));\n        }\n        return ans;\n    }\n}", "writer": "Human"}
{"code": "class Solution {\n    public ListNode doubleIt(ListNode head) {\n        if (head.val > 4)\n            head = new ListNode(0, head);\n        for(ListNode node = head; node != null; node = node.next) {\n            node.val = (node.val * 2) % 10;\n            if (node.next != null && node.next.val > 4)\n                node.val++;\n        }\n        return head;\n    }\n}", "writer": "Human"}
{"code": "class Solution {\n    static final int MOD = 1000000007;\n\n    public int maximumScore(List<Integer> nums, int k) {\n        int n = nums.size();\n\n        int upper = Collections.max(nums) + 1;\n\n        boolean[] prime = new boolean[upper];\n        int[] primeScore = new int[upper];\n        Arrays.fill(prime, true);\n        prime[0] = prime[1] = false;\n        for (int i = 2; i < upper; i++) {\n            if (prime[i]) {\n                for (int j = i; j < upper; j += i) {\n                    primeScore[j]++;\n                    prime[j] = false;\n                }\n            }\n        }\n\n        int[] nextGreaterElement = new int[n];\n        Arrays.fill(nextGreaterElement, n);\n        Stack<Integer> s = new Stack<>();\n        for (int i = n - 1; i >= 0; i--) {\n            while (!s.empty() && primeScore[nums.get(i)] >= primeScore[nums.get(s.peek())]) {\n                s.pop();\n            }\n            nextGreaterElement[i] = s.empty() ? n : s.peek();\n            s.push(i);\n        }\n\n        int[] prevGreaterOrEqualElement = new int[n];\n        Arrays.fill(prevGreaterOrEqualElement, -1);\n        s = new Stack<>();\n        for (int i = 0; i < n; i++) {\n            while (!s.empty() && primeScore[nums.get(i)] > primeScore[nums.get(s.peek())]) {\n                s.pop();\n            }\n            prevGreaterOrEqualElement[i] = s.empty() ? -1 : s.peek();\n            s.push(i);\n        }\n\n        int res = 1;\n        int[][] tuples = new int[n][2];\n        for (int i = 0; i < n; i++) {\n            tuples[i][0] = nums.get(i);\n            tuples[i][1] = i;\n        }\n        Arrays.sort(tuples, new Comparator<int[]>() {\n            public int compare(int[] a, int[] b) {\n                return b[0] - a[0];\n            }\n        });\n        for (int i = 0; i < n; i++) {\n            int num = tuples[i][0];\n            int idx = tuples[i][1];\n            int operations = Math.min((idx - prevGreaterOrEqualElement[idx]) * (nextGreaterElement[idx] - idx), k);\n            res = (int)((1L * res * pow(num, operations)) % MOD);\n            k -= operations;\n            if (k == 0) {\n                return res;\n            }\n        }\n\n        return res;\n    }\n\n    public int pow(int x, int n) {\n        int res = 1;\n        while (n > 0) {\n            if (n % 2 == 1) {\n                res = (int)((1L * res * x) % MOD);\n            }\n            x = (int)((1L * x * x) % MOD);\n            n /= 2;\n        }\n        return res;\n    }\n}", "writer": "Human"}
{"code": "class Solution {\n    public long findMaximumElegance(int[][] A, int k) {\n        Arrays.sort(A, (a, b) -> b[0] - a[0]);\n        long res = 0, cur = 0;\n        List<Integer> dup = new ArrayList<>();\n        Set<Integer> seen = new HashSet<>();\n        for (int i = 0; i < A.length; ++i) {\n            if (i < k) {\n                if (seen.contains(A[i][1])) {\n                    dup.add(A[i][0]);\n                }\n                cur += A[i][0];\n            } else if (!seen.contains(A[i][1])) {\n                if (dup.isEmpty()) break;\n                cur += A[i][0] - dup.remove(dup.size() - 1);\n            }\n            seen.add(A[i][1]);\n            res = Math.max(res, cur + 1L * seen.size() * seen.size());\n        }\n        return res;\n    }\n}", "writer": "Human"}
{"code": "class Solution {\n    public int maxSum(int[] nums) {\n    int ans = -1;\n    Map<Integer,List<Integer>> ump = new HashMap<>();\n    for(int i = 0; i < nums.length; ++i){\n        int t = nums[i], maxDigit = 0;\n        while(t != 0){ //evaluate max digit in the number\n            maxDigit = Math.max(t%10, maxDigit);\n            t = t/10;\n        }\n        if(!ump.containsKey(maxDigit)) ump.put(maxDigit, new ArrayList<>());\n        ump.get(maxDigit).add(nums[i]); // add the number to the map \n    }\n    for(Map.Entry<Integer, List<Integer>> entry: ump.entrySet()){\n        entry.getValue().sort(Comparator.reverseOrder()); //to find max two number in each max digit \n        if(entry.getValue().size() >= 2) ans = Math.max(ans, entry.getValue().get(0) + entry.getValue().get(1)); //sum max two number and take max\n    }\n    return ans;\n    }\n}", "writer": "Human"}
{"code": "class Solution {\n    public String finalString(String s) {\n        StringBuilder nm=new StringBuilder();\n        for(char c:s.toCharArray())\n        {\n            if(c=='i')\n            {\n                nm.reverse();\n            }\n            else\n            {\n                nm.append(c);\n            }\n        }\n        return nm.toString();\n    }\n}", "writer": "Human"}
{"code": "class Solution {\n    int minAbsoluteDifference(List<Integer> nums, int x) {\n        int ans = Integer.MAX_VALUE;\n        TreeSet<Integer> s = new TreeSet<>();\n        for(int i = x; i < nums.size(); ++i){\n            s.add(nums.get(i-x));\n            Integer high = s.ceiling(nums.get(i)), low = s.floor(nums.get(i));\n            if(high != null) ans = Math.min(ans, Math.abs(nums.get(i) - high));\n            if(low != null) ans = Math.min(ans, Math.abs(nums.get(i) - low));\n        }\n        return ans;\n    }\n}", "writer": "Human"}
{"code": "class Solution {\n    public ListNode doubleIt(ListNode head) {\n        if (head.val > 4)\n            head = new ListNode(0, head);\n        for(ListNode node = head; node != null; node = node.next) {\n            node.val = (node.val * 2) % 10;\n            if (node.next != null && node.next.val > 4)\n                node.val++;\n        }\n        return head;\n    }\n}", "writer": "Human"}
{"code": "class Solution {\n    static final int MOD = 1000000007;\n\n    public int maximumScore(List<Integer> nums, int k) {\n        int n = nums.size();\n\n        int upper = Collections.max(nums) + 1;\n\n        boolean[] prime = new boolean[upper];\n        int[] primeScore = new int[upper];\n        Arrays.fill(prime, true);\n        prime[0] = prime[1] = false;\n        for (int i = 2; i < upper; i++) {\n            if (prime[i]) {\n                for (int j = i; j < upper; j += i) {\n                    primeScore[j]++;\n                    prime[j] = false;\n                }\n            }\n        }\n\n        int[] nextGreaterElement = new int[n];\n        Arrays.fill(nextGreaterElement, n);\n        Stack<Integer> s = new Stack<>();\n        for (int i = n - 1; i >= 0; i--) {\n            while (!s.empty() && primeScore[nums.get(i)] >= primeScore[nums.get(s.peek())]) {\n                s.pop();\n            }\n            nextGreaterElement[i] = s.empty() ? n : s.peek();\n            s.push(i);\n        }\n\n        int[] prevGreaterOrEqualElement = new int[n];\n        Arrays.fill(prevGreaterOrEqualElement, -1);\n        s = new Stack<>();\n        for (int i = 0; i < n; i++) {\n            while (!s.empty() && primeScore[nums.get(i)] > primeScore[nums.get(s.peek())]) {\n                s.pop();\n            }\n            prevGreaterOrEqualElement[i] = s.empty() ? -1 : s.peek();\n            s.push(i);\n        }\n\n        int res = 1;\n        int[][] tuples = new int[n][2];\n        for (int i = 0; i < n; i++) {\n            tuples[i][0] = nums.get(i);\n            tuples[i][1] = i;\n        }\n        Arrays.sort(tuples, new Comparator<int[]>() {\n            public int compare(int[] a, int[] b) {\n                return b[0] - a[0];\n            }\n        });\n        for (int i = 0; i < n; i++) {\n            int num = tuples[i][0];\n            int idx = tuples[i][1];\n            int operations = Math.min((idx - prevGreaterOrEqualElement[idx]) * (nextGreaterElement[idx] - idx), k);\n            res = (int)((1L * res * pow(num, operations)) % MOD);\n            k -= operations;\n            if (k == 0) {\n                return res;\n            }\n        }\n\n        return res;\n    }\n\n    public int pow(int x, int n) {\n        int res = 1;\n        while (n > 0) {\n            if (n % 2 == 1) {\n                res = (int)((1L * res * x) % MOD);\n            }\n            x = (int)((1L * x * x) % MOD);\n            n /= 2;\n        }\n        return res;\n    }\n}", "writer": "Human"}
{"code": "class Solution {\n    public long findMaximumElegance(int[][] A, int k) {\n        Arrays.sort(A, (a, b) -> b[0] - a[0]);\n        long res = 0, cur = 0;\n        List<Integer> dup = new ArrayList<>();\n        Set<Integer> seen = new HashSet<>();\n        for (int i = 0; i < A.length; ++i) {\n            if (i < k) {\n                if (seen.contains(A[i][1])) {\n                    dup.add(A[i][0]);\n                }\n                cur += A[i][0];\n            } else if (!seen.contains(A[i][1])) {\n                if (dup.isEmpty()) break;\n                cur += A[i][0] - dup.remove(dup.size() - 1);\n            }\n            seen.add(A[i][1]);\n            res = Math.max(res, cur + 1L * seen.size() * seen.size());\n        }\n        return res;\n    }\n}", "writer": "Human"}
{"code": "class Solution {\n    public int maxSum(int[] nums) {\n    int ans = -1;\n    Map<Integer,List<Integer>> ump = new HashMap<>();\n    for(int i = 0; i < nums.length; ++i){\n        int t = nums[i], maxDigit = 0;\n        while(t != 0){ //evaluate max digit in the number\n            maxDigit = Math.max(t%10, maxDigit);\n            t = t/10;\n        }\n        if(!ump.containsKey(maxDigit)) ump.put(maxDigit, new ArrayList<>());\n        ump.get(maxDigit).add(nums[i]); // add the number to the map \n    }\n    for(Map.Entry<Integer, List<Integer>> entry: ump.entrySet()){\n        entry.getValue().sort(Comparator.reverseOrder()); //to find max two number in each max digit \n        if(entry.getValue().size() >= 2) ans = Math.max(ans, entry.getValue().get(0) + entry.getValue().get(1)); //sum max two number and take max\n    }\n    return ans;\n    }\n}", "writer": "Human"}
{"code": "class Solution {\n    public String finalString(String s) {\n        StringBuilder nm=new StringBuilder();\n        for(char c:s.toCharArray())\n        {\n            if(c=='i')\n            {\n                nm.reverse();\n            }\n            else\n            {\n                nm.append(c);\n            }\n        }\n        return nm.toString();\n    }\n}", "writer": "Human"}
{"code": "class Solution {\n    int minAbsoluteDifference(List<Integer> nums, int x) {\n        int ans = Integer.MAX_VALUE;\n        TreeSet<Integer> s = new TreeSet<>();\n        for(int i = x; i < nums.size(); ++i){\n            s.add(nums.get(i-x));\n            Integer high = s.ceiling(nums.get(i)), low = s.floor(nums.get(i));\n            if(high != null) ans = Math.min(ans, Math.abs(nums.get(i) - high));\n            if(low != null) ans = Math.min(ans, Math.abs(nums.get(i) - low));\n        }\n        return ans;\n    }\n}", "writer": "Human"}
{"code": "class Solution {\n    public ListNode doubleIt(ListNode head) {\n        if (head.val > 4)\n            head = new ListNode(0, head);\n        for(ListNode node = head; node != null; node = node.next) {\n            node.val = (node.val * 2) % 10;\n            if (node.next != null && node.next.val > 4)\n                node.val++;\n        }\n        return head;\n    }\n}", "writer": "Human"}
{"code": "class Solution {\n    static final int MOD = 1000000007;\n\n    public int maximumScore(List<Integer> nums, int k) {\n        int n = nums.size();\n\n        int upper = Collections.max(nums) + 1;\n\n        boolean[] prime = new boolean[upper];\n        int[] primeScore = new int[upper];\n        Arrays.fill(prime, true);\n        prime[0] = prime[1] = false;\n        for (int i = 2; i < upper; i++) {\n            if (prime[i]) {\n                for (int j = i; j < upper; j += i) {\n                    primeScore[j]++;\n                    prime[j] = false;\n                }\n            }\n        }\n\n        int[] nextGreaterElement = new int[n];\n        Arrays.fill(nextGreaterElement, n);\n        Stack<Integer> s = new Stack<>();\n        for (int i = n - 1; i >= 0; i--) {\n            while (!s.empty() && primeScore[nums.get(i)] >= primeScore[nums.get(s.peek())]) {\n                s.pop();\n            }\n            nextGreaterElement[i] = s.empty() ? n : s.peek();\n            s.push(i);\n        }\n\n        int[] prevGreaterOrEqualElement = new int[n];\n        Arrays.fill(prevGreaterOrEqualElement, -1);\n        s = new Stack<>();\n        for (int i = 0; i < n; i++) {\n            while (!s.empty() && primeScore[nums.get(i)] > primeScore[nums.get(s.peek())]) {\n                s.pop();\n            }\n            prevGreaterOrEqualElement[i] = s.empty() ? -1 : s.peek();\n            s.push(i);\n        }\n\n        int res = 1;\n        int[][] tuples = new int[n][2];\n        for (int i = 0; i < n; i++) {\n            tuples[i][0] = nums.get(i);\n            tuples[i][1] = i;\n        }\n        Arrays.sort(tuples, new Comparator<int[]>() {\n            public int compare(int[] a, int[] b) {\n                return b[0] - a[0];\n            }\n        });\n        for (int i = 0; i < n; i++) {\n            int num = tuples[i][0];\n            int idx = tuples[i][1];\n            int operations = Math.min((idx - prevGreaterOrEqualElement[idx]) * (nextGreaterElement[idx] - idx), k);\n            res = (int)((1L * res * pow(num, operations)) % MOD);\n            k -= operations;\n            if (k == 0) {\n                return res;\n            }\n        }\n\n        return res;\n    }\n\n    public int pow(int x, int n) {\n        int res = 1;\n        while (n > 0) {\n            if (n % 2 == 1) {\n                res = (int)((1L * res * x) % MOD);\n            }\n            x = (int)((1L * x * x) % MOD);\n            n /= 2;\n        }\n        return res;\n    }\n}", "writer": "Human"}
{"code": "class Solution {\n    public long findMaximumElegance(int[][] A, int k) {\n        Arrays.sort(A, (a, b) -> b[0] - a[0]);\n        long res = 0, cur = 0;\n        List<Integer> dup = new ArrayList<>();\n        Set<Integer> seen = new HashSet<>();\n        for (int i = 0; i < A.length; ++i) {\n            if (i < k) {\n                if (seen.contains(A[i][1])) {\n                    dup.add(A[i][0]);\n                }\n                cur += A[i][0];\n            } else if (!seen.contains(A[i][1])) {\n                if (dup.isEmpty()) break;\n                cur += A[i][0] - dup.remove(dup.size() - 1);\n            }\n            seen.add(A[i][1]);\n            res = Math.max(res, cur + 1L * seen.size() * seen.size());\n        }\n        return res;\n    }\n}", "writer": "Human"}
{"code": "class Solution {\n    public int maxSum(int[] nums) {\n    int ans = -1;\n    Map<Integer,List<Integer>> ump = new HashMap<>();\n    for(int i = 0; i < nums.length; ++i){\n        int t = nums[i], maxDigit = 0;\n        while(t != 0){ //evaluate max digit in the number\n            maxDigit = Math.max(t%10, maxDigit);\n            t = t/10;\n        }\n        if(!ump.containsKey(maxDigit)) ump.put(maxDigit, new ArrayList<>());\n        ump.get(maxDigit).add(nums[i]); // add the number to the map \n    }\n    for(Map.Entry<Integer, List<Integer>> entry: ump.entrySet()){\n        entry.getValue().sort(Comparator.reverseOrder()); //to find max two number in each max digit \n        if(entry.getValue().size() >= 2) ans = Math.max(ans, entry.getValue().get(0) + entry.getValue().get(1)); //sum max two number and take max\n    }\n    return ans;\n    }\n}", "writer": "Human"}
{"code": "class Solution {\n    public String finalString(String s) {\n        StringBuilder nm=new StringBuilder();\n        for(char c:s.toCharArray())\n        {\n            if(c=='i')\n            {\n                nm.reverse();\n            }\n            else\n            {\n                nm.append(c);\n            }\n        }\n        return nm.toString();\n    }\n}", "writer": "Human"}
{"code": "class Solution {\n    int minAbsoluteDifference(List<Integer> nums, int x) {\n        int ans = Integer.MAX_VALUE;\n        TreeSet<Integer> s = new TreeSet<>();\n        for(int i = x; i < nums.size(); ++i){\n            s.add(nums.get(i-x));\n            Integer high = s.ceiling(nums.get(i)), low = s.floor(nums.get(i));\n            if(high != null) ans = Math.min(ans, Math.abs(nums.get(i) - high));\n            if(low != null) ans = Math.min(ans, Math.abs(nums.get(i) - low));\n        }\n        return ans;\n    }\n}", "writer": "Human"}
{"code": "class Solution {\n    public ListNode doubleIt(ListNode head) {\n        if (head.val > 4)\n            head = new ListNode(0, head);\n        for(ListNode node = head; node != null; node = node.next) {\n            node.val = (node.val * 2) % 10;\n            if (node.next != null && node.next.val > 4)\n                node.val++;\n        }\n        return head;\n    }\n}", "writer": "Human"}
{"code": "class Solution {\n    static final int MOD = 1000000007;\n\n    public int maximumScore(List<Integer> nums, int k) {\n        int n = nums.size();\n\n        int upper = Collections.max(nums) + 1;\n\n        boolean[] prime = new boolean[upper];\n        int[] primeScore = new int[upper];\n        Arrays.fill(prime, true);\n        prime[0] = prime[1] = false;\n        for (int i = 2; i < upper; i++) {\n            if (prime[i]) {\n                for (int j = i; j < upper; j += i) {\n                    primeScore[j]++;\n                    prime[j] = false;\n                }\n            }\n        }\n\n        int[] nextGreaterElement = new int[n];\n        Arrays.fill(nextGreaterElement, n);\n        Stack<Integer> s = new Stack<>();\n        for (int i = n - 1; i >= 0; i--) {\n            while (!s.empty() && primeScore[nums.get(i)] >= primeScore[nums.get(s.peek())]) {\n                s.pop();\n            }\n            nextGreaterElement[i] = s.empty() ? n : s.peek();\n            s.push(i);\n        }\n\n        int[] prevGreaterOrEqualElement = new int[n];\n        Arrays.fill(prevGreaterOrEqualElement, -1);\n        s = new Stack<>();\n        for (int i = 0; i < n; i++) {\n            while (!s.empty() && primeScore[nums.get(i)] > primeScore[nums.get(s.peek())]) {\n                s.pop();\n            }\n            prevGreaterOrEqualElement[i] = s.empty() ? -1 : s.peek();\n            s.push(i);\n        }\n\n        int res = 1;\n        int[][] tuples = new int[n][2];\n        for (int i = 0; i < n; i++) {\n            tuples[i][0] = nums.get(i);\n            tuples[i][1] = i;\n        }\n        Arrays.sort(tuples, new Comparator<int[]>() {\n            public int compare(int[] a, int[] b) {\n                return b[0] - a[0];\n            }\n        });\n        for (int i = 0; i < n; i++) {\n            int num = tuples[i][0];\n            int idx = tuples[i][1];\n            int operations = Math.min((idx - prevGreaterOrEqualElement[idx]) * (nextGreaterElement[idx] - idx), k);\n            res = (int)((1L * res * pow(num, operations)) % MOD);\n            k -= operations;\n            if (k == 0) {\n                return res;\n            }\n        }\n\n        return res;\n    }\n\n    public int pow(int x, int n) {\n        int res = 1;\n        while (n > 0) {\n            if (n % 2 == 1) {\n                res = (int)((1L * res * x) % MOD);\n            }\n            x = (int)((1L * x * x) % MOD);\n            n /= 2;\n        }\n        return res;\n    }\n}", "writer": "Human"}
{"code": "class Solution {\n    public long findMaximumElegance(int[][] A, int k) {\n        Arrays.sort(A, (a, b) -> b[0] - a[0]);\n        long res = 0, cur = 0;\n        List<Integer> dup = new ArrayList<>();\n        Set<Integer> seen = new HashSet<>();\n        for (int i = 0; i < A.length; ++i) {\n            if (i < k) {\n                if (seen.contains(A[i][1])) {\n                    dup.add(A[i][0]);\n                }\n                cur += A[i][0];\n            } else if (!seen.contains(A[i][1])) {\n                if (dup.isEmpty()) break;\n                cur += A[i][0] - dup.remove(dup.size() - 1);\n            }\n            seen.add(A[i][1]);\n            res = Math.max(res, cur + 1L * seen.size() * seen.size());\n        }\n        return res;\n    }\n}", "writer": "Human"}
{"code": "class Solution {\n    public int maxSum(int[] nums) {\n    int ans = -1;\n    Map<Integer,List<Integer>> ump = new HashMap<>();\n    for(int i = 0; i < nums.length; ++i){\n        int t = nums[i], maxDigit = 0;\n        while(t != 0){ //evaluate max digit in the number\n            maxDigit = Math.max(t%10, maxDigit);\n            t = t/10;\n        }\n        if(!ump.containsKey(maxDigit)) ump.put(maxDigit, new ArrayList<>());\n        ump.get(maxDigit).add(nums[i]); // add the number to the map \n    }\n    for(Map.Entry<Integer, List<Integer>> entry: ump.entrySet()){\n        entry.getValue().sort(Comparator.reverseOrder()); //to find max two number in each max digit \n        if(entry.getValue().size() >= 2) ans = Math.max(ans, entry.getValue().get(0) + entry.getValue().get(1)); //sum max two number and take max\n    }\n    return ans;\n    }\n}", "writer": "Human"}
{"code": "class Solution {\n    public String finalString(String s) {\n        StringBuilder nm=new StringBuilder();\n        for(char c:s.toCharArray())\n        {\n            if(c=='i')\n            {\n                nm.reverse();\n            }\n            else\n            {\n                nm.append(c);\n            }\n        }\n        return nm.toString();\n    }\n}", "writer": "Human"}
{"code": "class Solution {\n    int minAbsoluteDifference(List<Integer> nums, int x) {\n        int ans = Integer.MAX_VALUE;\n        TreeSet<Integer> s = new TreeSet<>();\n        for(int i = x; i < nums.size(); ++i){\n            s.add(nums.get(i-x));\n            Integer high = s.ceiling(nums.get(i)), low = s.floor(nums.get(i));\n            if(high != null) ans = Math.min(ans, Math.abs(nums.get(i) - high));\n            if(low != null) ans = Math.min(ans, Math.abs(nums.get(i) - low));\n        }\n        return ans;\n    }\n}", "writer": "Human"}
{"code": "class Solution {\n    public ListNode doubleIt(ListNode head) {\n        if (head.val > 4)\n            head = new ListNode(0, head);\n        for(ListNode node = head; node != null; node = node.next) {\n            node.val = (node.val * 2) % 10;\n            if (node.next != null && node.next.val > 4)\n                node.val++;\n        }\n        return head;\n    }\n}", "writer": "Human"}
{"code": "class Solution {\n    static final int MOD = 1000000007;\n\n    public int maximumScore(List<Integer> nums, int k) {\n        int n = nums.size();\n\n        int upper = Collections.max(nums) + 1;\n\n        boolean[] prime = new boolean[upper];\n        int[] primeScore = new int[upper];\n        Arrays.fill(prime, true);\n        prime[0] = prime[1] = false;\n        for (int i = 2; i < upper; i++) {\n            if (prime[i]) {\n                for (int j = i; j < upper; j += i) {\n                    primeScore[j]++;\n                    prime[j] = false;\n                }\n            }\n        }\n\n        int[] nextGreaterElement = new int[n];\n        Arrays.fill(nextGreaterElement, n);\n        Stack<Integer> s = new Stack<>();\n        for (int i = n - 1; i >= 0; i--) {\n            while (!s.empty() && primeScore[nums.get(i)] >= primeScore[nums.get(s.peek())]) {\n                s.pop();\n            }\n            nextGreaterElement[i] = s.empty() ? n : s.peek();\n            s.push(i);\n        }\n\n        int[] prevGreaterOrEqualElement = new int[n];\n        Arrays.fill(prevGreaterOrEqualElement, -1);\n        s = new Stack<>();\n        for (int i = 0; i < n; i++) {\n            while (!s.empty() && primeScore[nums.get(i)] > primeScore[nums.get(s.peek())]) {\n                s.pop();\n            }\n            prevGreaterOrEqualElement[i] = s.empty() ? -1 : s.peek();\n            s.push(i);\n        }\n\n        int res = 1;\n        int[][] tuples = new int[n][2];\n        for (int i = 0; i < n; i++) {\n            tuples[i][0] = nums.get(i);\n            tuples[i][1] = i;\n        }\n        Arrays.sort(tuples, new Comparator<int[]>() {\n            public int compare(int[] a, int[] b) {\n                return b[0] - a[0];\n            }\n        });\n        for (int i = 0; i < n; i++) {\n            int num = tuples[i][0];\n            int idx = tuples[i][1];\n            int operations = Math.min((idx - prevGreaterOrEqualElement[idx]) * (nextGreaterElement[idx] - idx), k);\n            res = (int)((1L * res * pow(num, operations)) % MOD);\n            k -= operations;\n            if (k == 0) {\n                return res;\n            }\n        }\n\n        return res;\n    }\n\n    public int pow(int x, int n) {\n        int res = 1;\n        while (n > 0) {\n            if (n % 2 == 1) {\n                res = (int)((1L * res * x) % MOD);\n            }\n            x = (int)((1L * x * x) % MOD);\n            n /= 2;\n        }\n        return res;\n    }\n}", "writer": "Human"}
{"code": "class Solution {\n    public long findMaximumElegance(int[][] A, int k) {\n        Arrays.sort(A, (a, b) -> b[0] - a[0]);\n        long res = 0, cur = 0;\n        List<Integer> dup = new ArrayList<>();\n        Set<Integer> seen = new HashSet<>();\n        for (int i = 0; i < A.length; ++i) {\n            if (i < k) {\n                if (seen.contains(A[i][1])) {\n                    dup.add(A[i][0]);\n                }\n                cur += A[i][0];\n            } else if (!seen.contains(A[i][1])) {\n                if (dup.isEmpty()) break;\n                cur += A[i][0] - dup.remove(dup.size() - 1);\n            }\n            seen.add(A[i][1]);\n            res = Math.max(res, cur + 1L * seen.size() * seen.size());\n        }\n        return res;\n    }\n}", "writer": "Human"}
{"code": "class Solution {\n    public int maxSum(int[] nums) {\n    int ans = -1;\n    Map<Integer,List<Integer>> ump = new HashMap<>();\n    for(int i = 0; i < nums.length; ++i){\n        int t = nums[i], maxDigit = 0;\n        while(t != 0){ //evaluate max digit in the number\n            maxDigit = Math.max(t%10, maxDigit);\n            t = t/10;\n        }\n        if(!ump.containsKey(maxDigit)) ump.put(maxDigit, new ArrayList<>());\n        ump.get(maxDigit).add(nums[i]); // add the number to the map \n    }\n    for(Map.Entry<Integer, List<Integer>> entry: ump.entrySet()){\n        entry.getValue().sort(Comparator.reverseOrder()); //to find max two number in each max digit \n        if(entry.getValue().size() >= 2) ans = Math.max(ans, entry.getValue().get(0) + entry.getValue().get(1)); //sum max two number and take max\n    }\n    return ans;\n    }\n}", "writer": "Human"}
{"code": "class Solution {\n    public String finalString(String s) {\n        StringBuilder nm=new StringBuilder();\n        for(char c:s.toCharArray())\n        {\n            if(c=='i')\n            {\n                nm.reverse();\n            }\n            else\n            {\n                nm.append(c);\n            }\n        }\n        return nm.toString();\n    }\n}", "writer": "Human"}
{"code": "class Solution {\n    int minAbsoluteDifference(List<Integer> nums, int x) {\n        int ans = Integer.MAX_VALUE;\n        TreeSet<Integer> s = new TreeSet<>();\n        for(int i = x; i < nums.size(); ++i){\n            s.add(nums.get(i-x));\n            Integer high = s.ceiling(nums.get(i)), low = s.floor(nums.get(i));\n            if(high != null) ans = Math.min(ans, Math.abs(nums.get(i) - high));\n            if(low != null) ans = Math.min(ans, Math.abs(nums.get(i) - low));\n        }\n        return ans;\n    }\n}", "writer": "Human"}
{"code": "class Solution {\n    public ListNode doubleIt(ListNode head) {\n        if (head.val > 4)\n            head = new ListNode(0, head);\n        for(ListNode node = head; node != null; node = node.next) {\n            node.val = (node.val * 2) % 10;\n            if (node.next != null && node.next.val > 4)\n                node.val++;\n        }\n        return head;\n    }\n}", "writer": "Human"}
{"code": "class Solution {\n    static final int MOD = 1000000007;\n\n    public int maximumScore(List<Integer> nums, int k) {\n        int n = nums.size();\n\n        int upper = Collections.max(nums) + 1;\n\n        boolean[] prime = new boolean[upper];\n        int[] primeScore = new int[upper];\n        Arrays.fill(prime, true);\n        prime[0] = prime[1] = false;\n        for (int i = 2; i < upper; i++) {\n            if (prime[i]) {\n                for (int j = i; j < upper; j += i) {\n                    primeScore[j]++;\n                    prime[j] = false;\n                }\n            }\n        }\n\n        int[] nextGreaterElement = new int[n];\n        Arrays.fill(nextGreaterElement, n);\n        Stack<Integer> s = new Stack<>();\n        for (int i = n - 1; i >= 0; i--) {\n            while (!s.empty() && primeScore[nums.get(i)] >= primeScore[nums.get(s.peek())]) {\n                s.pop();\n            }\n            nextGreaterElement[i] = s.empty() ? n : s.peek();\n            s.push(i);\n        }\n\n        int[] prevGreaterOrEqualElement = new int[n];\n        Arrays.fill(prevGreaterOrEqualElement, -1);\n        s = new Stack<>();\n        for (int i = 0; i < n; i++) {\n            while (!s.empty() && primeScore[nums.get(i)] > primeScore[nums.get(s.peek())]) {\n                s.pop();\n            }\n            prevGreaterOrEqualElement[i] = s.empty() ? -1 : s.peek();\n            s.push(i);\n        }\n\n        int res = 1;\n        int[][] tuples = new int[n][2];\n        for (int i = 0; i < n; i++) {\n            tuples[i][0] = nums.get(i);\n            tuples[i][1] = i;\n        }\n        Arrays.sort(tuples, new Comparator<int[]>() {\n            public int compare(int[] a, int[] b) {\n                return b[0] - a[0];\n            }\n        });\n        for (int i = 0; i < n; i++) {\n            int num = tuples[i][0];\n            int idx = tuples[i][1];\n            int operations = Math.min((idx - prevGreaterOrEqualElement[idx]) * (nextGreaterElement[idx] - idx), k);\n            res = (int)((1L * res * pow(num, operations)) % MOD);\n            k -= operations;\n            if (k == 0) {\n                return res;\n            }\n        }\n\n        return res;\n    }\n\n    public int pow(int x, int n) {\n        int res = 1;\n        while (n > 0) {\n            if (n % 2 == 1) {\n                res = (int)((1L * res * x) % MOD);\n            }\n            x = (int)((1L * x * x) % MOD);\n            n /= 2;\n        }\n        return res;\n    }\n}", "writer": "Human"}
{"code": "class Solution {\n    public long findMaximumElegance(int[][] A, int k) {\n        Arrays.sort(A, (a, b) -> b[0] - a[0]);\n        long res = 0, cur = 0;\n        List<Integer> dup = new ArrayList<>();\n        Set<Integer> seen = new HashSet<>();\n        for (int i = 0; i < A.length; ++i) {\n            if (i < k) {\n                if (seen.contains(A[i][1])) {\n                    dup.add(A[i][0]);\n                }\n                cur += A[i][0];\n            } else if (!seen.contains(A[i][1])) {\n                if (dup.isEmpty()) break;\n                cur += A[i][0] - dup.remove(dup.size() - 1);\n            }\n            seen.add(A[i][1]);\n            res = Math.max(res, cur + 1L * seen.size() * seen.size());\n        }\n        return res;\n    }\n}", "writer": "Human"}
{"code": "fun findLargestElement(array: IntArray) : Int {\n  if (array.isEmpty()) {\n    return -1\n  }\n\n  var maximum = array[0]\n\n  for (item in array) {\n    if (item > maximum) {\n      maximum = item\n    }\n  }\n\n  return maximum\n    \n}", "writer": "Human"}
{"code": "str_helloworld = \"Hello World!\"\n\nstr_hw_splitted = str_helloworld.split(\" \")\n\nstr_reverse = str_hw_splitted[::-1]\n\nprint(str_helloworld, \"-> \", str_reverse[0], str_reverse[1])", "writer": "Human"}
{"code": "static boolean sieveOfEratosthenes(int checkNumber) {\n  if (checkNumber == 0 || checkNumber == 1) return false;\n\n  boolean prime[] = new boolean[checkNumber+1];\n  for(int i = 1; i <= checkNumber; i++) \n    prime[i] = true;\n\n  for(int j = 2; j*j <= checkNumber; j++){\n    if(prime[j]) {\n      for(int i = j*j; i <= checkNumber; i+=j) {\n        prime[i] = false;\n      }\n    }\n  }\n  return prime[checkNumber];\n}\n\npublic static void main(String[] args) {\n  int checkNumber = 7;\n  System.out.println(sieveOfEratosthenes(checkNumber));\n}", "writer": "Human"}
{"code": "Class reverse{\n  public Static void main(String args[]){\n    String s=\"hello\"\n    String st=\" \"\n    for(i=0;i<s.length;i++){\n      ch=s.charAt(i)\n      st=st+ch;  \n    }  \n    System.out.println(st)  \n  }\n}", "writer": "Human"}
{"code": "import java.util.Scanner;\n \nclass palindrome {\n    public static void main(String[] args) {\n        Scanner scanner=new Scanner(System.in);\n        System.out.println(\"Enter a string as an input to check whether it is palindrome or not\");\n        String input= scanner.nextLine();\n        //checking whether palindrome or not\n        if(isPalindrome(input))\n        {\n            System.out.println(input+\" is a palindrome string\");\n        }\n        else\n        {\n            System.out.println(input+\" is not a palindrome string\");\n        }\n    }\n \n    public static boolean isPalindrome(String str) {\n        int left = 0, right = str.length() - 1;\n        \n        while(left < right)\n        {\n            if(str.charAt(left) != str.charAt(right))\n            {\n                return false;\n            }\n            left++;\n            right--;\n        }\n        return true;\n    } \n}", "writer": "Human"}
{"code": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class TwoSum {\n    public static int[] findTwoSum(int[] nums, int target) {\n        Map<Integer, Integer> numIndices = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (numIndices.containsKey(complement)) {\n                return new int[] { numIndices.get(complement), i };\n            }\n            numIndices.put(nums[i], i);\n        }\n        return new int[] {}; // return an empty array if no solution\n    }\n    \n    public static void main(String[] args) {\n        int[] nums = {2, 7, 11, 15};\n        int target = 9;\n        int[] indices = findTwoSum(nums, target);\n        if (indices.length == 2) {\n            System.out.println(\"Output: [\" + indices[0] + \", \" + indices[1] + \"]\");\n        } else {\n            System.out.println(\"No solution found.\");\n        }\n    }\n}", "writer": "Human"}
{"code": "public class Solution {\n    public int maxSum(int[] nums) {\n        int[] maxSum = new int[10];\n        for (int num : nums) {\n            int maxDigit = 0;\n            int temp = num;\n            while (temp > 0) {\n                maxDigit = Math.max(maxDigit, temp % 10);\n                temp /= 10;\n            }\n            for (int i = 0; i < 10; i++) {\n                if (i == maxDigit) {\n                    maxSum[i] = Math.max(maxSum[i], num + maxSum[i]);\n                } else {\n                    maxSum[i] = Math.max(maxSum[i], num);\n                }\n            }\n        }\n        int res = -1;\n        for (int sum : maxSum) {\n            res = Math.max(res, sum);\n        }\n        return res == 0 ? -1 : res;\n    }\n}", "writer": "AI"}
{"code": "class Solution {\n    public String finalString(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (char c : s.toCharArray()) {\n            if (c == 'i') {\n                sb.reverse();\n            } else {\n                sb.append(c);\n            }\n        }\n        return sb.toString();\n    }\n}", "writer": "AI"}
{"code": "public class Solution {\n    public int minAbsoluteDifference(List<Integer> nums, int x) {\n        TreeMap<Integer, Integer> map = new TreeMap<>();\n        map.put(nums.get(0), 0);\n        int n = nums.size();\n        int minDiff = Integer.MAX_VALUE;\n\n        for (int i = 1; i < n; i++) {\n            if (i >= x) {\n                map.remove(nums.get(i - x));\n            }\n            Integer lower = map.floorKey(nums.get(i));\n            Integer higher = map.ceilingKey(nums.get(i));\n            if (lower != null) {\n                minDiff = Math.min(minDiff, Math.abs(nums.get(i) - lower));\n            }\n            if (higher != null) {\n                minDiff = Math.min(minDiff, Math.abs(nums.get(i) - higher));\n            }\n            map.put(nums.get(i), i);\n        }\n\n        return minDiff;\n    }\n}", "writer": "AI"}
{"code": "class Solution {\n    public ListNode doubleIt(ListNode head) {\n        // Convert linked list to number\n        long num = 0;\n        while (head != null) {\n            num = num * 10 + head.val;\n            head = head.next;\n        }\n\n        // Double the number\n        num *= 2;\n\n        // Convert number back to linked list\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        do {\n            curr.next = new ListNode((int)(num % 10));\n            num /= 10;\n            curr = curr.next;\n        } while (num > 0);\n\n        // Reverse the linked list and return\n        return reverse(dummy.next);\n    }\n\n    private ListNode reverse(ListNode head) {\n        ListNode prev = null;\n        while (head != null) {\n            ListNode next = head.next;\n            head.next = prev;\n            prev = head;\n            head = next;\n        }\n        return prev;\n    }\n}", "writer": "AI"}
{"code": "public class Solution {\n    private static final int MOD = 1_000_000_007;\n    private List<Integer> nums;\n    private int n;\n    private List<Integer>[] factors;\n\n    public int maximumScore(List<Integer> nums, int k) {\n        this.nums = nums;\n        this.n = nums.size();\n        this.factors = new ArrayList[n];\n        for (int i = 0; i < n; i++) {\n            factors[i] = primeFactors(nums.get(i));\n        }\n\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> b[2] - a[2]);\n        pq.offer(new int[]{0, n - 1, maxPrimeScore(0, n - 1)});\n\n        long res = 1;\n        boolean[] chosen = new boolean[n];\n        while (k-- > 0) {\n            int[] cur = pq.poll();\n            int l = cur[0], r = cur[1], maxScore = cur[2];\n            res = (res * maxScore) % MOD;\n\n            int maxIdx = maxPrimeScoreIndex(l, r);\n            chosen[maxIdx] = true;\n\n            if (maxIdx - 1 >= l && !chosen[maxIdx - 1]) {\n                pq.offer(new int[]{l, maxIdx - 1, maxPrimeScore(l, maxIdx - 1)});\n            }\n            if (maxIdx + 1 <= r && !chosen[maxIdx + 1]) {\n                pq.offer(new int[]{maxIdx + 1, r, maxPrimeScore(maxIdx + 1, r)});\n            }\n        }\n\n        return (int) res;\n    }\n\n    private List<Integer> primeFactors(int num) {\n        List<Integer> factors = new ArrayList<>();\n        for (int i = 2; i * i <= num; i++) {\n            if (num % i == 0) {\n                factors.add(i);\n                while (num % i == 0) {\n                    num /= i;\n                }\n            }\n        }\n        if (num > 1) {\n            factors.add(num);\n        }\n        return factors;\n    }\n\n    private int maxPrimeScore(int l, int r) {\n        int maxScore = 0;\n        for (int i = l; i <= r; i++) {\n            maxScore = Math.max(maxScore, factors[i].size());\n        }\n        return maxScore;\n    }\n\n    private int maxPrimeScoreIndex(int l, int r) {\n        int maxScore = 0, idx = -1;\n        for (int i = l; i <= r; i++) {\n            if (factors[i].size() >= maxScore) {\n                maxScore = factors[i].size();\n                idx = i;\n            }\n        }\n        return idx;\n    }\n}", "writer": "AI"}
{"code": "class Solution {\n    private static final int MOD = 1_000_000_007;\n\n    public int findMaximumElegance(int[][] items, int k) {\n        int n = items.length;\n        List<int[]>[] categoryItems = new List[n + 1];\n        for (int i = 0; i <= n; i++) {\n            categoryItems[i] = new ArrayList<>();\n        }\n        for (int[] item : items) {\n            categoryItems[item[1]].add(item);\n        }\n\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\n        long[] dp = new long[k + 1];\n        dp[0] = 0;\n        int totalItems = 0;\n        for (List<int[]> itemList : categoryItems) {\n            if (itemList.isEmpty()) continue;\n\n            Collections.sort(itemList, Comparator.comparingInt(a -> -a[0]));\n            int categoryProfit = 0;\n            for (int[] item : itemList) {\n                categoryProfit += item[0];\n                pq.offer(item[0]);\n                if (pq.size() > totalItems + 1) {\n                    categoryProfit -= pq.poll();\n                }\n            }\n\n            for (int j = Math.min(k, totalItems + itemList.size()); j >= 0; j--) {\n                for (int l = Math.max(0, j - totalItems); l <= Math.min(j, itemList.size()); l++) {\n                    dp[j] = Math.max(dp[j], (j - l > 0 ? dp[j - l - 1] : 0) + categoryProfit);\n                }\n            }\n\n            totalItems += itemList.size();\n        }\n\n        long res = 0;\n        for (int i = 1; i <= k; i++) {\n            res = Math.max(res, dp[i] + (long)i * i);\n        }\n\n        return (int)(res % MOD);\n    }\n}", "writer": "AI"}
{"code": "public class Solution {\n    public int maxSum(int[] nums) {\n        // Create an array of size 10 to keep track of the maximum values for each digit (0-9)\n        int[] maxDigits = new int[10];\n        \n        // Iterate through the array and update the maxDigits array with the maximum values for each digit\n        for (int num : nums) {\n            int maxDigit = getMaxDigit(num);\n            maxDigits[maxDigit] = Math.max(maxDigits[maxDigit], num);\n        }\n        \n        int maxSum = -1;\n        \n        // Iterate through the maxDigits array to find pairs with equal maximum digits\n        for (int i = 0; i <= 9; i++) {\n            for (int j = i; j <= 9; j++) {\n                if (maxDigits[i] != 0 && maxDigits[j] != 0 && i == j) {\n                    maxSum = Math.max(maxSum, maxDigits[i] + maxDigits[j]);\n                }\n            }\n        }\n        \n        return maxSum;\n    }\n    \n    // Helper method to get the maximum digit from a number\n    private int getMaxDigit(int num) {\n        int maxDigit = 0;\n        while (num > 0) {\n            maxDigit = Math.max(maxDigit, num % 10);\n            num /= 10;\n        }\n        return maxDigit;\n    }\n    \n}", "writer": "AI"}
{"code": "public class Solution {\n    public String finalString(String s) {\n        StringBuilder result = new StringBuilder();\n        StringBuilder reverseBuffer = new StringBuilder();\n        \n        boolean reverse = false;\n        \n        for (char c : s.toCharArray()) {\n            if (c == 'i') {\n                reverse = !reverse;\n            } else {\n                if (reverse) {\n                    reverseBuffer.insert(0, c);\n                } else {\n                    result.append(c);\n                }\n            }\n        }\n        \n        result.append(reverseBuffer);\n        \n        return result.toString();\n    }\n    \n}", "writer": "AI"}
{"code": "public class Solution {\n    public int minAbsoluteDifference(List<Integer> nums, int x) {\n        int n = nums.size();\n        int minAbsDiff = Integer.MAX_VALUE;\n        \n        // Create a TreeMap to store the indices of elements\n        TreeMap<Integer, Integer> indexMap = new TreeMap<>();\n        \n        for (int i = 0; i < n; i++) {\n            int num = nums.get(i);\n            \n            // Check if there exists a number in the TreeMap with a difference of at least x\n            // from the current number, and update the minimum absolute difference accordingly.\n            Integer floorKey = indexMap.floorKey(num - x);\n            if (floorKey != null) {\n                int index = indexMap.get(floorKey);\n                minAbsDiff = Math.min(minAbsDiff, Math.abs(num - nums.get(index)));\n            }\n            \n            // Check if there exists a number in the TreeMap with a difference of at least x\n            // from the current number, and update the minimum absolute difference accordingly.\n            Integer ceilingKey = indexMap.ceilingKey(num + x);\n            if (ceilingKey != null) {\n                int index = indexMap.get(ceilingKey);\n                minAbsDiff = Math.min(minAbsDiff, Math.abs(num - nums.get(index)));\n            }\n            \n            // Update the index of the current number in the TreeMap.\n            indexMap.put(num, i);\n        }\n        \n        return minAbsDiff;\n    }\n   \n}", "writer": "AI"}
{"code": "public class Solution {\n    public ListNode doubleIt(ListNode head) {\n        if (head == null) {\n            return null;\n        }\n\n        int carry = 0;\n        ListNode current = head;\n        ListNode prev = null;\n\n        // Traverse the list in reverse order and double the values\n        while (current != null) {\n            int newVal = current.val * 2 + carry;\n            carry = newVal / 10;\n            current.val = newVal % 10;\n\n            prev = current;\n            current = current.next;\n        }\n\n        // If there's a remaining carry, add a new node for it\n        if (carry > 0) {\n            ListNode newNode = new ListNode(carry);\n            prev.next = newNode;\n        }\n\n        return reverseList(head);\n    }\n\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode current = head;\n\n        while (current != null) {\n            ListNode nextNode = current.next;\n            current.next = prev;\n            prev = current;\n            current = nextNode;\n        }\n\n        return prev;\n    }\n}", "writer": "AI"}
{"code": "public class Solution {\n    public int maximumScore(List<Integer> nums, int k) {\n        int MOD = 1000000007;\n        int n = nums.size();\n        \n        // Create an array to store the prime scores for each element.\n        int[] primeScores = new int[n];\n        \n        // Calculate the prime scores for each element using a helper function.\n        for (int i = 0; i < n; i++) {\n            primeScores[i] = calculatePrimeScore(nums.get(i));\n        }\n        \n        long score = 1L; // Initialize the score as a long integer to avoid overflow.\n        \n        // Create a max heap to keep track of the elements with the highest prime scores.\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<>((a, b) -> Integer.compare(primeScores[b], primeScores[a]));\n        \n        // Initialize the max heap with the element at index k.\n        maxHeap.offer(k);\n        \n        // Create two arrays to keep track of the left and right boundaries of the subarray.\n        int[] left = new int[n];\n        int[] right = new int[n];\n        \n        // Initialize the left and right boundaries.\n        left[k] = k;\n        right[k] = k;\n        \n        // Perform at most k operations.\n        for (int i = 0; i < k; i++) {\n            int maxIndex = maxHeap.poll(); // Get the index with the highest prime score.\n            \n            // Calculate the new score by multiplying the current score by the selected element.\n            score = (score * nums.get(maxIndex)) % MOD;\n            \n            // Update the left and right boundaries for the subarray.\n            int newLeft = left[maxIndex] - 1;\n            int newRight = right[maxIndex] + 1;\n            \n            // Add the new potential candidates to the max heap.\n            if (newLeft >= 0) {\n                maxHeap.offer(newLeft);\n                left[newLeft] = newLeft;\n                right[newLeft] = right[maxIndex];\n            }\n            if (newRight < n) {\n                maxHeap.offer(newRight);\n                left[newRight] = left[maxIndex];\n                right[newRight] = newRight;\n            }\n        }\n        \n        return (int)score;\n    }\n    \n    // Helper function to calculate the prime score of an integer.\n    private int calculatePrimeScore(int num) {\n        Set<Integer> factors = new HashSet<>();\n        \n        // Find prime factors of the number.\n        while (num % 2 == 0) {\n            factors.add(2);\n            num /= 2;\n        }\n        \n        for (int i = 3; i <= Math.sqrt(num); i += 2) {\n            while (num % i == 0) {\n                factors.add(i);\n                num /= i;\n            }\n        }\n        \n        if (num > 2) {\n            factors.add(num);\n        }\n        \n        return factors.size();\n    }\n}", "writer": "AI"}
{"code": "public class Solution {\n    public int findMaximumElegance(int[][] items, int k) {\n        List<int[]> itemList = new ArrayList<>();\n        Map<Integer, Integer> categoryFreq = new HashMap<>();\n        int totalProfit = 0;\n        int distinctCategories = 0;\n        int maxElegance = 0;\n\n        for (int[] item : items) {\n            itemList.add(item);\n        }\n\n        Collections.sort(itemList, (a, b) -> b[0] - a[0]); // Sort by profit in descending order\n\n        for (int i = 0; i < itemList.size(); i++) {\n            int[] item = itemList.get(i);\n            int profit = item[0];\n            int category = item[1];\n\n            categoryFreq.put(category, categoryFreq.getOrDefault(category, 0) + 1);\n            totalProfit += profit;\n\n            if (categoryFreq.get(category) == 1) {\n                distinctCategories++;\n            }\n\n            int elegance = totalProfit + distinctCategories * distinctCategories;\n            maxElegance = Math.max(maxElegance, elegance);\n\n            if (distinctCategories == k) {\n                break; // We have reached the required number of distinct categories\n            }\n        }\n\n        return maxElegance;\n    }\n}", "writer": "AI"}
{"code": "class Solution {\n    public int maxSum(int[] nums) {\n        int max = 0;\n        int maxDigit = 0;\n        for(int i = 0; i < nums.length; i++){\n            int digit = 0;\n            int num = nums[i];\n            while(num > 0){\n                digit = Math.max(digit, num % 10);\n                num /= 10;\n            }\n            if(digit > maxDigit){\n                maxDigit = digit;\n                max = nums[i];\n            }\n            else if(digit == maxDigit){\n                max = Math.max(max, nums[i]);\n            }\n        }\n        \n        int maxSum = 0;\n        for(int i = 0; i < nums.length; i++){\n            int digit = 0;\n            int num = nums[i];\n            while(num > 0){\n                digit = Math.max(digit, num % 10);\n                num /= 10;\n            }\n            if(digit == maxDigit){\n                maxSum = Math.max(maxSum, nums[i]);\n            }\n        }\n        \n        if(maxSum == 0){\n            return -1;\n        }\n        \n        int sum = 0;\n        for(int i = 0; i < nums.length; i++){\n            if(nums[i] == max){\n                sum += nums[i];\n            }\n            else if(nums[i] == maxSum){\n                sum += nums[i];\n            }\n        }\n        \n        return sum;\n    }\n}", "writer": "AI"}
{"code": "class Solution {\n    public String finalString(String s) {\n        StringBuilder sb = new StringBuilder();\n        for(int i = 0; i < s.length(); i++){\n            if(s.charAt(i) == 'i'){\n                sb.reverse();\n            }\n            else{\n                sb.append(s.charAt(i));\n            }\n        }\n        return sb.toString();\n    }\n}", "writer": "AI"}
{"code": "class Solution {\n    public int minAbsoluteDifference(List<Integer> nums, int x) {\n        int min = Integer.MAX_VALUE;\n        int n = nums.size();\n        for(int i = 0; i < n; i++){\n            for(int j = i + x; j < n; j++){\n                min = Math.min(min, Math.abs(nums.get(i) - nums.get(j)));\n            }\n        }\n        return min;\n    }\n}", "writer": "AI"}
{"code": "class Solution {\n    public ListNode doubleIt(ListNode head) {\n        ListNode temp = head;\n        ListNode prev = null;\n        while(temp!=null){\n            int val = temp.val;\n            temp.val = val*2;\n            if(temp.val>9){\n                temp.val = temp.val%10;\n                if(prev!=null){\n                    prev.val+=1;\n                }\n            }\n            prev = temp;\n            temp = temp.next;\n        }\n        return head;\n    }\n}", "writer": "AI"}
{"code": "class Solution {\n    public int maximumScore(List<Integer> nums, int k) {\n        int n = nums.size();\n        int[][] dp = new int[n][k + 1];\n        for(int i = 0; i < n; i++)\n            Arrays.fill(dp[i], -1);\n        return dfs(nums, 0, k, dp);\n    }\n    public int dfs(List<Integer> nums, int i, int k, int[][] dp){\n        if(i == nums.size())\n            return 1;\n        if(k == 0)\n            return 0;\n        if(dp[i][k] != -1)\n            return dp[i][k];\n        int ans = 0;\n        for(int j = i; j < nums.size(); j++){\n            ans = Math.max(ans, nums.get(j) * dfs(nums, j + 1, k - 1, dp));\n        }\n        return dp[i][k] = ans;\n    }\n}", "writer": "AI"}
{"code": "class Solution {\n    public long findMaximumElegance(int[][] items, int k) {\n        int n = items.length;\n        long[][] dp = new long[n + 1][k + 1];\n        for (int i = 1; i <= n; i++) {\n            int profit = items[i - 1][0];\n            int category = items[i - 1][1];\n            for (int j = 1; j <= k; j++) {\n                dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - 1] + profit);\n                if (category != items[i - 1][1]) {\n                    dp[i][j] = Math.max(dp[i][j], dp[i - 1][j] + profit);\n                }\n            }\n        }\n        long max = 0;\n        for (int i = 1; i <= k; i++) {\n            max = Math.max(max, dp[n][i]);\n        }\n        return max;\n    }\n}", "writer": "AI"}
{"code": "public class Solution{\n    public int maxSum(int[] nums) {\n        int max = -1;\n        for(int i = 0; i < nums.length; i++) {\n            for(int j = i + 1; j < nums.length;\n                    j++) {\n                if(nums[i] % 10 == nums[j] % 10) {\n                    max = Math.max(max, nums[i] + nums[j]);\n                }\n            }\n            \n        }\n        return max;\n        \n    }\n    \n}", "writer": "AI"}
{"code": "public class Solution {\n    public String finalString(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            if (c == 'i') {\n                sb.append(s.substring(i));\n                break;\n            }\n            sb.append(c);\n        }\n        return sb.toString();\n        \n    }\n    \n}", "writer": "AI"}
{"code": "class Solution {\n    public int minAbsoluteDifference(List<Integer> nums, int x) {\n        int min = Integer.MAX_VALUE;\n        int n = nums.size();\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                if (Math.abs(i - j) >= x) {\n                    min = Math.min(min, Math.abs(nums.get(i) - nums.get(j)));\n                }\n            }\n        }\n        return min;\n        \n    }\n    \n}", "writer": "AI"}
{"code": "class Solution {\n    public ListNode doubleIt(ListNode head) {\n        ListNode curr = head;\n        while (curr != null) {\n            curr.val *= 2;\n            curr = curr.next;\n        }\n        return head;\n        \n    }\n    \n}", "writer": "AI"}
{"code": "public class Solution {\n    public int maximumScore(List<Integer> nums, int k) {\n        int n = nums.size();\n        int[] primes = new int[n];\n        for (int i = 0; i < n; i++) {\n            primes[i] = primeFactors(nums.get(i));\n            if (primes[i] == 0) primes[i] = 1;\n            //System.out.println(primes[i]);\n        }\n        int[][] dp = new int[n][k + 1];\n        for (int i = 0; i < n; i++) {\n            dp[i][0] = 1;\n        }\n        for (int i = 1; i <= k; i++) {\n            for (int j = 0; j < n; j++) {\n                dp[j][i] = Math.max(dp[j][i - 1], dp[j - 1][i - 1] * primes[j]);\n            }\n        }\n        return dp[n - 1][k];\n        \n    }\n    \n    public int primeFactors(int n) {\n        int count = 0;\n        for (int i = 2; i <= n / i; i++) {\n            while (n % i == 0) {\n                n /= i;\n                count++;\n            }\n        }\n        if (n > 1) count++;\n        return count;\n    }\n    \n}", "writer": "AI"}
{"code": "public class Solution {\n    public int findMaximumElegance(int[][] items, int k) {\n        int n = items.length;\n        int[] category = new int[n];\n        for (int i = 0; i < n; i++) {\n            category[i] = items[i][1];\n        }\n        int[] count = new int[n + 1];\n        for (int i = 0; i < n; i++) {\n            count[category[i]]++;\n        }\n        for (int i = 1; i <= n; i++) {\n            count[i] += count[i - 1];\n        }\n        int[] dp = new int[n + 1];\n        for (int i = 0; i < n; i++) {\n            int index = count[category[i]];\n            dp[index] = Math.max(dp[index], dp[index - 1] + items[i][0]);\n        }\n        return dp[n];\n        \n    }\n\n}", "writer": "AI"}
{"code": "public class Solution {\n    public int maxSum(int[] nums) {\n        int max = -1;\n        for(int i = 0; i < nums.length; i++){\n            for(int j = i+1; j < nums.length;j++){\n                if(max < nums[i] + nums[j] && maxDigit(nums[i]) == maxDigit(nums[j])){\n                    max = nums[i] + nums[j];\n                }\n            }\n        }\n        return max;\n    }\n    public int maxDigit(int num){\n        int max = 0;\n        while(num > 0){\n            max = Math.max(max, num % 10);\n            num /= 10;\n        }\n        return max;\n    }\n}", "writer": "AI"}
{"code": "public class Solution {\n    public String finalString(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == 'i') {\n                sb.reverse();\n            } else {\n                sb.append(s.charAt(i));\n            }\n        }\n        return sb.toString();\n    }\n}", "writer": "AI"}
{"code": "class Solution {\n    public int minAbsoluteDifference(List<Integer> nums, int x) {\n        int min = Integer.MAX_VALUE;\n        int n = nums.size();\n        for(int i = 0; i < n; i++){\n            for(int j = i + x; j < n; j++){\n                min = Math.min(min, Math.abs(nums.get(i) - nums.get(j)));\n            }\n        }\n        return min;\n    }\n}", "writer": "AI"}
{"code": "class Solution {\n    public ListNode doubleIt(ListNode head) {\n        ListNode curr = head;\n        ListNode prev = null;\n        while(curr != null) {\n            ListNode next = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = next;\n        }\n        \n        ListNode newHead = prev;\n        ListNode newCurr = newHead;\n        ListNode carry = null;\n        while(newCurr != null) {\n            int sum = newCurr.val * 2;\n            if(carry != null) {\n                sum += carry.val;\n                carry = null;\n            }\n            if(sum > 9) {\n                carry = new ListNode(sum / 10);\n                sum = sum % 10;\n            }\n            newCurr.val = sum;\n            newCurr = newCurr.next;\n        }\n        if(carry != null) {\n            newCurr = newHead;\n            while(newCurr.next != null) {\n                newCurr = newCurr.next;\n            }\n            newCurr.next = carry;\n        }\n        return reverse(newHead);\n    }\n    \n    public ListNode reverse(ListNode head) {\n        ListNode curr = head;\n        ListNode prev = null;\n        while(curr != null) {\n            ListNode next = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = next;\n        }\n        \n        return prev;\n    }\n}", "writer": "AI"}
{"code": "public class Solution {\n    public int maximumScore(List<Integer> nums, int k) {\n        int n = nums.size();\n        int[] left = new int[n];\n        int[] right = new int[n];\n        Stack<Integer> stack = new Stack<>();\n        for (int i = 0; i < n; i++) {\n            while (!stack.isEmpty() && nums.get(stack.peek()) >= nums.get(i)) {\n                stack.pop();\n            }\n            left[i] = stack.isEmpty() ? -1 : stack.peek();\n            stack.push(i);\n        }\n        stack.clear();\n        for (int i = n - 1; i >= 0; i--) {\n            while (!stack.isEmpty() && nums.get(stack.peek()) >= nums.get(i)) {\n                stack.pop();\n            }\n            right[i] = stack.isEmpty() ? n : stack.peek();\n            stack.push(i);\n        }\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            if (left[i] < k && right[i] > k) {\n                ans = Math.max(ans, nums.get(i) * (right[i] - left[i] - 1));\n            }\n        }\n        return ans;\n    }\n}", "writer": "AI"}
{"code": "public class Solution {\n    public int findMaximumElegance(int[][] items, int k) {\n        int n = items.length;\n        int[] dp = new int[n];\n        Arrays.sort(items, (a, b) -> a[0] - b[0]);\n        int max = 0;\n        for (int i = 0; i < n; i++) {\n            int profit = items[i][0];\n            int category = items[i][1];\n            dp[i] = profit + category * category;\n            for (int j = 0; j < i; j++) {\n                if (items[j][1] != category) {\n                    dp[i] = Math.max(dp[i], dp[j] + profit + category * category);\n                }\n            }\n            if (i >= k - 1) {\n                max = Math.max(max, dp[i]);\n            }\n        }\n        return max;\n    }\n}", "writer": "AI"}
{"code": "class Solution {    \n    public int maxSum(int[] nums) {\n        int max = Integer.MIN_VALUE;\n        int sum = 0;\n        for (int i = 0; i < nums.length; i++) {\n            sum += nums[i];\n            if (nums[i] > max) {\n                max = nums[i];\n            }\n            if (max > 0 && nums[i] % max == 0) {\n                sum -= nums[i];\n            }\n        }\n        return sum;\n    }\n}", "writer": "AI"}
{"code": "public class Solution {    \n    public String finalString(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            if (c == 'i') {\n                sb.append(c);\n            } else {\n                sb.append(c);\n                sb.append(c);\n            }\n        }\n        return sb.toString();\n    }\n}", "writer": "AI"}
{"code": "class Solution {\n    int minAbsoluteDifference(List<Integer> nums, int x) {\n        int min = Integer.MAX_VALUE;\n        int max = Integer.MIN_VALUE;\n        for (int i = 0; i < nums.size(); i++) {\n            if (nums.get(i) < min) {\n                min = nums.get(i);\n            }\n            if (nums.get(i) > max) {\n                max = nums.get(i);\n            }\n        }\n        int diff = Integer.MAX_VALUE;\n        for (int i = 0; i < nums.size(); i++) {\n            if (Math.abs(nums.get(i) - min) >= x) {\n                diff = Math.min(diff, Math.abs(nums.get(i) - min));\n            }\n            if (Math.abs(nums.get(i) - max) >= x) {\n                diff = Math.min(diff, Math.abs(nums.get(i) - max));\n            }\n        }\n        return diff;\n    }\n}", "writer": "AI"}
{"code": "class Solution {\n    public ListNode doubleIt(ListNode head) {\n        ListNode curr = head;\n        int currVal = 0;\n        while (curr!= null) {\n            currVal += curr.val;\n            curr.val = currVal;\n            curr = curr.next;\n        }\n        curr = head;\n        while (curr!= null) {\n            curr.val = curr.val * 2;\n            curr = curr.next;\n        }\n        return head;\n    }\n}", "writer": "AI"}
{"code": "class Solution {    public int maximumScore(List<Integer> nums, int k) {\n        int n = nums.size();\n        int[] primes = new int[n];\n        int[] scores = new int[n];\n        Arrays.fill(primes, -1);\n        Arrays.fill(scores, 1);\n        \n        for (int i = 0; i < n; i++) {\n            primes[i] = getPrime(nums.get(i));\n        }\n        \n        int maxScore = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                int l = Math.max(i, primes[i] - 1);\n                int r = Math.min(j, primes[j] - 1);\n                int score = (r - l + 1) * scores[j];\n                if (score > maxScore) {\n                    maxScore = score;\n                }\n            }\n        }\n        \n        return (int) (maxScore % (1e9 + 7));\n    }\n    \n    private int getPrime(int num) {\n        int res = num;\n        for (int i = 2; i * i <= num; i++) {\n            if (num % i == 0) {\n                res = i;\n                break;\n            }\n        }\n        return res;\n    }\n}", "writer": "AI"}
{"code": "class Solution {    \n    public long findMaximumElegance(int[][] items, int k) {\n        int n = items.length;\n        int[][] dp = new int[n + 1][k + 1];\n        for (int i = 0; i <= n; i++) {\n            for (int j = 0; j <= k; j++) {\n                if (i == 0) {\n                    dp[i][j] = 0;\n                } else if (j == 0) {\n                    dp[i][j] = 0;\n                } else if (j == 1) {\n                    dp[i][j] = items[i - 1][0];\n                } else {\n                    dp[i][j] = Math.max(dp[i - 1][j], items[i - 1][0] + dp[i - 1][j - 1]);\n                }\n            }\n        }\n        return dp[n][k];\n    }\n}", "writer": "AI"}
{"code": "public class Solution{\n    public int maxSum(int[] nums){\n        int maxSum = Integer.MIN_VALUE;\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[i] % 10 == nums[j] % 10) {\n                    maxSum = Math.max(maxSum, nums[i] + nums[j]);\n                }\n            }\n        }\n        return maxSum == Integer.MIN_VALUE? -1 : maxSum; \n    }\n    \n}", "writer": "AI"}
{"code": "public class Solution {\n    public String finalString(String s) {\n        String result = \"\";\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            if (c == 'i') {\n                result = new StringBuilder(result).reverse().toString();\n            } else {\n                result += c;\n            }\n        }\n        return result;\n    }\n}", "writer": "AI"}
{"code": "class Solution {\n    public int minAbsoluteDifference(List<Integer> nums, int x) {\n        int n = nums.size();\n        int[] arr  = new int[n];\n        for(int i = 0; i < n; i++) {\n            arr[i] = nums.get(i);\n        }\n        Arrays.sort(arr);\n        int res = Integer.MAX_VALUE;\n        for(int i =  0; i < n; i++) {\n            int left = i + 1;\n            int right = n - 1;\n            while(left <= right) {\n                int mid = left + (right - left) / 2;\n                if(arr[mid] - arr[  i] >= x) {\n                    right = mid - 1;\n                } else {\n                    left = mid + 1;\n                }\n            }\n            if(left < n) {\n                res = Math.min(res, arr[left] - arr[i]);\n            }\n            left  = 0;\n            right = i - 1;\n            while(left <= right) {\n                int mid = left + (right - left) / 2;\n                if(arr[i] - arr[mid] >= x) {\n                    left = mid + 1;\n                 } else {\n                    right = mid - 1;\n                }\n            }\n            if(right >= 0) {\n                res = Math.min(res, arr[i] - arr[right]);\n            }\n        }\n        return res;\n    }\n} ", "writer": "AI"}
{"code": "class Solution {\n    public ListNode doubleIt(ListNode head) {\n    ListNode dummy = new ListNode(0);\n    dummy.next = head;\n    ListNode cur = dummy;\n    while (cur.next != null && cur.next.next != null) {\n        ListNode next = cur.next.next;\n        cur.next.next =  next.next;\n        next.next = cur.next;\n        cur.next = next;\n        cur = cur.next.next;\n    }\n    return dummy.next;\n    }\n}", "writer": "AI"}
{"code": "public class Solution {\n    public int maximumScore(List<Integer> nums, int k) {\n        \n        int n = nums.size();\n        int[] dp = new int[n];\n        int[] prime = new int[n];\n        int[] primeCount = new int[n];\n        int[] prefix = new int[n];\n        int[] suffix = new int[n];\n        \n        \n        for(int i = 0; i < n; i++){\n            dp[i] = nums.get(i);\n            prime[i] = getPrime(nums.get(i));\n            primeCount[i] = getPrimeCount(nums.get(i));\n            \n        }\n        \n        for(int i = 1; i < n; i++){\n            prefix[i] = prefix[i-1] + primeCount[i-1];\n        }\n        \n        for(int i = n-2; i >= 0; i--){\n            suffix[  i] = suffix[i+1] + primeCount[i+1];\n        }\n        \n        int[] dp2 = new int[n];\n        int[] dp3 = new int[n];\n        int[] dp4 = new int[n];\n        \n        for(int i = 0  ; i < n; i++){\n            dp2[i] = dp[i];\n            dp3[i] = dp[i];\n            dp4[i] = dp[i];\n        }\n        \n        for(int i = 0; i < k; i++){\n            int max  = -1;\n            int maxIndex = -1;\n            for(int j = 0; j < n; j++){\n                if(j == 0){\n                    dp2[j] = dp[j] * prime[j];\n                }else{\n                    dp2[j  ] = Math.max(dp2[j-1], dp[j] * prime[j]);\n                }\n                \n                if(j == n-1){\n                    dp3[j] = dp[j] * prime[j];\n                }else{\n                    dp3[j]  = Math.max(dp3[j+1], dp[j] * prime[j]);\n                }\n                \n                if(prefix[j] + suffix[j] - primeCount[j] > max){\n                    max = prefix[j] + suffix[j] - primeCount  [j];\n                    maxIndex = j;\n                }\n            }\n            \n            dp4[maxIndex] = 0;\n            \n            for(int j = 0; j < n; j++){\n                if(j == 0){\n                    dp4[j] = Math.max(dp4  [j], dp2[j]);\n                }else if(j == n-1){\n                    dp4[j] = Math.max(dp4[j], dp3[j]);\n                }else{\n                    dp4[j] = Math.max(dp4[j],  Math.max(dp2[j], dp3[j]));\n                }\n            }\n            \n            for(int j = 0; j < n; j++){\n                dp[j] = dp4[j];\n            }\n        }\n        \n        int sum = 0;\n        for(int i  = 0; i < n; i++){\n            sum = (sum + dp[i]) % 1000000007;\n        }\n        \n        return sum;\n    }\n    \n    public int getPrime(int num){\n        int count = 0;\n        for(  int i = 2; i <= num; i++){\n            if(num % i == 0){\n                count++;\n            }\n        }\n        return count;\n    }\n    \n    public int getPrimeCount(int num){\n        int count = 0;\n        for(  int i =  2; i <= num; i++){\n            if(num % i == 0){\n                count++;\n            }\n        }\n        return count - 1;\n    }\n}", "writer": "AI"}
{"code": "public class Solution {\n    public int findMaximumElegance(int[][] items, int k) {\n        int n = items.length;\n        int[][] dp = new int[n][k];\n        for(int i=0; i<n; i++) {\n            dp[i][0] = items[i][0];\n        }\n        for(int i=1; i  <n; i++) {\n            for(int j=1; j<k; j++) {\n                int max = Integer.MIN_VALUE;\n                for(int m=0; m<i; m++) {\n                    if(items[m][1] != items[i][ 1]) {\n                        max = Math.max(max, dp[m][j-1]);\n                    }\n                }\n                dp[i][j] = max + items[i][0];\n            }\n        }\n        int max = Integer.MIN_VALUE;\n        for(int i= 0; i<n; i++) {\n            max = Math.max(max, dp[i][k-1]);\n        }\n        return max;\n    }\n}", "writer": "AI"}
{"code": "public class Main {\n    public static void main(String[] args) {\n        int[] array = {1, 4, 2, 9, 5}; // Example input array\n        int largest = findLargestElement(array); // Finding the largest element\n        System.out.println(largest); // Output the largest element\n    }\n\n    // Method to find the largest element in the array\n    public static int findLargestElement(int[] arr) {\n        if (arr == null || arr.length == 0) {\n            throw new IllegalArgumentException(\"Array should not be empty\");\n        }\n        int max = arr[0]; // Assume the first element is the largest initially\n\n        // Traverse the array to find the largest element\n        for (int i = 1; i < arr.length; i++) {\n            if (arr[i] > max) {\n                max = arr[i]; // Update max if current element is greater\n            }\n        }\n        return max; // Return the largest element\n    }\n}\n", "writer": "AI"}
{"code": "public class ReverseWords {\n\n    public static String reverseWords(String s) {\n        // Split the input string on one or more spaces\n        String[] words = s.split(\"\\\\s+\");\n        // StringBuilder to hold the reversed words\n        StringBuilder reversed = new StringBuilder();\n        \n        // Iterate over the words array from the last element to the first\n        for (int i = words.length - 1; i >= 0; i--) {\n            reversed.append(words[i]); // Append the word to the StringBuilder\n            if (i > 0) {\n                reversed.append(\" \"); // Append a space if it's not the last word\n            }\n        }\n        return reversed.toString(); // Convert StringBuilder to String and return it\n    }\n\n    // Main method to test the reverseWords function\n    public static void main(String[] args) {\n        String input = \"Hello World!\";\n        String reversed = reverseWords(input);\n        System.out.println(reversed);  // Output: \"World! Hello\"\n    }\n}\n", "writer": "AI"}
{"code": "import java.util.Arrays;\n\npublic class PrimeChecker {\n    public static void main(String[] args) {\n        int number1 = 7;\n        int number2 = 12;\n\n        System.out.println(isPrime(number1)); // Output: true\n        System.out.println(isPrime(number2)); // Output: false\n    }\n\n    // Function to check if a number is prime using Sieve of Eratosthenes\n    public static boolean isPrime(int n) {\n        if (n <= 1) return false; // 0 and 1 are not prime numbers\n        boolean[] isPrime = new boolean[n + 1];\n        Arrays.fill(isPrime, true); // Assume all numbers are prime\n        isPrime[0] = isPrime[1] = false; // 0 and 1 are not prime numbers\n\n        for (int i = 2; i * i <= n; i++) {\n            if (isPrime[i]) {\n                for (int j = i * i; j <= n; j += i) {\n                    isPrime[j] = false; // Marking the multiples of i as non-prime\n                }\n            }\n        }\n\n        return isPrime[n]; // Return the primality of n\n    }\n}\n", "writer": "AI"}
{"code": "public class ReverseString {\n    public static void main(String[] args) {\n        String input = \"hello\";  // The original string\n        String reversed = \"\";   // This will store the reversed string\n\n        // Looping from the end of the string to the beginning\n        for (int i = input.length() - 1; i >= 0; i--) {\n            reversed += input.charAt(i);  // Adding each character to the reversed string\n        }\n\n        System.out.println(reversed);  // Output the reversed string\n    }\n}\n", "writer": "AI"}
{"code": "public class PalindromeChecker {\n\n    public static boolean isPalindrome(String s) {\n        s = s.toLowerCase().replaceAll(\"[^a-z0-9]\", \"\"); // Normalize: remove non-alphanumeric and convert to lower case\n        int left = 0; // Starting index\n        int right = s.length() - 1; // Ending index\n\n        while (left < right) { // Compare characters from each end\n            if (s.charAt(left) != s.charAt(right)) {\n                return false; // If characters do not match, it's not a palindrome\n            }\n            left++; // Move inward from the left side\n            right--; // Move inward from the right side\n        }\n\n        return true; // If no mismatches, it is a palindrome\n    }\n\n    public static void main(String[] args) {\n        System.out.println(isPalindrome(\"A man, a plan, a canal: Panama\")); // Output: true\n        System.out.println(isPalindrome(\"race a car\")); // Output: false\n    }\n}\n", "writer": "AI"}
{"code": "public class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        // HashMap to store the indices of the numbers\n        HashMap<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            // Check if the complement exists in the map\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                // If complement exists, return the pair of indices\n                return new int[] {map.get(complement), i};\n            }\n            // Store the index of the current number in the map\n            map.put(nums[i], i);\n        }\n        // Return an empty array if no solution is found\n        return new int[] {};\n    }\n}\n", "writer": "AI"}
