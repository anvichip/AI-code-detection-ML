{"code": "class Solution {\npublic:\n    int maxSum(std::vector<int>& nums) {\n        int maxSum = -1;\n        for (int i = 0; i < nums.size(); i++) {\n            for (int j = i + 1; j < nums.size(); j++) {\n                if (maxDigit(nums[i]) == maxDigit(nums[j])) {\n                    maxSum = std::max(maxSum, nums[i] + nums[j]);\n                }\n            }\n        }\n        return maxSum;\n    }\n\nprivate:\n    int maxDigit(int num) {\n        int maxDigit = 0;\n        while (num > 0) {\n            maxDigit = std::max(maxDigit, num % 10);\n            num /= 10;\n        }\n        return maxDigit;\n    }\n};", "writer": "AI"}
{"code": "class Solution {\n    public:\n        int maxSum(vector<int>& nums) {\n        int res = -1, max_num[10] = {};\n        for (auto num : nums) {\n            int max_d = 0;\n            for (int v = num; v; v /= 10)\n                max_d = max(max_d, v % 10);\n            if (max_num[max_d])\n                res = max(res, max_num[max_d] + num);\n            max_num[max_d] = max(max_num[max_d], num);\n        }\n        return res;\n    }\n};", "writer": "Human"}
{"code": "class Solution {\npublic:\n    std::string finalString(std::string s) {\n        std::string result = \"\";\n        for (char c : s) {\n            if (c == 'i') {\n                std::reverse(result.begin(), result.end());\n            } else {\n                result += c;\n            }\n        }\n        return result;\n    }\n};", "writer": "AI"}
{"code": "class Solution {\npublic:\n    string finalString(const string &s) {\n        string a, b;\n        for (char ch : s)\n            if (ch == 'i')\n                swap(a, b);\n            else\n                a += ch;\n        return string(rbegin(b), rend(b)) + a;\n    }\n};", "writer": "Human"}
{"code": "class Solution {\npublic:\n    int minAbsoluteDifference(std::vector<int>& nums, int x) {\n        int minDiff = INT_MAX;\n        for (int i = 0; i < nums.size(); i++) {\n            for (int j = i + x; j < nums.size(); j++) {\n                minDiff = std::min(minDiff, std::abs(nums[i] - nums[j]));\n            }\n        }\n        return minDiff;\n    }\n};", "writer": "AI"}
{"code": "class Solution {\npublic:\n    int minAbsoluteDifference(vector<int>& nums, int x) {\n        int ans = INT_MAX;\n        set<int> s;\n        for(int i = x; i < nums.size(); ++i){\n            s.insert(nums[i-x]);\n            auto it = s.upper_bound(nums[i]);\n            if(it != s.end()) ans = min(ans, abs(nums[i] - *it));\n            if(it != s.begin()) ans = min(ans, abs(nums[i] - *prev(it)));\n        }\n        return ans;\n    }\n};", "writer": "Human"}
{"code": "class Solution {\npublic:\n    ListNode* doubleIt(ListNode* head) {\n        ListNode* current = head;\n        int carry = 0;\n        while (current != nullptr) {\n            int sum = current->val * 2 + carry;\n            current->val = sum % 10;\n            carry = sum / 10;\n            if (current->next == nullptr && carry > 0) {\n                current->next = new ListNode(carry);\n                break;\n            }\n            current = current->next;\n        }\n        return head;\n    }\n};", "writer": "AI"}
{"code": "class Solution {\npublic:\n    ListNode* doubleIt(ListNode* head) {\n        if (head->val > 4)\n            head = new ListNode(0, head);\n        for(ListNode* node = head; node; node = node->next) {\n            node->val = (node->val * 2) % 10;\n            if (node->next && node->next->val > 4)\n                node->val++;\n        }\n        return head;\n    }\n};", "writer": "Human"}
{"code": "class Solution {\npublic:\n    int maximumScore(std::vector<int>& nums, int k) {\n        const int MOD = 1e9 + 7;\n        int n = nums.size();\n        std::vector<int> primeScore(n);\n        for (int i = 0; i < n; i++) {\n            primeScore[i] = getPrimeScore(nums[i]);\n        }\n        std::vector<std::vector<long long>> dp(n, std::vector<long long>(k + 1));\n        for (int i = 0; i < n; i++) {\n            dp[i][0] = nums[i];\n            for (int j = 1; j <= k; j++) {\n                for (int l = 0; l < i; l++) {\n                    if (primeScore[l] >= primeScore[i]) {\n                        dp[i][j] = std::max(dp[i][j], dp[l][j - 1] * nums[i] % MOD);\n                    }\n                }\n            }\n        }\n        long long maxScore = 0;\n        for (int i = 0; i < n; i++) {\n            maxScore = std::max(maxScore, dp[i][k]);\n        }\n        return maxScore % MOD;\n    }\n\nprivate:\n    int getPrimeScore(int num) {\n        int score = 0;\n        for (int i = 2; i <= std::sqrt(num); i++) {\n            if (num % i == 0) {\n                score++;\n                while (num % i == 0) {\n                    num /= i;\n                }\n            }\n        }\n        if (num > 1) {\n            score++;\n        }\n        return score;\n    }\n};", "writer": "AI"}
{"code": "class Solution {\npublic:\n    const int MOD = 1000000007;\n\n    int maximumScore(vector<int>& nums, int k) {\n        int n = nums.size();\n\n        int upper = *max_element(nums.begin(), nums.end()) + 1;\n\n        vector<bool> prime(upper, true);\n        prime[0] = prime[1] = false;\n        vector<int> primeScore(upper, 0);\n        for (int i = 2; i < upper; i++) {\n            if (prime[i]) {\n                for (int j = i; j < upper; j += i) {\n                    primeScore[j]++;\n                    prime[j] = false;\n                }\n            }\n        }\n\n        vector<int> nextGreaterElement(n, n);\n        stack<int> s;\n        for (int i = n - 1; i >= 0; i--) {\n            while (!s.empty() && primeScore[nums[i]] >= primeScore[nums[s.top()]]) {\n                s.pop();\n            }\n            nextGreaterElement[i] = s.empty() ? n : s.top();\n            s.push(i);\n        }\n\n        vector<int> prevGreaterOrEqualElement(n, -1);\n        s = stack<int>();\n        for (int i = 0; i < n; i++) {\n            while (!s.empty() && primeScore[nums[i]] > primeScore[nums[s.top()]]) {\n                s.pop();\n            }\n            prevGreaterOrEqualElement[i] = s.empty() ? -1 : s.top();\n            s.push(i);\n        }\n\n        int res = 1;\n        vector<pair<int, int>> tuples(n);\n        for (int i = 0; i < n; i++) {\n            tuples[i].first = nums[i];\n            tuples[i].second = i;\n        }\n        sort(tuples.rbegin(), tuples.rend());\n        for (const auto& [num, i] : tuples) {\n            int operations = min((i - prevGreaterOrEqualElement[i]) * (nextGreaterElement[i] - i), k);\n            res = (int)((1L * res * pow(num, operations)) % MOD);\n            k -= operations;\n            if (k == 0) {\n                return res;\n            }\n        }\n\n        return res;\n    }\n\n    int pow(int x, int n) {\n        int res = 1;\n        while (n > 0) {\n            if (n % 2 == 1) {\n                res = (int)((1L * res * x) % MOD);\n            }\n            x = (int)((1L * x * x) % MOD);\n            n /= 2;\n        }\n        return res;\n    }\n};", "writer": "Human"}
{"code": "class Solution {\npublic:\n    long long findMaximumElegance(std::vector<std::vector<int>>& items, int k) {\n        const int MOD = 1e9 + 7;\n        int n = items.size();\n        std::vector<std::unordered_map<int, long long>> dp(n);\n        for (int i = 0; i < n; i++) {\n            dp[i][1 << items[i][1]] = items[i][0];\n            for (int j = 0; j < i; j++) {\n                for (auto& [mask, val] : dp[j]) {\n                    int newMask = mask | (1 << items[i][1]);\n                    dp[i][newMask] = std::max(dp[i][newMask], val + items[i][0]);\n                }\n            }\n        }\n        long long maxElegance = 0;\n        for (int i = 0; i < n; i++) {\n            for (auto& [mask, val] : dp[i]) {\n                int cnt = __builtin_popcount(mask);\n                if (cnt >= k) {\n                    maxElegance = std::max(maxElegance, val + cnt * cnt);\n                }\n            }\n        }\n        return maxElegance % MOD;\n    }\n};", "writer": "AI"}
{"code": "class Solution {\npublic:\n    long long findMaximumElegance(vector<vector<int>>& A, int k) {\n        sort(A.begin(), A.end(), [](const vector<int>& a, const vector<int>& b) {\n            return a[0] > b[0];\n        });\n        long long res = 0, cur = 0;\n        vector<int> dup;\n        unordered_set<int> seen;\n        for (int i = 0; i < A.size(); ++i) {\n            if (i < k) {\n                if (seen.count(A[i][1])) {\n                    dup.push_back(A[i][0]);\n                }\n                cur += A[i][0];\n            } else if (seen.find(A[i][1]) == seen.end()) {\n                if (dup.empty()) break;\n                cur += A[i][0] - dup.back();\n                dup.pop_back();\n            }\n            seen.insert(A[i][1]);\n            res = fmax(res, cur + 1L * seen.size() * seen.size());\n        }\n        return res;\n    }\n};", "writer": "Human"}
{"code": "class Solution {\npublic:\n    int maxSum(std::vector<int>& nums) {\n        std::vector<int> maxDigit(10, -1); // To store the maximum number for each digit (0-9)\n        int maxSum = -1; // Initialize maxSum to -1 as the minimum possible answer\n        \n        for (int num : nums) {\n            int maxDig = 0; // To store the maximum digit in the current number\n            int temp = num; // Temporary variable to avoid modifying num\n            \n            while (temp > 0) {\n                int digit = temp % 10;\n                maxDig = std::max(maxDig, digit); // Update maxDig if a larger digit is found\n                temp /= 10;\n            }\n            \n            if (maxDigit[maxDig] != -1) {\n                // If we have seen a number with the same maximum digit before, update maxSum\n                maxSum = std::max(maxSum, maxDigit[maxDig] + num);\n            }\n            \n            // Update maxDigit[maxDig] with the maximum of the current number and the previous maximum\n            maxDigit[maxDig] = std::max(maxDigit[maxDig], num);\n        }\n        \n        return maxSum;\n    }\n};", "writer": "AI"}
{"code": "class Solution {\n    public:\n        int maxSum(vector<int>& nums) {\n        int res = -1, max_num[10] = {};\n        for (auto num : nums) {\n            int max_d = 0;\n            for (int v = num; v; v /= 10)\n                max_d = max(max_d, v % 10);\n            if (max_num[max_d])\n                res = max(res, max_num[max_d] + num);\n            max_num[max_d] = max(max_num[max_d], num);\n        }\n        return res;\n    }\n};", "writer": "Human"}
{"code": "class Solution {\npublic:\n    std::string finalString(std::string s) {\n        std::string result = \"\"; // Initialize the result string\n        \n        for (char c : s) {\n            if (c == 'i') {\n                // If the character is 'i', reverse the result string\n                std::reverse(result.begin(), result.end());\n            } else {\n                // Otherwise, append the character to the result string\n                result += c;\n            }\n        }\n        \n        return result;\n    }\n};", "writer": "AI"}
{"code": "class Solution {\npublic:\n    string finalString(const string &s) {\n        string a, b;\n        for (char ch : s)\n            if (ch == 'i')\n                swap(a, b);\n            else\n                a += ch;\n        return string(rbegin(b), rend(b)) + a;\n    }\n};", "writer": "Human"}
{"code": "class Solution {\npublic:\n    int minAbsoluteDifference(std::vector<int>& nums, int x) {\n        int n = nums.size();\n        std::vector<std::pair<int, int>> indexedNums; // Store the numbers along with their indices\n        \n        // Create a vector of pairs (number, index)\n        for (int i = 0; i < n; ++i) {\n            indexedNums.push_back({nums[i], i});\n        }\n        \n        // Sort the vector based on numbers\n        std::sort(indexedNums.begin(), indexedNums.end());\n        \n        int minDiff = INT_MAX; // Initialize the minimum difference to a large value\n        \n        // Traverse the sorted vector and find the minimum absolute difference\n        for (int i = 0; i < n; ++i) {\n            // Find the index of the element that is at least x indices apart\n            int j = i + x;\n            if (j < n) {\n                int diff = abs(indexedNums[i].first - indexedNums[j].first);\n                minDiff = std::min(minDiff, diff);\n            }\n        }\n        \n        return minDiff;\n    }\n};", "writer": "AI"}
{"code": "class Solution {\npublic:\n    int minAbsoluteDifference(vector<int>& nums, int x) {\n        int ans = INT_MAX;\n        set<int> s;\n        for(int i = x; i < nums.size(); ++i){\n            s.insert(nums[i-x]);\n            auto it = s.upper_bound(nums[i]);\n            if(it != s.end()) ans = min(ans, abs(nums[i] - *it));\n            if(it != s.begin()) ans = min(ans, abs(nums[i] - *prev(it)));\n        }\n        return ans;\n    }\n};", "writer": "Human"}
{"code": "class Solution {\npublic:\n    ListNode* doubleIt(ListNode* head) {\n        if (!head) {\n            return nullptr;\n        }\n\n        int carry = 0;\n        ListNode* current = head;\n        ListNode* prev = nullptr;\n\n        // Traverse the list in reverse order and double the values\n        while (current) {\n            int newVal = current->val * 2 + carry;\n            carry = newVal / 10;\n            current->val = newVal % 10;\n\n            prev = current;\n            current = current->next;\n        }\n\n        // If there's a remaining carry, add a new node for it\n        if (carry > 0) {\n            ListNode* newNode = new ListNode(carry);\n            prev->next = newNode;\n        }\n\n        return reverseList(head);\n    }\n\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* current = head;\n\n        while (current) {\n            ListNode* nextNode = current->next;\n            current->next = prev;\n            prev = current;\n            current = nextNode;\n        }\n\n        return prev;\n    }\n};", "writer": "AI"}
{"code": "class Solution {\npublic:\n    ListNode* doubleIt(ListNode* head) {\n        if (head->val > 4)\n            head = new ListNode(0, head);\n        for(ListNode* node = head; node; node = node->next) {\n            node->val = (node->val * 2) % 10;\n            if (node->next && node->next->val > 4)\n                node->val++;\n        }\n        return head;\n    }\n};", "writer": "Human"}
{"code": "class Solution {\npublic:\n    const int MOD = 1e9 + 7;\n\n    int maximumScore(std::vector<int>& nums, int k) {\n        int n = nums.size();\n        std::unordered_map<int, int> primeScore; // Map to store prime scores of elements\n        int left = 0; // Left pointer of the sliding window\n        long long score = 1; // Initial score\n        int maxScore = 1; // Maximum score\n\n        for (int right = 0; right < n; ++right) {\n            // Calculate prime score for the new element\n            int curScore = calculatePrimeScore(nums[right]);\n\n            // Update prime score map\n            primeScore[nums[right]]++;\n\n            // Increment the score by multiplying it with the prime score\n            score = (score * curScore) % MOD;\n\n            // Check if the window size exceeds k, then we need to shrink the window\n            while (right - left + 1 > k) {\n                int leftElem = nums[left];\n                primeScore[leftElem]--;\n\n                // If the left element has no more occurrences in the window, remove it from the map\n                if (primeScore[leftElem] == 0) {\n                    primeScore.erase(leftElem);\n                }\n\n                // Move the left pointer to the right\n                left++;\n            }\n\n            // Update the maximum score\n            maxScore = std::max(maxScore, static_cast<int>(score));\n        }\n\n        return maxScore;\n    }\n\n    // Helper function to calculate the prime score of an integer\n    int calculatePrimeScore(int x) {\n        int score = 0;\n        for (int i = 2; i * i <= x; ++i) {\n            while (x % i == 0) {\n                x /= i;\n                score++;\n            }\n        }\n        if (x > 1) {\n            score++;\n        }\n        return score;\n    }\n};", "writer": "AI"}
{"code": "class Solution {\npublic:\n    const int MOD = 1000000007;\n\n    int maximumScore(vector<int>& nums, int k) {\n        int n = nums.size();\n\n        int upper = *max_element(nums.begin(), nums.end()) + 1;\n\n        vector<bool> prime(upper, true);\n        prime[0] = prime[1] = false;\n        vector<int> primeScore(upper, 0);\n        for (int i = 2; i < upper; i++) {\n            if (prime[i]) {\n                for (int j = i; j < upper; j += i) {\n                    primeScore[j]++;\n                    prime[j] = false;\n                }\n            }\n        }\n\n        vector<int> nextGreaterElement(n, n);\n        stack<int> s;\n        for (int i = n - 1; i >= 0; i--) {\n            while (!s.empty() && primeScore[nums[i]] >= primeScore[nums[s.top()]]) {\n                s.pop();\n            }\n            nextGreaterElement[i] = s.empty() ? n : s.top();\n            s.push(i);\n        }\n\n        vector<int> prevGreaterOrEqualElement(n, -1);\n        s = stack<int>();\n        for (int i = 0; i < n; i++) {\n            while (!s.empty() && primeScore[nums[i]] > primeScore[nums[s.top()]]) {\n                s.pop();\n            }\n            prevGreaterOrEqualElement[i] = s.empty() ? -1 : s.top();\n            s.push(i);\n        }\n\n        int res = 1;\n        vector<pair<int, int>> tuples(n);\n        for (int i = 0; i < n; i++) {\n            tuples[i].first = nums[i];\n            tuples[i].second = i;\n        }\n        sort(tuples.rbegin(), tuples.rend());\n        for (const auto& [num, i] : tuples) {\n            int operations = min((i - prevGreaterOrEqualElement[i]) * (nextGreaterElement[i] - i), k);\n            res = (int)((1L * res * pow(num, operations)) % MOD);\n            k -= operations;\n            if (k == 0) {\n                return res;\n            }\n        }\n\n        return res;\n    }\n\n    int pow(int x, int n) {\n        int res = 1;\n        while (n > 0) {\n            if (n % 2 == 1) {\n                res = (int)((1L * res * x) % MOD);\n            }\n            x = (int)((1L * x * x) % MOD);\n            n /= 2;\n        }\n        return res;\n    }\n};", "writer": "Human"}
{"code": "class Solution {\npublic:\n    long long findMaximumElegance(std::vector<std::vector<int>>& items, int k) {\n        std::unordered_map<int, std::vector<int>> categoryToProfits;\n        std::unordered_map<int, long long> categoryToTotalProfit;\n\n        for (auto& item : items) {\n            int profit = item[0];\n            int category = item[1];\n            categoryToProfits[category].push_back(profit);\n            categoryToTotalProfit[category] += profit;\n        }\n\n        std::vector<long long> maxProfits;\n        long long totalElegance = 0;\n\n        for (auto& pair : categoryToProfits) {\n            int category = pair.first;\n            std::vector<int>& profits = pair.second;\n\n            std::sort(profits.rbegin(), profits.rend());\n\n            long long categoryTotalProfit = categoryToTotalProfit[category];\n            int categoryDistinctCount = profits.size();\n\n            for (int i = 0; i < k && i < categoryDistinctCount; ++i) {\n                totalElegance += profits[i] + static_cast<long long>(categoryDistinctCount) * categoryDistinctCount;\n                maxProfits.push_back(profits[i]);\n            }\n        }\n\n        std::sort(maxProfits.rbegin(), maxProfits.rend());\n\n        for (int i = k; i < maxProfits.size(); ++i) {\n            totalElegance -= maxProfits[i];\n        }\n\n        return totalElegance;\n    }\n};", "writer": "AI"}
{"code": "class Solution {\npublic:\n    long long findMaximumElegance(vector<vector<int>>& A, int k) {\n        sort(A.begin(), A.end(), [](const vector<int>& a, const vector<int>& b) {\n            return a[0] > b[0];\n        });\n        long long res = 0, cur = 0;\n        vector<int> dup;\n        unordered_set<int> seen;\n        for (int i = 0; i < A.size(); ++i) {\n            if (i < k) {\n                if (seen.count(A[i][1])) {\n                    dup.push_back(A[i][0]);\n                }\n                cur += A[i][0];\n            } else if (seen.find(A[i][1]) == seen.end()) {\n                if (dup.empty()) break;\n                cur += A[i][0] - dup.back();\n                dup.pop_back();\n            }\n            seen.insert(A[i][1]);\n            res = fmax(res, cur + 1L * seen.size() * seen.size());\n        }\n        return res;\n    }\n};", "writer": "Human"}
{"code": "class Solution {\npublic:\n    int maxSum(vector<int>& nums) {\n       int n = nums.size();\n        int max_digit = 0;\n        for(int i = 0; i < n; i++){\n            int digit = 0;\n            int num = nums[i];\n            while(num){\n                digit = max(digit, num % 10);\n                num /= 10;\n            }\n            max_digit = max(max_digit, digit);\n        }\n        \n        int max_sum = -1;\n        for(int i = 0; i < n; i++){\n            for(int j = i + 1; j < n; j++){\n                int digit = 0;\n                int num = nums[i] + nums[j];\n                while(num){\n                    digit = max(digit, num % 10);\n                    num /= 10;\n                }\n                if(digit == max_digit){\n                    max_sum = max(max_sum, nums[i] + nums[j]);\n                }\n            }\n        }\n        \n        return max_sum;\n    }\n};", "writer": "AI"}
{"code": "class Solution {\n    public:\n        int maxSum(vector<int>& nums) {\n        int res = -1, max_num[10] = {};\n        for (auto num : nums) {\n            int max_d = 0;\n            for (int v = num; v; v /= 10)\n                max_d = max(max_d, v % 10);\n            if (max_num[max_d])\n                res = max(res, max_num[max_d] + num);\n            max_num[max_d] = max(max_num[max_d], num);\n        }\n        return res;\n    }\n};", "writer": "Human"}
{"code": "class Solution {\npublic:\n    string finalString(string s) {\n        string ans;\n        for(int i = 0; i < s.length(); i++){\n            if(s[i] == 'i'){\n                reverse(ans.begin(), ans.end());\n            }\n            else{\n                ans.push_back(s[i]);\n            }\n        }\n        return ans;\n    }\n};", "writer": "AI"}
{"code": "class Solution {\npublic:\n    string finalString(const string &s) {\n        string a, b;\n        for (char ch : s)\n            if (ch == 'i')\n                swap(a, b);\n            else\n                a += ch;\n        return string(rbegin(b), rend(b)) + a;\n    }\n};", "writer": "Human"}
{"code": "class Solution {\npublic:\n    int minAbsoluteDifference(vector<int>& nums, int x) {\n        int n=nums.size();\n        int min=INT_MAX;\n        int i=0;\n        int j=0;\n        for(i=0;i<n;i++){\n            for(j=i+1;j<n;j++){\n                if(abs(nums[i]-nums[j])<min && abs(i-j)>=x){\n                    min=abs(nums[i]-nums[j]);\n                }\n            }\n        }\n        return min;\n    }\n};", "writer": "AI"}
{"code": "class Solution {\npublic:\n    int minAbsoluteDifference(vector<int>& nums, int x) {\n        int ans = INT_MAX;\n        set<int> s;\n        for(int i = x; i < nums.size(); ++i){\n            s.insert(nums[i-x]);\n            auto it = s.upper_bound(nums[i]);\n            if(it != s.end()) ans = min(ans, abs(nums[i] - *it));\n            if(it != s.begin()) ans = min(ans, abs(nums[i] - *prev(it)));\n        }\n        return ans;\n    }\n};", "writer": "Human"}
{"code": "class Solution {\npublic:\n    ListNode* doubleIt(ListNode* head) {\n        ListNode* temp = head;\n         ListNode* temp2 = head;\n         while(temp->next!=NULL){\n             temp2 = temp2->next;\n             temp = temp->next;\n         }\n         temp2->next = head;\n         temp = temp2;\n         while(temp->next!=NULL){\n             temp->val = temp->val*2;\n             if(temp->val>9){\n                 temp->val = temp->val%10;\n                 temp->next->val = temp->next->val+1;\n             }\n             temp = temp->next;\n         }\n         if(temp->val>9){\n             temp->val = temp->val%10;\n             temp->next = new ListNode(1);\n         }\n         return head;\n    }\n};", "writer": "AI"}
{"code": "class Solution {\npublic:\n    ListNode* doubleIt(ListNode* head) {\n        if (head->val > 4)\n            head = new ListNode(0, head);\n        for(ListNode* node = head; node; node = node->next) {\n            node->val = (node->val * 2) % 10;\n            if (node->next && node->next->val > 4)\n                node->val++;\n        }\n        return head;\n    }\n};", "writer": "Human"}
{"code": "class Solution {\npublic:\n    int maximumScore(vector<int>& nums, int k) { \n       int n = nums.size();\n        vector<int> primes;\n        for(int i = 2; i <= n; i++){\n            bool isPrime = true;\n            for(int j = 2; j <= sqrt(i); j++){\n                if(i % j == 0){\n                    isPrime = false;\n                    break;\n                }\n            }\n            if(isPrime){\n                primes.push_back(i);\n            }\n        }\n        vector<int> dp(n + 1, 0);\n        dp[0] = 1;\n        for(int i = 1; i <= n; i++){\n            for(int j = 0; j < primes.size(); j++){\n                if(primes[j] <= nums[i - 1]){\n                    dp[i] = (dp[i] + dp[i - 1]) % MOD;\n                }\n            }\n        }\n        int ans = 0;\n        for(int i = 0; i <= n; i++){\n            for(int j = 0; j <= n; j++){\n                if(i + j <= n){\n                    ans = (ans + dp[i] * dp[n - i - j] % MOD) % MOD;\n                }\n            }\n        }\n        return ans;\n    }\n    \n    int MOD = 1e9 + 7;\n};", "writer": "AI"}
{"code": "class Solution {\npublic:\n    const int MOD = 1000000007;\n\n    int maximumScore(vector<int>& nums, int k) {\n        int n = nums.size();\n\n        int upper = *max_element(nums.begin(), nums.end()) + 1;\n\n        vector<bool> prime(upper, true);\n        prime[0] = prime[1] = false;\n        vector<int> primeScore(upper, 0);\n        for (int i = 2; i < upper; i++) {\n            if (prime[i]) {\n                for (int j = i; j < upper; j += i) {\n                    primeScore[j]++;\n                    prime[j] = false;\n                }\n            }\n        }\n\n        vector<int> nextGreaterElement(n, n);\n        stack<int> s;\n        for (int i = n - 1; i >= 0; i--) {\n            while (!s.empty() && primeScore[nums[i]] >= primeScore[nums[s.top()]]) {\n                s.pop();\n            }\n            nextGreaterElement[i] = s.empty() ? n : s.top();\n            s.push(i);\n        }\n\n        vector<int> prevGreaterOrEqualElement(n, -1);\n        s = stack<int>();\n        for (int i = 0; i < n; i++) {\n            while (!s.empty() && primeScore[nums[i]] > primeScore[nums[s.top()]]) {\n                s.pop();\n            }\n            prevGreaterOrEqualElement[i] = s.empty() ? -1 : s.top();\n            s.push(i);\n        }\n\n        int res = 1;\n        vector<pair<int, int>> tuples(n);\n        for (int i = 0; i < n; i++) {\n            tuples[i].first = nums[i];\n            tuples[i].second = i;\n        }\n        sort(tuples.rbegin(), tuples.rend());\n        for (const auto& [num, i] : tuples) {\n            int operations = min((i - prevGreaterOrEqualElement[i]) * (nextGreaterElement[i] - i), k);\n            res = (int)((1L * res * pow(num, operations)) % MOD);\n            k -= operations;\n            if (k == 0) {\n                return res;\n            }\n        }\n\n        return res;\n    }\n\n    int pow(int x, int n) {\n        int res = 1;\n        while (n > 0) {\n            if (n % 2 == 1) {\n                res = (int)((1L * res * x) % MOD);\n            }\n            x = (int)((1L * x * x) % MOD);\n            n /= 2;\n        }\n        return res;\n    }\n};", "writer": "Human"}
{"code": "class Solution {\npublic:\n    long long findMaximumElegance(vector<vector<int>>& items, int k) {\n        int n = items.size();\n        vector<int> profit(n);\n        vector<int> category(n);\n        \n        for(int i = 0; i < n; i++){\n            profit[i] = items[i][0];\n            category[i] = items[i][1];\n        }\n        \n        sort(profit.begin(), profit.end());\n        sort(category.begin(), category.end());\n        \n        int max_elegance = 0;\n        \n        for(int i = 0; i < n; i++){\n            int j = i + k - 1;\n            if(j >= n) break;\n            \n            int total_profit = profit[j] - profit[i];\n            int distinct_categories = upper_bound(category.begin(), category.end(), category[j]) - upper_bound(category.begin(), category.end(), category[i]);\n            \n            max_elegance = max(max_elegance, total_profit + distinct_categories * distinct_categories);\n        }\n        \n        return max_elegance;\n    }\n};", "writer": "AI"}
{"code": "class Solution {\npublic:\n    long long findMaximumElegance(vector<vector<int>>& A, int k) {\n        sort(A.begin(), A.end(), [](const vector<int>& a, const vector<int>& b) {\n            return a[0] > b[0];\n        });\n        long long res = 0, cur = 0;\n        vector<int> dup;\n        unordered_set<int> seen;\n        for (int i = 0; i < A.size(); ++i) {\n            if (i < k) {\n                if (seen.count(A[i][1])) {\n                    dup.push_back(A[i][0]);\n                }\n                cur += A[i][0];\n            } else if (seen.find(A[i][1]) == seen.end()) {\n                if (dup.empty()) break;\n                cur += A[i][0] - dup.back();\n                dup.pop_back();\n            }\n            seen.insert(A[i][1]);\n            res = fmax(res, cur + 1L * seen.size() * seen.size());\n        }\n        return res;\n    }\n};", "writer": "Human"}
{"code": "class Solution {\npublic:\n    int maxSum(vector<int>& nums) {\n        int ans = -1;\n        int n = nums.size();\n        for(int i = 0; i < n; i++){\n            for(int j = i + 1; j < n; j++){\n                if(nums[i] % 10 == nums[j] % 10){\n                    ans = max(ans, nums[i] + nums[j]);\n                    break;\n                }\n            }\n        }\n        return ans;\n    }\n};", "writer": "AI"}
{"code": "class Solution {\n    public:\n        int maxSum(vector<int>& nums) {\n        int res = -1, max_num[10] = {};\n        for (auto num : nums) {\n            int max_d = 0;\n            for (int v = num; v; v /= 10)\n                max_d = max(max_d, v % 10);\n            if (max_num[max_d])\n                res = max(res, max_num[max_d] + num);\n            max_num[max_d] = max(max_num[max_d], num);\n        }\n        return res;\n    }\n};", "writer": "Human"}
{"code": "class Solution {\npublic:\n    string finalString(string s) {\n        string ans=\"\";\n        for(int i=0;i<s.length();i++){\n            if(s[i]=='i'){\n                reverse(ans.begin(),ans.end());\n                ans=\"\";\n                continue;\n            }\n            ans+=s[i];\n        }\n        return ans;\n    }\n};", "writer": "AI"}
{"code": "class Solution {\npublic:\n    string finalString(const string &s) {\n        string a, b;\n        for (char ch : s)\n            if (ch == 'i')\n                swap(a, b);\n            else\n                a += ch;\n        return string(rbegin(b), rend(b)) + a;\n    }\n};", "writer": "Human"}
{"code": "class Solution {\npublic:\n    int minAbsoluteDifference(vector<int>& nums, int x) {\n        int n = nums.size();\n        int ans = INT_MAX;\n        for(int i = 0; i < n; i++){\n            for(int j = i + 1; j < n; j++){\n                if(abs(nums[i] - nums[j]) >= x){\n                    ans = min(ans, abs(nums[i] - nums[j]));\n                    break;\n                }\n            }\n        }\n        return ans;\n    }\n};", "writer": "AI"}
{"code": "class Solution {\npublic:\n    int minAbsoluteDifference(vector<int>& nums, int x) {\n        int ans = INT_MAX;\n        set<int> s;\n        for(int i = x; i < nums.size(); ++i){\n            s.insert(nums[i-x]);\n            auto it = s.upper_bound(nums[i]);\n            if(it != s.end()) ans = min(ans, abs(nums[i] - *it));\n            if(it != s.begin()) ans = min(ans, abs(nums[i] - *prev(it)));\n        }\n        return ans;\n    }\n};", "writer": "Human"}
{"code": "class Solution {\npublic:\n    ListNode* doubleIt(ListNode* head) {\n        if(head == NULL)\n            return NULL;\n        ListNode* temp = head;\n        while(temp->next != NULL){\n            temp->val *= 2;\n            temp = temp->next;\n            if(temp->next != NULL) {\n                temp->val *= 2;\n                temp = temp->next;\n                continue;\n            }\n            else {\n                break;\n            }\n        }\n        return head;\n    }\n};", "writer": "AI"}
{"code": "class Solution {\npublic:\n    ListNode* doubleIt(ListNode* head) {\n        if (head->val > 4)\n            head = new ListNode(0, head);\n        for(ListNode* node = head; node; node = node->next) {\n            node->val = (node->val * 2) % 10;\n            if (node->next && node->next->val > 4)\n                node->val++;\n        }\n        return head;\n    }\n};", "writer": "Human"}
{"code": "class Solution {\npublic:\n    int maximumScore(vector<int>& nums, int k) {\n        int n = nums.size();\n        int l = k, r = k;\n        int score = 1;\n        int ans = 0;\n        while(l >= 0 || r < n){\n            if(l < 0){\n                score *= nums[r++];\n                ans = max(ans, score);\n                continue;\n            }\n            if(r == n){\n                score *= nums[l--];\n                ans = max(ans, score);\n                continue;\n            }\n            if(nums[l] < nums[r]){\n                score *= nums[l--];\n                ans = max(ans, score);\n            }\n            else{\n                score *= nums[r++];\n                ans = max(ans, score);\n            }\n        }\n        return ans;\n    }\n};", "writer": "AI"}
{"code": "class Solution {\npublic:\n    const int MOD = 1000000007;\n\n    int maximumScore(vector<int>& nums, int k) {\n        int n = nums.size();\n\n        int upper = *max_element(nums.begin(), nums.end()) + 1;\n\n        vector<bool> prime(upper, true);\n        prime[0] = prime[1] = false;\n        vector<int> primeScore(upper, 0);\n        for (int i = 2; i < upper; i++) {\n            if (prime[i]) {\n                for (int j = i; j < upper; j += i) {\n                    primeScore[j]++;\n                    prime[j] = false;\n                }\n            }\n        }\n\n        vector<int> nextGreaterElement(n, n);\n        stack<int> s;\n        for (int i = n - 1; i >= 0; i--) {\n            while (!s.empty() && primeScore[nums[i]] >= primeScore[nums[s.top()]]) {\n                s.pop();\n            }\n            nextGreaterElement[i] = s.empty() ? n : s.top();\n            s.push(i);\n        }\n\n        vector<int> prevGreaterOrEqualElement(n, -1);\n        s = stack<int>();\n        for (int i = 0; i < n; i++) {\n            while (!s.empty() && primeScore[nums[i]] > primeScore[nums[s.top()]]) {\n                s.pop();\n            }\n            prevGreaterOrEqualElement[i] = s.empty() ? -1 : s.top();\n            s.push(i);\n        }\n\n        int res = 1;\n        vector<pair<int, int>> tuples(n);\n        for (int i = 0; i < n; i++) {\n            tuples[i].first = nums[i];\n            tuples[i].second = i;\n        }\n        sort(tuples.rbegin(), tuples.rend());\n        for (const auto& [num, i] : tuples) {\n            int operations = min((i - prevGreaterOrEqualElement[i]) * (nextGreaterElement[i] - i), k);\n            res = (int)((1L * res * pow(num, operations)) % MOD);\n            k -= operations;\n            if (k == 0) {\n                return res;\n            }\n        }\n\n        return res;\n    }\n\n    int pow(int x, int n) {\n        int res = 1;\n        while (n > 0) {\n            if (n % 2 == 1) {\n                res = (int)((1L * res * x) % MOD);\n            }\n            x = (int)((1L * x * x) % MOD);\n            n /= 2;\n        }\n        return res;\n    }\n};", "writer": "Human"}
{"code": "class Solution {\npublic:\n    long long findMaximumElegance(vector<vector<int>>& items, int k) {\n        int n=items.size();\n        vector<long long>profit(n);\n        vector<long long>category(n);\n        for(int i=0;i<n;i++){\n            profit[i]=items[i][0];\n            category[i]=items[i][1];\n        }\n        sort(profit.begin(),profit.end());\n        sort(category.begin(),category.end());\n        long long ans=0;\n        long long max_profit=0;\n        long long max_category=0;\n        for(int i=0;i<n;i++){\n            if(i<k){\n                max_profit+=profit[i];\n                max_category+=category[i];\n                ans=max(ans,max_profit+max_category*max_category);\n                continue;\n            }\n            max_profit-=profit[i-k];\n            max_profit+=profit[i];\n            max_category-=category[i-k];\n            max_category+=category[i];\n            ans=max(ans,max_profit+max_category*max_category);\n        }\n        return ans;\n    }\n};", "writer": "AI"}
{"code": "class Solution {\npublic:\n    long long findMaximumElegance(vector<vector<int>>& A, int k) {\n        sort(A.begin(), A.end(), [](const vector<int>& a, const vector<int>& b) {\n            return a[0] > b[0];\n        });\n        long long res = 0, cur = 0;\n        vector<int> dup;\n        unordered_set<int> seen;\n        for (int i = 0; i < A.size(); ++i) {\n            if (i < k) {\n                if (seen.count(A[i][1])) {\n                    dup.push_back(A[i][0]);\n                }\n                cur += A[i][0];\n            } else if (seen.find(A[i][1]) == seen.end()) {\n                if (dup.empty()) break;\n                cur += A[i][0] - dup.back();\n                dup.pop_back();\n            }\n            seen.insert(A[i][1]);\n            res = fmax(res, cur + 1L * seen.size() * seen.size());\n        }\n        return res;\n    }\n};", "writer": "Human"}
{"code": "class Solution {\npublic:\n    int maxSum(vector<int>& nums) {\n        int n = nums.size();\n        int maxSum = -1;\n        unordered_map<int, int> mp;\n        for(int i = 0; i < n; i++) {\n            int maxDigit = 0;\n            int temp = nums[i];\n            while(temp) {\n                maxDigit = max(maxDigit, temp % 10);\n                temp /= 10;\n            }\n            if(mp.find(maxDigit) != mp.end()) {\n                maxSum = max(maxSum, mp[maxDigit] + nums[i]);\n                mp[maxDigit] = max(mp[maxDigit], nums[i]);\n            } else {\n                mp[maxDigit] = nums[i];\n            }\n        }\n        return maxSum;\n    }\n};", "writer": "AI"}
{"code": "class Solution {\n    public:\n        int maxSum(vector<int>& nums) {\n        int res = -1, max_num[10] = {};\n        for (auto num : nums) {\n            int max_d = 0;\n            for (int v = num; v; v /= 10)\n                max_d = max(max_d, v % 10);\n            if (max_num[max_d])\n                res = max(res, max_num[max_d] + num);\n            max_num[max_d] = max(max_num[max_d], num);\n        }\n        return res;\n    }\n};", "writer": "Human"}
{"code": "class Solution {\npublic:\n    string finalString(string s) {\n        string ans = \"\";\n        int n = s.length();\n        int i = 0;\n        while(i < n) {\n            if(s[i] == 'i') {\n                reverse(ans.begin(), ans.end());\n            } else {\n                ans += s[i];\n            }\n            i++;\n        }\n        return ans;\n    }\n};", "writer": "AI"}
{"code": "class Solution {\npublic:\n    string finalString(const string &s) {\n        string a, b;\n        for (char ch : s)\n            if (ch == 'i')\n                swap(a, b);\n            else\n                a += ch;\n        return string(rbegin(b), rend(b)) + a;\n    }\n};", "writer": "Human"}
{"code": "class Solution {\npublic:\n    int minAbsoluteDifference(vector<int>& nums, int x) {\n        int n = nums.size();\n        int ans = INT_MAX;\n        for(int i = 0; i < n; i++){\n            for(int j = i + x; j < n; j++){\n                ans = min(ans, abs(nums[i] - nums[j]));\n            }\n        }\n        return ans;\n    }\n};", "writer": "AI"}
{"code": "class Solution {\npublic:\n    int minAbsoluteDifference(vector<int>& nums, int x) {\n        int ans = INT_MAX;\n        set<int> s;\n        for(int i = x; i < nums.size(); ++i){\n            s.insert(nums[i-x]);\n            auto it = s.upper_bound(nums[i]);\n            if(it != s.end()) ans = min(ans, abs(nums[i] - *it));\n            if(it != s.begin()) ans = min(ans, abs(nums[i] - *prev(it)));\n        }\n        return ans;\n    }\n};", "writer": "Human"}
{"code": "class Solution {\npublic:\n    ListNode* doubleIt(ListNode* head) {\n        ListNode* temp = head;\n        ListNode* prev = NULL;\n        while(temp != NULL) {\n            temp->val *= 2;\n            if(temp->val > 9) {\n                if(prev == NULL) {\n                    ListNode* newHead = new ListNode(1);\n                    newHead->next = head;\n                    head = newHead;\n                    temp->val -= 10;\n                } else {\n                    prev->val += 1;\n                    temp->val -= 10;\n                }\n            }\n            prev = temp;\n            temp = temp->next;\n        }\n        return head;\n    }\n};", "writer": "AI"}
{"code": "class Solution {\npublic:\n    ListNode* doubleIt(ListNode* head) {\n        if (head->val > 4)\n            head = new ListNode(0, head);\n        for(ListNode* node = head; node; node = node->next) {\n            node->val = (node->val * 2) % 10;\n            if (node->next && node->next->val > 4)\n                node->val++;\n        }\n        return head;\n    }\n};", "writer": "Human"}
{"code": "class Solution {\npublic:\n    int maximumScore(vector<int>& nums, int k) {\n        int n = nums.size();\n        vector<int> left(n, -1), right(n, n);\n        stack<int> st;\n        for(int i = 0; i < n; i++) {\n            while(!st.empty() && nums[st.top()] >= nums[i]) {\n                st.pop();\n            }\n            if(!st.empty()) {\n                left[i] = st.top();\n            }\n            st.push(i);\n        }\n        while(!st.empty()) {\n            st.pop();\n        }\n        for(int i = n - 1; i >= 0; i--) {\n            while(!st.empty() && nums[st.top()] >= nums[i]) {\n                st.pop();\n            }\n            if(!st.empty()) {\n                right[i] = st.top();\n            }\n            st.push(i);\n        }\n        vector<int> primes(100001, 0);\n        for(int i = 2; i <= 100000; i++) {\n            if(primes[i] == 0) {\n                for(int j = i; j <= 100000; j += i) {\n                    primes[j]++;\n                }\n            }\n        }\n        vector<int> dp(n, 0);\n        for(int i = 0; i < n; i++) {\n            dp[i] = nums[i] * (primes[nums[i]] + 1);\n        }\n        for(int i = 1; i < n; i++) {\n            dp[i] = max(dp[i], dp[i - 1]);\n        }\n        int ans = 0;\n        for(int i = 0; i < n; i++) {\n            int l = left[i] + 1, r = right[i] - 1;\n            if(l <= k && k <= r) {\n                ans = max(ans, nums[i] * dp[r]);\n            }\n            if(l <= k - 1 && k - 1 <= r) {\n                ans = max(ans, nums[i] * dp[r]);\n            }\n            if(l <= k && k <= r + 1) {\n                ans = max(ans, nums[i] * dp[r]);\n            }\n            if(l <= k - 1 && k - 1 <= r + 1) {\n                ans = max(ans, nums[i] * dp[r]);\n            }\n        }\n        return ans;\n    }\n};", "writer": "AI"}
{"code": "class Solution {\npublic:\n    const int MOD = 1000000007;\n\n    int maximumScore(vector<int>& nums, int k) {\n        int n = nums.size();\n\n        int upper = *max_element(nums.begin(), nums.end()) + 1;\n\n        vector<bool> prime(upper, true);\n        prime[0] = prime[1] = false;\n        vector<int> primeScore(upper, 0);\n        for (int i = 2; i < upper; i++) {\n            if (prime[i]) {\n                for (int j = i; j < upper; j += i) {\n                    primeScore[j]++;\n                    prime[j] = false;\n                }\n            }\n        }\n\n        vector<int> nextGreaterElement(n, n);\n        stack<int> s;\n        for (int i = n - 1; i >= 0; i--) {\n            while (!s.empty() && primeScore[nums[i]] >= primeScore[nums[s.top()]]) {\n                s.pop();\n            }\n            nextGreaterElement[i] = s.empty() ? n : s.top();\n            s.push(i);\n        }\n\n        vector<int> prevGreaterOrEqualElement(n, -1);\n        s = stack<int>();\n        for (int i = 0; i < n; i++) {\n            while (!s.empty() && primeScore[nums[i]] > primeScore[nums[s.top()]]) {\n                s.pop();\n            }\n            prevGreaterOrEqualElement[i] = s.empty() ? -1 : s.top();\n            s.push(i);\n        }\n\n        int res = 1;\n        vector<pair<int, int>> tuples(n);\n        for (int i = 0; i < n; i++) {\n            tuples[i].first = nums[i];\n            tuples[i].second = i;\n        }\n        sort(tuples.rbegin(), tuples.rend());\n        for (const auto& [num, i] : tuples) {\n            int operations = min((i - prevGreaterOrEqualElement[i]) * (nextGreaterElement[i] - i), k);\n            res = (int)((1L * res * pow(num, operations)) % MOD);\n            k -= operations;\n            if (k == 0) {\n                return res;\n            }\n        }\n\n        return res;\n    }\n\n    int pow(int x, int n) {\n        int res = 1;\n        while (n > 0) {\n            if (n % 2 == 1) {\n                res = (int)((1L * res * x) % MOD);\n            }\n            x = (int)((1L * x * x) % MOD);\n            n /= 2;\n        }\n        return res;\n    }\n};", "writer": "Human"}
{"code": "class Solution {\npublic:\n    long long findMaximumElegance(vector<vector<int>>& items, int k) {\n        int n = items.size();\n        vector<pair<int,int>> v;\n        for(int i=0;i<n;i++){\n            v.push_back({items[i][0],items[i][1]});\n        }\n        sort(v.begin(),v.end(),greater<pair<int,int>>());\n        int i=0;\n        long long ans = 0;\n        unordered_map<int,int> mp;\n        while(i<n && k>0){\n            if(mp[v[i].second]==0){\n                ans += v[i].first;\n                mp[v[i].second]++;\n                k--;\n            }\n            i++;\n        }\n        return ans + (k*k);\n    }\n};", "writer": "AI"}
{"code": "class Solution {\npublic:\n    long long findMaximumElegance(vector<vector<int>>& A, int k) {\n        sort(A.begin(), A.end(), [](const vector<int>& a, const vector<int>& b) {\n            return a[0] > b[0];\n        });\n        long long res = 0, cur = 0;\n        vector<int> dup;\n        unordered_set<int> seen;\n        for (int i = 0; i < A.size(); ++i) {\n            if (i < k) {\n                if (seen.count(A[i][1])) {\n                    dup.push_back(A[i][0]);\n                }\n                cur += A[i][0];\n            } else if (seen.find(A[i][1]) == seen.end()) {\n                if (dup.empty()) break;\n                cur += A[i][0] - dup.back();\n                dup.pop_back();\n            }\n            seen.insert(A[i][1]);\n            res = fmax(res, cur + 1L * seen.size() * seen.size());\n        }\n        return res;\n    }\n};", "writer": "Human"}
{"code": "class Solution {\npublic:    int maxSum(vector<int>& nums) {\n        int n = nums.size();\n        int max_sum = -1;\n        unordered_map<int, int> mp;\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                int sum = nums[i] + nums[j];\n                int max_digit = 0;\n                for (int k = 0; k < 10; k++) {\n                    if (sum % 10 == k) {\n                        max_digit = max(max_digit, k);\n                    }\n                    sum /= 10;\n                }\n                if (mp.find(max_digit)!= mp.end()) {\n                    max_sum = max(max_sum, sum + mp[max_digit]);\n                }\n                mp[max_digit] = sum;\n            }\n        }\n        return max_sum;\n    }\n};", "writer": "AI"}
{"code": "class Solution {\n    public:\n        int maxSum(vector<int>& nums) {\n        int res = -1, max_num[10] = {};\n        for (auto num : nums) {\n            int max_d = 0;\n            for (int v = num; v; v /= 10)\n                max_d = max(max_d, v % 10);\n            if (max_num[max_d])\n                res = max(res, max_num[max_d] + num);\n            max_num[max_d] = max(max_num[max_d], num);\n        }\n        return res;\n    }\n};", "writer": "Human"}
{"code": "class Solution {\npublic:    \n    string finalString(string s) {\n        string res = \"\";\n        for (int i = 0; i < s.length(); i++) {\n            res += s[s.length() - i - 1];\n        }\n        return res;\n    }\n};", "writer": "AI"}
{"code": "class Solution {\npublic:\n    string finalString(const string &s) {\n        string a, b;\n        for (char ch : s)\n            if (ch == 'i')\n                swap(a, b);\n            else\n                a += ch;\n        return string(rbegin(b), rend(b)) + a;\n    }\n};", "writer": "Human"}
{"code": "class Solution {\npublic:    \n    int minAbsoluteDifference(vector<int>& nums, int x) {\n        int min = INT_MAX;\n        int n = nums.size();\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                if (abs(nums[i] - nums[j]) >= x)\n                    continue;\n                min = min < abs(nums[i] - nums[j])? abs(nums[i] - nums[j]) : min;\n            }\n        }\n        return min;\n    }\n};", "writer": "AI"}
{"code": "class Solution {\npublic:\n    int minAbsoluteDifference(vector<int>& nums, int x) {\n        int ans = INT_MAX;\n        set<int> s;\n        for(int i = x; i < nums.size(); ++i){\n            s.insert(nums[i-x]);\n            auto it = s.upper_bound(nums[i]);\n            if(it != s.end()) ans = min(ans, abs(nums[i] - *it));\n            if(it != s.begin()) ans = min(ans, abs(nums[i] - *prev(it)));\n        }\n        return ans;\n    }\n};", "writer": "Human"}
{"code": "class Solution {\npublic:    \n    ListNode* doubleIt(ListNode* head) {\n        if(head == NULL) return NULL;\n        ListNode* cur = head;\n        ListNode* pre = NULL;\n        ListNode* next = NULL;\n        while(cur!= NULL) {\n            next = cur->next;\n            cur->next = pre;\n            pre = cur;\n            cur = next;\n        }\n        cur = pre;\n        while(cur!= NULL) {\n            cur->val *= 2;\n            cur = cur->next;\n        }\n        return pre;\n    }\n};", "writer": "AI"}
{"code": "class Solution {\npublic:\n    ListNode* doubleIt(ListNode* head) {\n        if (head->val > 4)\n            head = new ListNode(0, head);\n        for(ListNode* node = head; node; node = node->next) {\n            node->val = (node->val * 2) % 10;\n            if (node->next && node->next->val > 4)\n                node->val++;\n        }\n        return head;\n    }\n};", "writer": "Human"}
{"code": "class Solution {\npublic:    \n    int getPrimeScore(int num) {\n        int count = 0;\n        for (int i = 2; i * i <= num; i++) {\n            while (num % i == 0) {\n                num /= i;\n                count++;\n            }\n        }\n        return count;\n    }\n\n    int getMaxPrimeScore(vector<int>& nums, int l, int r) {\n        int maxPrimeScore = 0;\n        for (int i = l; i <= r; i++) {\n            maxPrimeScore = max(maxPrimeScore, getPrimeScore(nums[i]));\n        }\n        return maxPrimeScore;\n    }\n\n    int getMaxScore(vector<int>& nums, int l, int r) {\n        int maxScore = 0;\n        for (int i = l; i <= r; i++) {\n            maxScore = max(maxScore, nums[i]);\n        }\n        return maxScore;\n    }\n\n    int maximumScore(vector<int>& nums, int k) {\n        int score = 1;\n        int maxScore = 0;\n\n        int l = 0;\n        int r = nums.size() - 1;\n        \n        for (int i = 0; i < k; i++) {\n            int temp = getMaxScore(nums, l, r);\n            maxScore = max(maxScore, temp);\n            int tempPrimeScore = getMaxPrimeScore(nums, l, r);\n            int tempScore = temp * tempPrimeScore;\n            l = l + 1;\n            r = r - 1;\n        }\n        \n        return maxScore;\n    }\n};", "writer": "AI"}
{"code": "class Solution {\npublic:\n    const int MOD = 1000000007;\n\n    int maximumScore(vector<int>& nums, int k) {\n        int n = nums.size();\n\n        int upper = *max_element(nums.begin(), nums.end()) + 1;\n\n        vector<bool> prime(upper, true);\n        prime[0] = prime[1] = false;\n        vector<int> primeScore(upper, 0);\n        for (int i = 2; i < upper; i++) {\n            if (prime[i]) {\n                for (int j = i; j < upper; j += i) {\n                    primeScore[j]++;\n                    prime[j] = false;\n                }\n            }\n        }\n\n        vector<int> nextGreaterElement(n, n);\n        stack<int> s;\n        for (int i = n - 1; i >= 0; i--) {\n            while (!s.empty() && primeScore[nums[i]] >= primeScore[nums[s.top()]]) {\n                s.pop();\n            }\n            nextGreaterElement[i] = s.empty() ? n : s.top();\n            s.push(i);\n        }\n\n        vector<int> prevGreaterOrEqualElement(n, -1);\n        s = stack<int>();\n        for (int i = 0; i < n; i++) {\n            while (!s.empty() && primeScore[nums[i]] > primeScore[nums[s.top()]]) {\n                s.pop();\n            }\n            prevGreaterOrEqualElement[i] = s.empty() ? -1 : s.top();\n            s.push(i);\n        }\n\n        int res = 1;\n        vector<pair<int, int>> tuples(n);\n        for (int i = 0; i < n; i++) {\n            tuples[i].first = nums[i];\n            tuples[i].second = i;\n        }\n        sort(tuples.rbegin(), tuples.rend());\n        for (const auto& [num, i] : tuples) {\n            int operations = min((i - prevGreaterOrEqualElement[i]) * (nextGreaterElement[i] - i), k);\n            res = (int)((1L * res * pow(num, operations)) % MOD);\n            k -= operations;\n            if (k == 0) {\n                return res;\n            }\n        }\n\n        return res;\n    }\n\n    int pow(int x, int n) {\n        int res = 1;\n        while (n > 0) {\n            if (n % 2 == 1) {\n                res = (int)((1L * res * x) % MOD);\n            }\n            x = (int)((1L * x * x) % MOD);\n            n /= 2;\n        }\n        return res;\n    }\n};", "writer": "Human"}
{"code": "class Solution {\npublic:    long long findMaximumElegance(vector<vector<int>>& items, int k) {\n        int n = items.size();\n        vector<vector<int>> dp(n, vector<int>(2, 0));\n        dp[0][0] = items[0][0];\n        dp[0][1] = 1;\n        for (int i = 1; i < n; i++) {\n            dp[i][0] = max(dp[i - 1][0], items[i][0]);\n            dp[i][1] = dp[i - 1][1] + 1;\n        }\n        long long res = 0;\n        for (int i = 0; i < n - k + 1; i++) {\n            res = max(res, static_cast<long long>(dp[i][0] + dp[i + k - 1][0] + dp[i][1] * dp[i + k - 1][1]));\n        }\n        return res;\n    }\n};", "writer": "AI"}
{"code": "class Solution {\npublic:\n    long long findMaximumElegance(vector<vector<int>>& A, int k) {\n        sort(A.begin(), A.end(), [](const vector<int>& a, const vector<int>& b) {\n            return a[0] > b[0];\n        });\n        long long res = 0, cur = 0;\n        vector<int> dup;\n        unordered_set<int> seen;\n        for (int i = 0; i < A.size(); ++i) {\n            if (i < k) {\n                if (seen.count(A[i][1])) {\n                    dup.push_back(A[i][0]);\n                }\n                cur += A[i][0];\n            } else if (seen.find(A[i][1]) == seen.end()) {\n                if (dup.empty()) break;\n                cur += A[i][0] - dup.back();\n                dup.pop_back();\n            }\n            seen.insert(A[i][1]);\n            res = fmax(res, cur + 1L * seen.size() * seen.size());\n        }\n        return res;\n    }\n};", "writer": "Human"}
{"code": "class Solution {\npublic:\n    int maxSum(vector<int>& nums) {\n    int n=nums.size();\n    int maxi=0;\n    int maxj=0;\n    int maxsum=0;\n    for(int i=0;i<n;i++){\n        for(int j=i+1;j<n;j++){\n            if(nums[i]>maxi){\n                maxi=nums[i];\n            }\n            if(nums[j]>maxj){\n                maxj=nums[j];\n            }\n            if(maxi==maxj){\n                maxsum=max(maxsum,maxi+maxj);\n            }\n        }\n    }\n    if(maxsum==0){\n        return -1;\n    }\n    return maxsum;\n    }\n};", "writer": "AI"}
{"code": "class Solution {\n    public:\n        int maxSum(vector<int>& nums) {\n        int res = -1, max_num[10] = {};\n        for (auto num : nums) {\n            int max_d = 0;\n            for (int v = num; v; v /= 10)\n                max_d = max(max_d, v % 10);\n            if (max_num[max_d])\n                res = max(res, max_num[max_d] + num);\n            max_num[max_d] = max(max_num[max_d], num);\n        }\n        return res;\n    }\n};", "writer": "Human"}
{"code": "class Solution {\npublic:\n    string finalString(string s) {\n    int n=s.length();\n    string ans=\"\";\n    for(int i=0;i<n;i++){\n        if(s[i]=='i'){\n            ans=ans.substr(0,ans.length()-1);\n        }\n        else{\n            ans+=s[i];\n        }\n    }\n    return ans;\n    }\n};", "writer": "AI"}
{"code": "class Solution {\npublic:\n    string finalString(const string &s) {\n        string a, b;\n        for (char ch : s)\n            if (ch == 'i')\n                swap(a, b);\n            else\n                a += ch;\n        return string(rbegin(b), rend(b)) + a;\n    }\n};", "writer": "Human"}
{"code": "class Solution {\npublic:\n    int minAbsoluteDifference(vector<int>& nums, int x) {\n    int n=nums.size();\n    vector<int>v;\n    for(int i=0;i<n;i++)\n    {\n        v.push_back(abs(nums[i]-x));\n    }\n    sort(v.begin(),v.end());\n    int ans=v[0];\n    for(int i=1;i<n;i++)\n    {\n        ans=min(ans,v[i]-v[i-1]);\n    }\n    return ans;\n    }\n};", "writer": "AI"}
{"code": "class Solution {\npublic:\n    int minAbsoluteDifference(vector<int>& nums, int x) {\n        int ans = INT_MAX;\n        set<int> s;\n        for(int i = x; i < nums.size(); ++i){\n            s.insert(nums[i-x]);\n            auto it = s.upper_bound(nums[i]);\n            if(it != s.end()) ans = min(ans, abs(nums[i] - *it));\n            if(it != s.begin()) ans = min(ans, abs(nums[i] - *prev(it)));\n        }\n        return ans;\n    }\n};", "writer": "Human"}
{"code": "class Solution {\npublic:\n    ListNode* doubleIt(ListNode* head) {\n        ListNode* temp=head;\n        while(temp!=NULL){\n            ListNode* temp2=temp->next;\n            temp->next=new ListNode(temp->val);\n            temp->next->next=temp2;\n            temp=temp2;\n        }\n        return head;\n    }\n};", "writer": "AI"}
{"code": "class Solution {\npublic:\n    ListNode* doubleIt(ListNode* head) {\n        if (head->val > 4)\n            head = new ListNode(0, head);\n        for(ListNode* node = head; node; node = node->next) {\n            node->val = (node->val * 2) % 10;\n            if (node->next && node->next->val > 4)\n                node->val++;\n        }\n        return head;\n    }\n};", "writer": "Human"}
{"code": "class Solution {\npublic:\n    int maximumScore(vector<int>& nums, int k) {\n        int MOD=1e9+7;\n        int n=nums.size();\n        vector<int> dp(n+1,0);\n        vector<int> primes;\n        for(int i=2;i<=n;i++) {\n            if(dp[i]==0) {\n                primes.push_back(i);\n                for(int j=i;j<=n;j+=i) {\n                    dp[j]+=1;\n                }\n            }\n        }\n        int ans=0;\n        for(int i=0;i<k;i++) {\n            int mx=0;\n            int mx_idx=-1;\n            for(int j=i;j<n;j++) {\n                if(mx<dp[j]) {\n                    mx=dp[j];\n                    mx_idx=j;\n                }\n            }\n            ans=(ans+nums[mx_idx]*primes[mx-1])%MOD;\n            dp[mx_idx]=0;\n        }\n        return ans;\n    }\n};", "writer": "AI"}
{"code": "class Solution {\npublic:\n    const int MOD = 1000000007;\n\n    int maximumScore(vector<int>& nums, int k) {\n        int n = nums.size();\n\n        int upper = *max_element(nums.begin(), nums.end()) + 1;\n\n        vector<bool> prime(upper, true);\n        prime[0] = prime[1] = false;\n        vector<int> primeScore(upper, 0);\n        for (int i = 2; i < upper; i++) {\n            if (prime[i]) {\n                for (int j = i; j < upper; j += i) {\n                    primeScore[j]++;\n                    prime[j] = false;\n                }\n            }\n        }\n\n        vector<int> nextGreaterElement(n, n);\n        stack<int> s;\n        for (int i = n - 1; i >= 0; i--) {\n            while (!s.empty() && primeScore[nums[i]] >= primeScore[nums[s.top()]]) {\n                s.pop();\n            }\n            nextGreaterElement[i] = s.empty() ? n : s.top();\n            s.push(i);\n        }\n\n        vector<int> prevGreaterOrEqualElement(n, -1);\n        s = stack<int>();\n        for (int i = 0; i < n; i++) {\n            while (!s.empty() && primeScore[nums[i]] > primeScore[nums[s.top()]]) {\n                s.pop();\n            }\n            prevGreaterOrEqualElement[i] = s.empty() ? -1 : s.top();\n            s.push(i);\n        }\n\n        int res = 1;\n        vector<pair<int, int>> tuples(n);\n        for (int i = 0; i < n; i++) {\n            tuples[i].first = nums[i];\n            tuples[i].second = i;\n        }\n        sort(tuples.rbegin(), tuples.rend());\n        for (const auto& [num, i] : tuples) {\n            int operations = min((i - prevGreaterOrEqualElement[i]) * (nextGreaterElement[i] - i), k);\n            res = (int)((1L * res * pow(num, operations)) % MOD);\n            k -= operations;\n            if (k == 0) {\n                return res;\n            }\n        }\n\n        return res;\n    }\n\n    int pow(int x, int n) {\n        int res = 1;\n        while (n > 0) {\n            if (n % 2 == 1) {\n                res = (int)((1L * res * x) % MOD);\n            }\n            x = (int)((1L * x * x) % MOD);\n            n /= 2;\n        }\n        return res;\n    }\n};", "writer": "Human"}
{"code": "class Solution {\npublic:\n    long long findMaximumElegance(vector<vector<int>>& items, int k) {\n  int n=items.size();\n  vector<vector<int>>dp(n,vector<int>(k,0));\n  for(int i=0;i<n;i++)\n  {\n    dp[i][0]=items[i][0];\n  }\n  for(int i=1;i<n;i++)\n  {\n    for(int j=1;j<k;j++)\n    {\n      dp[i][j]=max(dp[i-1][j],dp[i-1][j-1]);\n      if(items[i][1]!=items[i-1][1])\n      {\n        dp[i][j]=max(dp[i][j],dp[i-1][j]+items[i][0]);\n      }\n    }\n  }\n  return dp[n-1][k-1];\n    }\n};", "writer": "AI"}
{"code": "class Solution {\npublic:\n    long long findMaximumElegance(vector<vector<int>>& A, int k) {\n        sort(A.begin(), A.end(), [](const vector<int>& a, const vector<int>& b) {\n            return a[0] > b[0];\n        });\n        long long res = 0, cur = 0;\n        vector<int> dup;\n        unordered_set<int> seen;\n        for (int i = 0; i < A.size(); ++i) {\n            if (i < k) {\n                if (seen.count(A[i][1])) {\n                    dup.push_back(A[i][0]);\n                }\n                cur += A[i][0];\n            } else if (seen.find(A[i][1]) == seen.end()) {\n                if (dup.empty()) break;\n                cur += A[i][0] - dup.back();\n                dup.pop_back();\n            }\n            seen.insert(A[i][1]);\n            res = fmax(res, cur + 1L * seen.size() * seen.size());\n        }\n        return res;\n    }\n};", "writer": "Human"}
