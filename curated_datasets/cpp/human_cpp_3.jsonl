{"code": "class Solution {\n    public:\n        int maxSum(vector<int>& nums) {\n        int res = -1, max_num[10] = {};\n        for (auto num : nums) {\n            int max_d = 0;\n            for (int v = num; v; v /= 10)\n                max_d = max(max_d, v % 10);\n            if (max_num[max_d])\n                res = max(res, max_num[max_d] + num);\n            max_num[max_d] = max(max_num[max_d], num);\n        }\n        return res;\n    }\n};", "language": "C++"}
{"code": "class Solution {\npublic:\n    string finalString(const string &s) {\n        string a, b;\n        for (char ch : s)\n            if (ch == 'i')\n                swap(a, b);\n            else\n                a += ch;\n        return string(rbegin(b), rend(b)) + a;\n    }\n};", "language": "C++"}
{"code": "class Solution {\npublic:\n    int minAbsoluteDifference(vector<int>& nums, int x) {\n        int ans = INT_MAX;\n        set<int> s;\n        for(int i = x; i < nums.size(); ++i){\n            s.insert(nums[i-x]);\n            auto it = s.upper_bound(nums[i]);\n            if(it != s.end()) ans = min(ans, abs(nums[i] - *it));\n            if(it != s.begin()) ans = min(ans, abs(nums[i] - *prev(it)));\n        }\n        return ans;\n    }\n};", "language": "C++"}
{"code": "class Solution {\npublic:\n    ListNode* doubleIt(ListNode* head) {\n        if (head->val > 4)\n            head = new ListNode(0, head);\n        for(ListNode* node = head; node; node = node->next) {\n            node->val = (node->val * 2) % 10;\n            if (node->next && node->next->val > 4)\n                node->val++;\n        }\n        return head;\n    }\n};", "language": "C++"}
{"code": "class Solution {\npublic:\n    const int MOD = 1000000007;\n\n    int maximumScore(vector<int>& nums, int k) {\n        int n = nums.size();\n\n        int upper = *max_element(nums.begin(), nums.end()) + 1;\n\n        vector<bool> prime(upper, true);\n        prime[0] = prime[1] = false;\n        vector<int> primeScore(upper, 0);\n        for (int i = 2; i < upper; i++) {\n            if (prime[i]) {\n                for (int j = i; j < upper; j += i) {\n                    primeScore[j]++;\n                    prime[j] = false;\n                }\n            }\n        }\n\n        vector<int> nextGreaterElement(n, n);\n        stack<int> s;\n        for (int i = n - 1; i >= 0; i--) {\n            while (!s.empty() && primeScore[nums[i]] >= primeScore[nums[s.top()]]) {\n                s.pop();\n            }\n            nextGreaterElement[i] = s.empty() ? n : s.top();\n            s.push(i);\n        }\n\n        vector<int> prevGreaterOrEqualElement(n, -1);\n        s = stack<int>();\n        for (int i = 0; i < n; i++) {\n            while (!s.empty() && primeScore[nums[i]] > primeScore[nums[s.top()]]) {\n                s.pop();\n            }\n            prevGreaterOrEqualElement[i] = s.empty() ? -1 : s.top();\n            s.push(i);\n        }\n\n        int res = 1;\n        vector<pair<int, int>> tuples(n);\n        for (int i = 0; i < n; i++) {\n            tuples[i].first = nums[i];\n            tuples[i].second = i;\n        }\n        sort(tuples.rbegin(), tuples.rend());\n        for (const auto& [num, i] : tuples) {\n            int operations = min((i - prevGreaterOrEqualElement[i]) * (nextGreaterElement[i] - i), k);\n            res = (int)((1L * res * pow(num, operations)) % MOD);\n            k -= operations;\n            if (k == 0) {\n                return res;\n            }\n        }\n\n        return res;\n    }\n\n    int pow(int x, int n) {\n        int res = 1;\n        while (n > 0) {\n            if (n % 2 == 1) {\n                res = (int)((1L * res * x) % MOD);\n            }\n            x = (int)((1L * x * x) % MOD);\n            n /= 2;\n        }\n        return res;\n    }\n};", "language": "C++"}
{"code": "class Solution {\npublic:\n    long long findMaximumElegance(vector<vector<int>>& A, int k) {\n        sort(A.begin(), A.end(), [](const vector<int>& a, const vector<int>& b) {\n            return a[0] > b[0];\n        });\n        long long res = 0, cur = 0;\n        vector<int> dup;\n        unordered_set<int> seen;\n        for (int i = 0; i < A.size(); ++i) {\n            if (i < k) {\n                if (seen.count(A[i][1])) {\n                    dup.push_back(A[i][0]);\n                }\n                cur += A[i][0];\n            } else if (seen.find(A[i][1]) == seen.end()) {\n                if (dup.empty()) break;\n                cur += A[i][0] - dup.back();\n                dup.pop_back();\n            }\n            seen.insert(A[i][1]);\n            res = fmax(res, cur + 1L * seen.size() * seen.size());\n        }\n        return res;\n    }\n};", "language": "C++"}
{"code": "class Solution {\n    public:\n        int maxSum(vector<int>& nums) {\n        int res = -1, max_num[10] = {};\n        for (auto num : nums) {\n            int max_d = 0;\n            for (int v = num; v; v /= 10)\n                max_d = max(max_d, v % 10);\n            if (max_num[max_d])\n                res = max(res, max_num[max_d] + num);\n            max_num[max_d] = max(max_num[max_d], num);\n        }\n        return res;\n    }\n};", "language": "C++"}
{"code": "class Solution {\npublic:\n    string finalString(const string &s) {\n        string a, b;\n        for (char ch : s)\n            if (ch == 'i')\n                swap(a, b);\n            else\n                a += ch;\n        return string(rbegin(b), rend(b)) + a;\n    }\n};", "language": "C++"}
{"code": "class Solution {\npublic:\n    int minAbsoluteDifference(vector<int>& nums, int x) {\n        int ans = INT_MAX;\n        set<int> s;\n        for(int i = x; i < nums.size(); ++i){\n            s.insert(nums[i-x]);\n            auto it = s.upper_bound(nums[i]);\n            if(it != s.end()) ans = min(ans, abs(nums[i] - *it));\n            if(it != s.begin()) ans = min(ans, abs(nums[i] - *prev(it)));\n        }\n        return ans;\n    }\n};", "language": "C++"}
{"code": "class Solution {\npublic:\n    ListNode* doubleIt(ListNode* head) {\n        if (head->val > 4)\n            head = new ListNode(0, head);\n        for(ListNode* node = head; node; node = node->next) {\n            node->val = (node->val * 2) % 10;\n            if (node->next && node->next->val > 4)\n                node->val++;\n        }\n        return head;\n    }\n};", "language": "C++"}
{"code": "class Solution {\npublic:\n    const int MOD = 1000000007;\n\n    int maximumScore(vector<int>& nums, int k) {\n        int n = nums.size();\n\n        int upper = *max_element(nums.begin(), nums.end()) + 1;\n\n        vector<bool> prime(upper, true);\n        prime[0] = prime[1] = false;\n        vector<int> primeScore(upper, 0);\n        for (int i = 2; i < upper; i++) {\n            if (prime[i]) {\n                for (int j = i; j < upper; j += i) {\n                    primeScore[j]++;\n                    prime[j] = false;\n                }\n            }\n        }\n\n        vector<int> nextGreaterElement(n, n);\n        stack<int> s;\n        for (int i = n - 1; i >= 0; i--) {\n            while (!s.empty() && primeScore[nums[i]] >= primeScore[nums[s.top()]]) {\n                s.pop();\n            }\n            nextGreaterElement[i] = s.empty() ? n : s.top();\n            s.push(i);\n        }\n\n        vector<int> prevGreaterOrEqualElement(n, -1);\n        s = stack<int>();\n        for (int i = 0; i < n; i++) {\n            while (!s.empty() && primeScore[nums[i]] > primeScore[nums[s.top()]]) {\n                s.pop();\n            }\n            prevGreaterOrEqualElement[i] = s.empty() ? -1 : s.top();\n            s.push(i);\n        }\n\n        int res = 1;\n        vector<pair<int, int>> tuples(n);\n        for (int i = 0; i < n; i++) {\n            tuples[i].first = nums[i];\n            tuples[i].second = i;\n        }\n        sort(tuples.rbegin(), tuples.rend());\n        for (const auto& [num, i] : tuples) {\n            int operations = min((i - prevGreaterOrEqualElement[i]) * (nextGreaterElement[i] - i), k);\n            res = (int)((1L * res * pow(num, operations)) % MOD);\n            k -= operations;\n            if (k == 0) {\n                return res;\n            }\n        }\n\n        return res;\n    }\n\n    int pow(int x, int n) {\n        int res = 1;\n        while (n > 0) {\n            if (n % 2 == 1) {\n                res = (int)((1L * res * x) % MOD);\n            }\n            x = (int)((1L * x * x) % MOD);\n            n /= 2;\n        }\n        return res;\n    }\n};", "language": "C++"}
{"code": "class Solution {\npublic:\n    long long findMaximumElegance(vector<vector<int>>& A, int k) {\n        sort(A.begin(), A.end(), [](const vector<int>& a, const vector<int>& b) {\n            return a[0] > b[0];\n        });\n        long long res = 0, cur = 0;\n        vector<int> dup;\n        unordered_set<int> seen;\n        for (int i = 0; i < A.size(); ++i) {\n            if (i < k) {\n                if (seen.count(A[i][1])) {\n                    dup.push_back(A[i][0]);\n                }\n                cur += A[i][0];\n            } else if (seen.find(A[i][1]) == seen.end()) {\n                if (dup.empty()) break;\n                cur += A[i][0] - dup.back();\n                dup.pop_back();\n            }\n            seen.insert(A[i][1]);\n            res = fmax(res, cur + 1L * seen.size() * seen.size());\n        }\n        return res;\n    }\n};", "language": "C++"}
{"code": "class Solution {\n    public:\n        int maxSum(vector<int>& nums) {\n        int res = -1, max_num[10] = {};\n        for (auto num : nums) {\n            int max_d = 0;\n            for (int v = num; v; v /= 10)\n                max_d = max(max_d, v % 10);\n            if (max_num[max_d])\n                res = max(res, max_num[max_d] + num);\n            max_num[max_d] = max(max_num[max_d], num);\n        }\n        return res;\n    }\n};", "language": "C++"}
{"code": "class Solution {\npublic:\n    string finalString(const string &s) {\n        string a, b;\n        for (char ch : s)\n            if (ch == 'i')\n                swap(a, b);\n            else\n                a += ch;\n        return string(rbegin(b), rend(b)) + a;\n    }\n};", "language": "C++"}
{"code": "class Solution {\npublic:\n    int minAbsoluteDifference(vector<int>& nums, int x) {\n        int ans = INT_MAX;\n        set<int> s;\n        for(int i = x; i < nums.size(); ++i){\n            s.insert(nums[i-x]);\n            auto it = s.upper_bound(nums[i]);\n            if(it != s.end()) ans = min(ans, abs(nums[i] - *it));\n            if(it != s.begin()) ans = min(ans, abs(nums[i] - *prev(it)));\n        }\n        return ans;\n    }\n};", "language": "C++"}
{"code": "class Solution {\npublic:\n    ListNode* doubleIt(ListNode* head) {\n        if (head->val > 4)\n            head = new ListNode(0, head);\n        for(ListNode* node = head; node; node = node->next) {\n            node->val = (node->val * 2) % 10;\n            if (node->next && node->next->val > 4)\n                node->val++;\n        }\n        return head;\n    }\n};", "language": "C++"}
{"code": "class Solution {\npublic:\n    const int MOD = 1000000007;\n\n    int maximumScore(vector<int>& nums, int k) {\n        int n = nums.size();\n\n        int upper = *max_element(nums.begin(), nums.end()) + 1;\n\n        vector<bool> prime(upper, true);\n        prime[0] = prime[1] = false;\n        vector<int> primeScore(upper, 0);\n        for (int i = 2; i < upper; i++) {\n            if (prime[i]) {\n                for (int j = i; j < upper; j += i) {\n                    primeScore[j]++;\n                    prime[j] = false;\n                }\n            }\n        }\n\n        vector<int> nextGreaterElement(n, n);\n        stack<int> s;\n        for (int i = n - 1; i >= 0; i--) {\n            while (!s.empty() && primeScore[nums[i]] >= primeScore[nums[s.top()]]) {\n                s.pop();\n            }\n            nextGreaterElement[i] = s.empty() ? n : s.top();\n            s.push(i);\n        }\n\n        vector<int> prevGreaterOrEqualElement(n, -1);\n        s = stack<int>();\n        for (int i = 0; i < n; i++) {\n            while (!s.empty() && primeScore[nums[i]] > primeScore[nums[s.top()]]) {\n                s.pop();\n            }\n            prevGreaterOrEqualElement[i] = s.empty() ? -1 : s.top();\n            s.push(i);\n        }\n\n        int res = 1;\n        vector<pair<int, int>> tuples(n);\n        for (int i = 0; i < n; i++) {\n            tuples[i].first = nums[i];\n            tuples[i].second = i;\n        }\n        sort(tuples.rbegin(), tuples.rend());\n        for (const auto& [num, i] : tuples) {\n            int operations = min((i - prevGreaterOrEqualElement[i]) * (nextGreaterElement[i] - i), k);\n            res = (int)((1L * res * pow(num, operations)) % MOD);\n            k -= operations;\n            if (k == 0) {\n                return res;\n            }\n        }\n\n        return res;\n    }\n\n    int pow(int x, int n) {\n        int res = 1;\n        while (n > 0) {\n            if (n % 2 == 1) {\n                res = (int)((1L * res * x) % MOD);\n            }\n            x = (int)((1L * x * x) % MOD);\n            n /= 2;\n        }\n        return res;\n    }\n};", "language": "C++"}
{"code": "class Solution {\npublic:\n    long long findMaximumElegance(vector<vector<int>>& A, int k) {\n        sort(A.begin(), A.end(), [](const vector<int>& a, const vector<int>& b) {\n            return a[0] > b[0];\n        });\n        long long res = 0, cur = 0;\n        vector<int> dup;\n        unordered_set<int> seen;\n        for (int i = 0; i < A.size(); ++i) {\n            if (i < k) {\n                if (seen.count(A[i][1])) {\n                    dup.push_back(A[i][0]);\n                }\n                cur += A[i][0];\n            } else if (seen.find(A[i][1]) == seen.end()) {\n                if (dup.empty()) break;\n                cur += A[i][0] - dup.back();\n                dup.pop_back();\n            }\n            seen.insert(A[i][1]);\n            res = fmax(res, cur + 1L * seen.size() * seen.size());\n        }\n        return res;\n    }\n};", "language": "C++"}
{"code": "class Solution {\n    public:\n        int maxSum(vector<int>& nums) {\n        int res = -1, max_num[10] = {};\n        for (auto num : nums) {\n            int max_d = 0;\n            for (int v = num; v; v /= 10)\n                max_d = max(max_d, v % 10);\n            if (max_num[max_d])\n                res = max(res, max_num[max_d] + num);\n            max_num[max_d] = max(max_num[max_d], num);\n        }\n        return res;\n    }\n};", "language": "C++"}
{"code": "class Solution {\npublic:\n    string finalString(const string &s) {\n        string a, b;\n        for (char ch : s)\n            if (ch == 'i')\n                swap(a, b);\n            else\n                a += ch;\n        return string(rbegin(b), rend(b)) + a;\n    }\n};", "language": "C++"}
{"code": "class Solution {\npublic:\n    int minAbsoluteDifference(vector<int>& nums, int x) {\n        int ans = INT_MAX;\n        set<int> s;\n        for(int i = x; i < nums.size(); ++i){\n            s.insert(nums[i-x]);\n            auto it = s.upper_bound(nums[i]);\n            if(it != s.end()) ans = min(ans, abs(nums[i] - *it));\n            if(it != s.begin()) ans = min(ans, abs(nums[i] - *prev(it)));\n        }\n        return ans;\n    }\n};", "language": "C++"}
{"code": "class Solution {\npublic:\n    ListNode* doubleIt(ListNode* head) {\n        if (head->val > 4)\n            head = new ListNode(0, head);\n        for(ListNode* node = head; node; node = node->next) {\n            node->val = (node->val * 2) % 10;\n            if (node->next && node->next->val > 4)\n                node->val++;\n        }\n        return head;\n    }\n};", "language": "C++"}
{"code": "class Solution {\npublic:\n    const int MOD = 1000000007;\n\n    int maximumScore(vector<int>& nums, int k) {\n        int n = nums.size();\n\n        int upper = *max_element(nums.begin(), nums.end()) + 1;\n\n        vector<bool> prime(upper, true);\n        prime[0] = prime[1] = false;\n        vector<int> primeScore(upper, 0);\n        for (int i = 2; i < upper; i++) {\n            if (prime[i]) {\n                for (int j = i; j < upper; j += i) {\n                    primeScore[j]++;\n                    prime[j] = false;\n                }\n            }\n        }\n\n        vector<int> nextGreaterElement(n, n);\n        stack<int> s;\n        for (int i = n - 1; i >= 0; i--) {\n            while (!s.empty() && primeScore[nums[i]] >= primeScore[nums[s.top()]]) {\n                s.pop();\n            }\n            nextGreaterElement[i] = s.empty() ? n : s.top();\n            s.push(i);\n        }\n\n        vector<int> prevGreaterOrEqualElement(n, -1);\n        s = stack<int>();\n        for (int i = 0; i < n; i++) {\n            while (!s.empty() && primeScore[nums[i]] > primeScore[nums[s.top()]]) {\n                s.pop();\n            }\n            prevGreaterOrEqualElement[i] = s.empty() ? -1 : s.top();\n            s.push(i);\n        }\n\n        int res = 1;\n        vector<pair<int, int>> tuples(n);\n        for (int i = 0; i < n; i++) {\n            tuples[i].first = nums[i];\n            tuples[i].second = i;\n        }\n        sort(tuples.rbegin(), tuples.rend());\n        for (const auto& [num, i] : tuples) {\n            int operations = min((i - prevGreaterOrEqualElement[i]) * (nextGreaterElement[i] - i), k);\n            res = (int)((1L * res * pow(num, operations)) % MOD);\n            k -= operations;\n            if (k == 0) {\n                return res;\n            }\n        }\n\n        return res;\n    }\n\n    int pow(int x, int n) {\n        int res = 1;\n        while (n > 0) {\n            if (n % 2 == 1) {\n                res = (int)((1L * res * x) % MOD);\n            }\n            x = (int)((1L * x * x) % MOD);\n            n /= 2;\n        }\n        return res;\n    }\n};", "language": "C++"}
{"code": "class Solution {\npublic:\n    long long findMaximumElegance(vector<vector<int>>& A, int k) {\n        sort(A.begin(), A.end(), [](const vector<int>& a, const vector<int>& b) {\n            return a[0] > b[0];\n        });\n        long long res = 0, cur = 0;\n        vector<int> dup;\n        unordered_set<int> seen;\n        for (int i = 0; i < A.size(); ++i) {\n            if (i < k) {\n                if (seen.count(A[i][1])) {\n                    dup.push_back(A[i][0]);\n                }\n                cur += A[i][0];\n            } else if (seen.find(A[i][1]) == seen.end()) {\n                if (dup.empty()) break;\n                cur += A[i][0] - dup.back();\n                dup.pop_back();\n            }\n            seen.insert(A[i][1]);\n            res = fmax(res, cur + 1L * seen.size() * seen.size());\n        }\n        return res;\n    }\n};", "language": "C++"}
{"code": "class Solution {\n    public:\n        int maxSum(vector<int>& nums) {\n        int res = -1, max_num[10] = {};\n        for (auto num : nums) {\n            int max_d = 0;\n            for (int v = num; v; v /= 10)\n                max_d = max(max_d, v % 10);\n            if (max_num[max_d])\n                res = max(res, max_num[max_d] + num);\n            max_num[max_d] = max(max_num[max_d], num);\n        }\n        return res;\n    }\n};", "language": "C++"}
{"code": "class Solution {\npublic:\n    string finalString(const string &s) {\n        string a, b;\n        for (char ch : s)\n            if (ch == 'i')\n                swap(a, b);\n            else\n                a += ch;\n        return string(rbegin(b), rend(b)) + a;\n    }\n};", "language": "C++"}
{"code": "class Solution {\npublic:\n    int minAbsoluteDifference(vector<int>& nums, int x) {\n        int ans = INT_MAX;\n        set<int> s;\n        for(int i = x; i < nums.size(); ++i){\n            s.insert(nums[i-x]);\n            auto it = s.upper_bound(nums[i]);\n            if(it != s.end()) ans = min(ans, abs(nums[i] - *it));\n            if(it != s.begin()) ans = min(ans, abs(nums[i] - *prev(it)));\n        }\n        return ans;\n    }\n};", "language": "C++"}
{"code": "class Solution {\npublic:\n    ListNode* doubleIt(ListNode* head) {\n        if (head->val > 4)\n            head = new ListNode(0, head);\n        for(ListNode* node = head; node; node = node->next) {\n            node->val = (node->val * 2) % 10;\n            if (node->next && node->next->val > 4)\n                node->val++;\n        }\n        return head;\n    }\n};", "language": "C++"}
{"code": "class Solution {\npublic:\n    const int MOD = 1000000007;\n\n    int maximumScore(vector<int>& nums, int k) {\n        int n = nums.size();\n\n        int upper = *max_element(nums.begin(), nums.end()) + 1;\n\n        vector<bool> prime(upper, true);\n        prime[0] = prime[1] = false;\n        vector<int> primeScore(upper, 0);\n        for (int i = 2; i < upper; i++) {\n            if (prime[i]) {\n                for (int j = i; j < upper; j += i) {\n                    primeScore[j]++;\n                    prime[j] = false;\n                }\n            }\n        }\n\n        vector<int> nextGreaterElement(n, n);\n        stack<int> s;\n        for (int i = n - 1; i >= 0; i--) {\n            while (!s.empty() && primeScore[nums[i]] >= primeScore[nums[s.top()]]) {\n                s.pop();\n            }\n            nextGreaterElement[i] = s.empty() ? n : s.top();\n            s.push(i);\n        }\n\n        vector<int> prevGreaterOrEqualElement(n, -1);\n        s = stack<int>();\n        for (int i = 0; i < n; i++) {\n            while (!s.empty() && primeScore[nums[i]] > primeScore[nums[s.top()]]) {\n                s.pop();\n            }\n            prevGreaterOrEqualElement[i] = s.empty() ? -1 : s.top();\n            s.push(i);\n        }\n\n        int res = 1;\n        vector<pair<int, int>> tuples(n);\n        for (int i = 0; i < n; i++) {\n            tuples[i].first = nums[i];\n            tuples[i].second = i;\n        }\n        sort(tuples.rbegin(), tuples.rend());\n        for (const auto& [num, i] : tuples) {\n            int operations = min((i - prevGreaterOrEqualElement[i]) * (nextGreaterElement[i] - i), k);\n            res = (int)((1L * res * pow(num, operations)) % MOD);\n            k -= operations;\n            if (k == 0) {\n                return res;\n            }\n        }\n\n        return res;\n    }\n\n    int pow(int x, int n) {\n        int res = 1;\n        while (n > 0) {\n            if (n % 2 == 1) {\n                res = (int)((1L * res * x) % MOD);\n            }\n            x = (int)((1L * x * x) % MOD);\n            n /= 2;\n        }\n        return res;\n    }\n};", "language": "C++"}
{"code": "class Solution {\npublic:\n    long long findMaximumElegance(vector<vector<int>>& A, int k) {\n        sort(A.begin(), A.end(), [](const vector<int>& a, const vector<int>& b) {\n            return a[0] > b[0];\n        });\n        long long res = 0, cur = 0;\n        vector<int> dup;\n        unordered_set<int> seen;\n        for (int i = 0; i < A.size(); ++i) {\n            if (i < k) {\n                if (seen.count(A[i][1])) {\n                    dup.push_back(A[i][0]);\n                }\n                cur += A[i][0];\n            } else if (seen.find(A[i][1]) == seen.end()) {\n                if (dup.empty()) break;\n                cur += A[i][0] - dup.back();\n                dup.pop_back();\n            }\n            seen.insert(A[i][1]);\n            res = fmax(res, cur + 1L * seen.size() * seen.size());\n        }\n        return res;\n    }\n};", "language": "C++"}
{"code": "class Solution {\n    public:\n        int maxSum(vector<int>& nums) {\n        int res = -1, max_num[10] = {};\n        for (auto num : nums) {\n            int max_d = 0;\n            for (int v = num; v; v /= 10)\n                max_d = max(max_d, v % 10);\n            if (max_num[max_d])\n                res = max(res, max_num[max_d] + num);\n            max_num[max_d] = max(max_num[max_d], num);\n        }\n        return res;\n    }\n};", "language": "C++"}
{"code": "class Solution {\npublic:\n    string finalString(const string &s) {\n        string a, b;\n        for (char ch : s)\n            if (ch == 'i')\n                swap(a, b);\n            else\n                a += ch;\n        return string(rbegin(b), rend(b)) + a;\n    }\n};", "language": "C++"}
{"code": "class Solution {\npublic:\n    int minAbsoluteDifference(vector<int>& nums, int x) {\n        int ans = INT_MAX;\n        set<int> s;\n        for(int i = x; i < nums.size(); ++i){\n            s.insert(nums[i-x]);\n            auto it = s.upper_bound(nums[i]);\n            if(it != s.end()) ans = min(ans, abs(nums[i] - *it));\n            if(it != s.begin()) ans = min(ans, abs(nums[i] - *prev(it)));\n        }\n        return ans;\n    }\n};", "language": "C++"}
{"code": "class Solution {\npublic:\n    ListNode* doubleIt(ListNode* head) {\n        if (head->val > 4)\n            head = new ListNode(0, head);\n        for(ListNode* node = head; node; node = node->next) {\n            node->val = (node->val * 2) % 10;\n            if (node->next && node->next->val > 4)\n                node->val++;\n        }\n        return head;\n    }\n};", "language": "C++"}
{"code": "class Solution {\npublic:\n    const int MOD = 1000000007;\n\n    int maximumScore(vector<int>& nums, int k) {\n        int n = nums.size();\n\n        int upper = *max_element(nums.begin(), nums.end()) + 1;\n\n        vector<bool> prime(upper, true);\n        prime[0] = prime[1] = false;\n        vector<int> primeScore(upper, 0);\n        for (int i = 2; i < upper; i++) {\n            if (prime[i]) {\n                for (int j = i; j < upper; j += i) {\n                    primeScore[j]++;\n                    prime[j] = false;\n                }\n            }\n        }\n\n        vector<int> nextGreaterElement(n, n);\n        stack<int> s;\n        for (int i = n - 1; i >= 0; i--) {\n            while (!s.empty() && primeScore[nums[i]] >= primeScore[nums[s.top()]]) {\n                s.pop();\n            }\n            nextGreaterElement[i] = s.empty() ? n : s.top();\n            s.push(i);\n        }\n\n        vector<int> prevGreaterOrEqualElement(n, -1);\n        s = stack<int>();\n        for (int i = 0; i < n; i++) {\n            while (!s.empty() && primeScore[nums[i]] > primeScore[nums[s.top()]]) {\n                s.pop();\n            }\n            prevGreaterOrEqualElement[i] = s.empty() ? -1 : s.top();\n            s.push(i);\n        }\n\n        int res = 1;\n        vector<pair<int, int>> tuples(n);\n        for (int i = 0; i < n; i++) {\n            tuples[i].first = nums[i];\n            tuples[i].second = i;\n        }\n        sort(tuples.rbegin(), tuples.rend());\n        for (const auto& [num, i] : tuples) {\n            int operations = min((i - prevGreaterOrEqualElement[i]) * (nextGreaterElement[i] - i), k);\n            res = (int)((1L * res * pow(num, operations)) % MOD);\n            k -= operations;\n            if (k == 0) {\n                return res;\n            }\n        }\n\n        return res;\n    }\n\n    int pow(int x, int n) {\n        int res = 1;\n        while (n > 0) {\n            if (n % 2 == 1) {\n                res = (int)((1L * res * x) % MOD);\n            }\n            x = (int)((1L * x * x) % MOD);\n            n /= 2;\n        }\n        return res;\n    }\n};", "language": "C++"}
{"code": "class Solution {\npublic:\n    long long findMaximumElegance(vector<vector<int>>& A, int k) {\n        sort(A.begin(), A.end(), [](const vector<int>& a, const vector<int>& b) {\n            return a[0] > b[0];\n        });\n        long long res = 0, cur = 0;\n        vector<int> dup;\n        unordered_set<int> seen;\n        for (int i = 0; i < A.size(); ++i) {\n            if (i < k) {\n                if (seen.count(A[i][1])) {\n                    dup.push_back(A[i][0]);\n                }\n                cur += A[i][0];\n            } else if (seen.find(A[i][1]) == seen.end()) {\n                if (dup.empty()) break;\n                cur += A[i][0] - dup.back();\n                dup.pop_back();\n            }\n            seen.insert(A[i][1]);\n            res = fmax(res, cur + 1L * seen.size() * seen.size());\n        }\n        return res;\n    }\n};", "language": "C++"}
{"code": "class Solution {\n    public:\n        int maxSum(vector<int>& nums) {\n        int res = -1, max_num[10] = {};\n        for (auto num : nums) {\n            int max_d = 0;\n            for (int v = num; v; v /= 10)\n                max_d = max(max_d, v % 10);\n            if (max_num[max_d])\n                res = max(res, max_num[max_d] + num);\n            max_num[max_d] = max(max_num[max_d], num);\n        }\n        return res;\n    }\n};", "language": "C++"}
{"code": "class Solution {\npublic:\n    string finalString(const string &s) {\n        string a, b;\n        for (char ch : s)\n            if (ch == 'i')\n                swap(a, b);\n            else\n                a += ch;\n        return string(rbegin(b), rend(b)) + a;\n    }\n};", "language": "C++"}
{"code": "class Solution {\npublic:\n    int minAbsoluteDifference(vector<int>& nums, int x) {\n        int ans = INT_MAX;\n        set<int> s;\n        for(int i = x; i < nums.size(); ++i){\n            s.insert(nums[i-x]);\n            auto it = s.upper_bound(nums[i]);\n            if(it != s.end()) ans = min(ans, abs(nums[i] - *it));\n            if(it != s.begin()) ans = min(ans, abs(nums[i] - *prev(it)));\n        }\n        return ans;\n    }\n};", "language": "C++"}
{"code": "class Solution {\npublic:\n    ListNode* doubleIt(ListNode* head) {\n        if (head->val > 4)\n            head = new ListNode(0, head);\n        for(ListNode* node = head; node; node = node->next) {\n            node->val = (node->val * 2) % 10;\n            if (node->next && node->next->val > 4)\n                node->val++;\n        }\n        return head;\n    }\n};", "language": "C++"}
{"code": "class Solution {\npublic:\n    const int MOD = 1000000007;\n\n    int maximumScore(vector<int>& nums, int k) {\n        int n = nums.size();\n\n        int upper = *max_element(nums.begin(), nums.end()) + 1;\n\n        vector<bool> prime(upper, true);\n        prime[0] = prime[1] = false;\n        vector<int> primeScore(upper, 0);\n        for (int i = 2; i < upper; i++) {\n            if (prime[i]) {\n                for (int j = i; j < upper; j += i) {\n                    primeScore[j]++;\n                    prime[j] = false;\n                }\n            }\n        }\n\n        vector<int> nextGreaterElement(n, n);\n        stack<int> s;\n        for (int i = n - 1; i >= 0; i--) {\n            while (!s.empty() && primeScore[nums[i]] >= primeScore[nums[s.top()]]) {\n                s.pop();\n            }\n            nextGreaterElement[i] = s.empty() ? n : s.top();\n            s.push(i);\n        }\n\n        vector<int> prevGreaterOrEqualElement(n, -1);\n        s = stack<int>();\n        for (int i = 0; i < n; i++) {\n            while (!s.empty() && primeScore[nums[i]] > primeScore[nums[s.top()]]) {\n                s.pop();\n            }\n            prevGreaterOrEqualElement[i] = s.empty() ? -1 : s.top();\n            s.push(i);\n        }\n\n        int res = 1;\n        vector<pair<int, int>> tuples(n);\n        for (int i = 0; i < n; i++) {\n            tuples[i].first = nums[i];\n            tuples[i].second = i;\n        }\n        sort(tuples.rbegin(), tuples.rend());\n        for (const auto& [num, i] : tuples) {\n            int operations = min((i - prevGreaterOrEqualElement[i]) * (nextGreaterElement[i] - i), k);\n            res = (int)((1L * res * pow(num, operations)) % MOD);\n            k -= operations;\n            if (k == 0) {\n                return res;\n            }\n        }\n\n        return res;\n    }\n\n    int pow(int x, int n) {\n        int res = 1;\n        while (n > 0) {\n            if (n % 2 == 1) {\n                res = (int)((1L * res * x) % MOD);\n            }\n            x = (int)((1L * x * x) % MOD);\n            n /= 2;\n        }\n        return res;\n    }\n};", "language": "C++"}
{"code": "class Solution {\npublic:\n    long long findMaximumElegance(vector<vector<int>>& A, int k) {\n        sort(A.begin(), A.end(), [](const vector<int>& a, const vector<int>& b) {\n            return a[0] > b[0];\n        });\n        long long res = 0, cur = 0;\n        vector<int> dup;\n        unordered_set<int> seen;\n        for (int i = 0; i < A.size(); ++i) {\n            if (i < k) {\n                if (seen.count(A[i][1])) {\n                    dup.push_back(A[i][0]);\n                }\n                cur += A[i][0];\n            } else if (seen.find(A[i][1]) == seen.end()) {\n                if (dup.empty()) break;\n                cur += A[i][0] - dup.back();\n                dup.pop_back();\n            }\n            seen.insert(A[i][1]);\n            res = fmax(res, cur + 1L * seen.size() * seen.size());\n        }\n        return res;\n    }\n};", "language": "C++"}
